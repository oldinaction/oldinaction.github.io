---
layout: "post"
title: "分布式架构原理及选型方案"
date: "2019-09-03 14:22"
categories: [arch]
tags: [mq]
---

## 分布式锁

- 分布式锁一般有三种实现方式
    - 数据库乐观锁
    - [基于Redis的分布式锁](/_posts/db/redis.md#实现分布式锁)
      - 缺点：单节点可用性不高；主备复制时同步写入的数据存在延迟（写入主后，主挂掉了）；官方增加的RedLock算法，实现复杂，算法可用性存在质疑（将锁记录写入到多个节点中，然后判断超过一半以上成功的则认为加锁成功）
    - [基于ZooKeeper的分布式锁](/_posts/arch/zookeeper.md#实现分布式锁)
- 为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件
    - 互斥性。在任意时刻，只有一个客户端能持有锁
    - 不会发生死锁
    - 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁
    - 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了

## 分布式事务

- https://www.cnblogs.com/bluemiaomiao/p/11216380.html
- TCC事务补偿型
- 最大努力通知型
- 基于可靠消息的最终一致性方案

## MQ

- MQ优缺点
  - 优点：解耦、异步、削峰
  - 缺点：系统可用性降低、存在一致性问题、系统复杂度提高
- ActiveMQ、RabbitMQ、RocketMQ、Kafka对比

    ![mq](/data/images/arch/mq.png)
- 消息丢失问题（如网络波动导致）：如果消息未被确认，或确认失败，可以使用定时任务来进行消息重试
- 保证消息不被重复消费（消息"丢失"带来的消息重复）：让每个消息携带一个全局的唯一ID（如UUID），并增加消息消费状态字段，即可保证消息的幂等性
- 消息堆积的问题
  - 定时删除旧的没有使用过的消息信息（重要性不高的消息）
  - 对某些重要的 TAG 型（支付型）消息进行落库
- 保证消息消费的顺序性
  - RabbitMQ：一个 queue，多个 consumer就可能导致消息乱序消费。因此可拆分多个 queue，每个 queue 一个 consumer





