---
layout: "post"
title: "算法(algorithms)"
date: "2017-04-24 19:55"
categories: [linux]
tags: [arch]
---

## 预备知识

- 数据结构与算法
    - 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素、删除某个元素、对所有元素进行排序）而执行的相应操作，这个相应的操作叫算法。
	- 数据结构 = 个体 + 个体的关系
	- 算法 = 对存储数据的操作
- 数据结构举例
    - 存储15个人可以用数组(需要连续的存储空间)
	- 存储10000个人可能数组无法存储，可以使用链表(无需联系存储空间，将零散的空间连接起来)
	- 存储人事关系就需要用到树(数组、联表都无法体现上下级关系)
	- 存储交通图就需要用到图(每个地点都有可能连接起来)
- 衡量算法的标准
	- 时间复杂度：程序中最大循环语句循环的次数
	- 空间复杂度：算法执行过程中占用的最大内存
	- 难易程度
	- 健壮性
- 内存
	- 内存是用来存储数据的设备。它的速度介于寄存器（CPU中）和硬盘之间
	- 内存是CPU唯一可以访问的大容量存储设备（CPU还可以访问寄存器，不能操作硬盘。可以把硬盘上的数据读取到内存供CPU使用 ）
	- 内存是多字节组成的线性一维空间
	- 内存的基本划分单位是字节，每个字节含8位（栈图形中的一个横格标识一个字节）
	- 字节和编号是一一对应的。每个字节都有一个唯一确定的编号，一个编号对应一个字节。这个编号也叫地址
	- 一个系统所能管理的内存空间的大小取决于参与编号的二进制位数。如DOS系统20位寻址方案，可控制220B,即1M内存；奔腾系统32位寻址空间，其有效寻址空间为232M，即4GB
	- 软件在运行前需要向操作系统申请存储空间，在内存空闲空间足够时，操作系统将分配一段内存空间。软件在运行期间，该软件所占用内存空间不再分配给其他软件。当软件运行完毕，操作系统回收该内存空间
	- CPU控制内存有3个方面：地址线操作内存的地址分配，控制线操作该内存的读写方式，数据线操作数据填充到内存中
- 指针

    ```c++
    int i = 10;
    int * p = &i; // 整型指针, 其中空格加不加都可以
    int a[5] = {1, 2, 3, 4, 5};
    // 等价于：int *p; p = &i;
    // (1) p存放了i的地址, 所以p指向了i.
    // (2) p和i是两个完全不同的变量，修改其中任何一个变量的值都不会影响另外一个
    // (3) p指向了i, *p就是i变量本身, i和*p在之后的所有地方都可以互换
    // (4) 如果p为指针变量, i为普通变量. 则*p相当于普通变量, &i(取地址i)相当于普通变量的地址
    ```
	- 指针变量（如上述p）也是变量，只不过它存放的不能是内存单元的内容，只能存放内存单元的地址。普通变量（如上述i）前不能加*，常量和表达式前不能加&
	- 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数（0xbfebd5c0）。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同
	- 指针变量所占字节因机器不同所占的字节数也有所不同。在32位的机器上，一个指针变量占4个字节，在64位的机器上，一个指针变量占8个字节。（64位电脑测试确仍然占用4个字节，与编译器为了兼容有关）
	- 一维数组
		- 一维数组名是个指针常量，他存放一维数组第一个元素的地址，他的值不能被改变。`a[i]` 等价于 `*(a+i)`
		- 如果p为指针变量，p++等价于p+1。相当于p的下一个地址（double * p; 此时p存放某个double变量的地址0x000000, p+1则是基于此地址加8个字节，即0x000008）

## 基础知识

- 评定算法优劣
    - 时间复杂度(流程决定)
    - 额外空间复杂度(流程决定。与功能无关，流程执行过程中必须申请的空间)
    - 常数项时间(实现细节决定)
- 最差情况的复杂度使用O记录(读做big o)
- 常数时间操作：行时间固定的，和样本无关的即为常数时间操作
    - 加减乘除运算
    - `>>`、`>>>`、`^`等
    - 数组寻址操作(基于数组下标取值)
- 对数器：生成随机样例，测试算法的程序

### 二进制运算

- 异或运算
    - 无进位则相加
    - 同样一批数，不考虑顺序，异或结果一样
    - `0^N == N`，`N^N == 0`
    - 案例
        - 一个数组中有一个数出现了奇数次，其他数出现了偶数次，怎么找到并打印这个数
            - `int eor = 0; for { eor = eor ^ arr[i] }; print eor`
        - 一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到这两种数并打印
        - 计算一个二进制数出现1的次数
- 与运算
    - `X = N & ((~N) + 1)` 返回的二进制位只保留N最右边一个1
    - `N ^ X` 此时相当于去掉了N最后边的1
- `>>` 无符号右移。表示右移后，高位用0补全
- `>>>` 有符号右移。表示右移后，新的高位用之前的高位补全

### 数据结构

#### 数组

#### 链表

```java
// 单向链表结构
public class Node {
    private int value;
    private Node next;
    public Node(int value) {
        this.value = value;
    }
}

// 双向链表
public class Node {
    private int value;
    private Node last;
    private Node next;
    public Node(int value) {
        this.value = value;
    }
}
```

#### 栈和队列

- 可基于双向链表或数组实现

#### 哈希表和有序表

#### 堆

- 堆：可以认为是完全二叉树（除去叶子节点，其他节点都包含两个子元素，如果最后一层的枝干节点正在填充叶子节点也算）
- 堆分为大根堆和小根堆。大根堆指所有的父节点都大于等于其两个子节点，小根堆则相反
- 堆，基于数组存放：假设当前节点下标为 i, 则左子节点下表为 `2i+1`, 右子节点下标为 `2i+2`, 父节点下标为 `(i-1)/2`
    - 也有将数组的0号元素不用，则假设当前节点下标为 i, 则左子节点下表为 2i, 右子节点下标为 2i+1, 父节点下标为 i/2，那么可通过左移右移完成乘2和除2操作，相对快点
- 系统提供的堆可创建简单的大根堆或小根堆，如`PriorityQueue`，如果修改堆中元素，是不会自动重新排序的；此时只能[自定义堆]
- [题目：需要组织一个大根堆，可持续往里面放一定数量(上限)的元素，每次取出元素时总返回最大的]()
- 堆元素从下往上冒泡，时间复杂度为O(N)；当从上往下沉时，时间复杂度为O(N*logN)

#### 前缀树

- 前缀树特点
    - 单个字符串中，字符从前到后的加到一棵多叉树上
    - 字符放在路上，节点上有专属的数据项（pass经过此节点的数量，end此节点结束数量）
    - 所有样本都这样添加，如果没有路就新建，有则复用
    - 沿途节点的pass值加1，每个字符串结束时来到的节点end值增加1
- 用途：可用于前缀统计
- 图示

    ![前缀树](/data/images/linux/algorithms-前缀树.png)

### 排序算法

> https://www.runoob.com/w3cnote/sort-algorithm-summary.html

- 排序归纳图

    ![排序](/data/images/linux/algorithms-排序.png)
- 排序算法
    - 选择排序
        - 第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换
    - 冒泡排序
        - 比较A-B两个相邻的元素，将值大的元素交换到右边，否则不交换；然后比较B-C两个相邻的元素，同上；第一次循环会排好最后一个数为最大值
    - 插入排序：类似斗地主插入新牌
        - 假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的
    - 归并排序
        - 将数组一分二，递归使之左右两边的数字有序；然后准备left、right两个指针分别指向左右两边数组，比较小的拷贝到新数组，并移动小的指针
    - 快速排序
        - 使用left、right左右指针分别指向数组两端，交替一个指向坑位，一个指向被比较元素，直到两个元素重合，则认为排好第一个元素
            - 将right向左移动，如果指向元素比left缓存元素大，则保持不变；否则填到left处，切换left开始移动动
            - 将left向右移动，如果指向元素比缓存元素小，则不动；否则填到right处，切换right开始移动
            - 以此往复，直到left和right重合，则将缓存元素填充到left处。此时可任务左边的数都比此时left处小，右边都比其大，之后递归遍历左右两边的数组
    - 堆排序
        - 参考上文小根堆
    - 桶(容器)排序：不基于比较进行排序，对数据状态本身有要求
        - 计数排序：如基于年龄对用户排序(年龄一般是0-200岁)，因此对0-200进行计数，然后生成数组
        - 基数排序：对一批数排序(最多3位)，可创建0-9的队列，对数组从左到右，先对个数依次进队列(FIFO)，然后从0-9依次倒回到数组，下一步以十位数进队列出队列，最后以百位数进队列出队列，即排序完成
- 排序的稳定性（处理相等时的态度）：如先对商品的销量排序，再对商品的价格排序，如果排序算法存在稳定性则一定是物美价廉的
- 算法说明
    - 基于比较的排序，时间复杂度极限是O(N*logN)
    - 时间复杂度是O(N*logN)、额外空间复杂度低于O(N)，且必须稳定的排序算法暂时不存在
- 常见坑
    - 归并排序的额外空间复杂度可以变成O(1)，即“归并排序内部缓存法”，但是将变得不再稳定，此时还不如直接使用堆排序
    - 原地归并排序，会让世界复杂度变成O(N^2)
    - 快速排序稳定性改进：“01 stable sort”，但是会对样本数据要求更多，此时还不直接使用桶排序

### 二分法

- 在有序数组中查找一个元素，使用二分法时间复杂度为O(log(2, N))
- 在无序数组中，每个元素均不相等，从中随便找一个区间最小值

### master公式

- 也称主方法，是用来利用分治策略（递归）来解决问题经常使用的时间复杂度的分析方法

![master公式](/data/images/linux/algorithms-master.png)

## 常见算法

### 最不常用算法(LRU)

- `LRU`(Least Recently Used)算法，又称**最不常用算法**，需要实现O(1)复杂度的操作，见LeetCode 146题，见[msb#一#161#00:58:13]
    - 使用哈希表 + 双向链表实现
    - 哈希表保证查找最不常用元素操作O(1)
    - 链表保证排序操作和新增操作O(1)
    - 双向链表保证移动最不常用元素后，左边指针能指向右边元素O(1)。单向链表无法通过右边元素找到左边元素，因此查找左边元素又是基于链表进行遍历查询，此时是O(N)

### 跳跃表(skip-list)

- redis 的 sorted_set数据结构就是基于跳跃表完成排序的

![skip-list](/data/images/linux/algo-skip-list.png)

## 常见面试题

- [Leet Code HOT 100](https://leetcode-cn.com/problemset/hot-100/)

### PathToNum

- 进阶41#00:15:06
- `min { max{ sum左, sum右 } }` => `差{ 好{ S左, S右 } }`，只要S(指标)和范围成单调性时，分割点无需回退

![PathToNum](/data/images/arch/algorithms-PathToNum.png)
- https://github.com/algorithmzuo/trainingcamp005/blob/master/src/class02/Code01_PathsToNums.java

### 动态规划之四边形不等式优化

#### 邮局选址问题

- 令 `dp[i][j]` 为前i个村庄中一共已经设立了j个邮局。那么为：`dp[i][j] = min { {dp[k][j - 1] + w (k + 1, i) } }`，其中k是枚举上一个邮局的右端点在哪个村庄，意思就是前面j - 1的邮局的花费加上从第i + 1个村庄全都到第j个邮局时的花费
- https://github.com/algorithmzuo/trainingcamp005/blob/master/src/class04/Code03_PostOfficeProblem.java     

#### 画家问题

![画家问题](/data/images/arch/algorithms-画家问题.png)

#### 棋子楼层问题

![棋子楼层问题.](/data/images/arch/algorithms-棋子楼层问题.png)



