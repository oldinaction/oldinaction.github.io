---
layout: "post"
title: "算法(algorithms)"
date: "2017-04-24 19:55"
categories: [linux]
tags: [arch]
---

## 预备知识

- 数据结构与算法
    - 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素、删除某个元素、对所有元素进行排序）而执行的相应操作，这个相应的操作叫算法。
	- 数据结构 = 个体 + 个体的关系
	- 算法 = 对存储数据的操作
- 数据结构举例
    - 存储15个人可以用数组(需要连续的存储空间)
	- 存储10000个人可能数组无法存储，可以使用链表(无需联系存储空间，将零散的空间连接起来)
	- 存储人事关系就需要用到树(数组、联表都无法体现上下级关系)
	- 存储交通图就需要用到图(每个地点都有可能连接起来)
- 衡量算法的标准
	- 时间复杂度：程序中最大循环语句循环的次数
	- 空间复杂度：算法执行过程中占用的最大内存
	- 难易程度
	- 健壮性
- 内存
	- 内存是用来存储数据的设备。它的速度介于寄存器（CPU中）和硬盘之间
	- 内存是CPU唯一可以访问的大容量存储设备（CPU还可以访问寄存器，不能操作硬盘。可以把硬盘上的数据读取到内存供CPU使用 ）
	- 内存是多字节组成的线性一维空间
	- 内存的基本划分单位是字节，每个字节含8位（栈图形中的一个横格标识一个字节）
	- 字节和编号是一一对应的。每个字节都有一个唯一确定的编号，一个编号对应一个字节。这个编号也叫地址
	- 一个系统所能管理的内存空间的大小取决于参与编号的二进制位数。如DOS系统20位寻址方案，可控制220B,即1M内存；奔腾系统32位寻址空间，其有效寻址空间为232M，即4GB
	- 软件在运行前需要向操作系统申请存储空间，在内存空闲空间足够时，操作系统将分配一段内存空间。软件在运行期间，该软件所占用内存空间不再分配给其他软件。当软件运行完毕，操作系统回收该内存空间
	- CPU控制内存有3个方面：地址线操作内存的地址分配，控制线操作该内存的读写方式，数据线操作数据填充到内存中
- 指针

    ```c++
    int i = 10;
    int * p = &i; // 整型指针, 其中空格加不加都可以
    int a[5] = {1, 2, 3, 4, 5};
    // 等价于：int *p; p = &i;
    // (1) p存放了i的地址, 所以p指向了i.
    // (2) p和i是两个完全不同的变量，修改其中任何一个变量的值都不会影响另外一个
    // (3) p指向了i, *p就是i变量本身, i和*p在之后的所有地方都可以互换
    // (4) 如果p为指针变量, i为普通变量. 则*p相当于普通变量, &i(取地址i)相当于普通变量的地址
    ```
	- 指针变量（如上述p）也是变量，只不过它存放的不能是内存单元的内容，只能存放内存单元的地址。普通变量（如上述i）前不能加*，常量和表达式前不能加&
	- 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数（0xbfebd5c0）。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同
	- 指针变量所占字节因机器不同所占的字节数也有所不同。在32位的机器上，一个指针变量占4个字节，在64位的机器上，一个指针变量占8个字节。（64位电脑测试确仍然占用4个字节，与编译器为了兼容有关）
	- 一维数组
		- 一维数组名是个指针常量，他存放一维数组第一个元素的地址，他的值不能被改变。`a[i]` 等价于 `*(a+i)`
		- 如果p为指针变量，p++等价于p+1。相当于p的下一个地址（double * p; 此时p存放某个double变量的地址0x000000, p+1则是基于此地址加8个字节，即0x000008）

## 基础知识

- 评定算法优劣
    - 时间复杂度(流程决定)
    - 额外空间复杂度(流程决定。与功能无关，流程执行过程中必须申请的空间)
    - 常数项时间(实现细节决定)
- 最差情况的复杂度使用O记录(读做big o)
- 常数时间操作：行时间固定的，和样本无关的即为常数时间操作
    - 加减乘除运算
    - `>>`、`>>>`、`^`等
    - 数组寻址操作(基于数组下标取值)
- 对数器：生成随机样例，测试算法的程序

## 二进制运算

- 异或运算
    - 无进位则相加
    - 同样一批数，不考虑顺序，异或结果一样
    - `0^N == N`，`N^N == 0`
    - 案例
        - 一个数组中有一个数出现了奇数次，其他数出现了偶数次，怎么找到并打印这个数
            - `int eor = 0; for { eor = eor ^ arr[i] }; print eor`
        - 一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到这两种数并打印
        - 计算一个二进制数出现1的次数
- 与运算
    - `X = N & ((~N) + 1)` 返回的二进制位只保留N最右边一个1
    - `N ^ X` 此时相当于去掉了N最后边的1
- `>>` 无符号右移。表示右移后，高位用0补全
- `>>>` 有符号右移。表示右移后，新的高位用之前的高位补全

### 排序

> https://www.runoob.com/w3cnote/sort-algorithm-summary.html

- 选择排序：O(n2)
    - 第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换
- 冒泡排序：O(n2)
    - 比较两个相邻的元素，将值大的元素交换到右边
- 插入排序：O(n2)，类似斗地主插入新牌
    - 假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的

### 二分法

- 在有序数组中查找一个元素，使用二分法时间复杂度为O(log2N)
- 在无序数组中，每个元素均不相等，从中随便找一个区间最小值

## 常见算法

### 最不常用算法(LRU)

- `LRU`(Least Recently Used)算法，又称**最不常用算法**，需要实现O(1)复杂度的操作，见LeetCode 146题，见[msb#一#161#00:58:13]
    - 使用哈希表 + 双向链表实现
    - 哈希表保证查找最不常用元素操作O(1)
    - 链表保证排序操作和新增操作O(1)
    - 双向链表保证移动最不常用元素后，左边指针能指向右边元素O(1)。单向链表无法通过右边元素找到左边元素，因此查找左边元素又是基于链表进行遍历查询，此时是O(N)

### 跳跃表(skip-list)

![skip-list](/data/images/linux/algo-skip-list.png)

## 常见面试题

- [Leet Code HOT 100](https://leetcode-cn.com/problemset/hot-100/)

### PathToNum

- 进阶41#00:15:06
- `min { max{ sum左, sum右 } }` => `差{ 好{ S左, S右 } }`，只要S(指标)和范围成单调性时，分割点无需回退

![PathToNum](/data/images/arch/algorithms-PathToNum.png)
- https://github.com/algorithmzuo/trainingcamp005/blob/master/src/class02/Code01_PathsToNums.java

### 动态规划之四边形不等式优化

#### 邮局选址问题

- 令 `dp[i][j]` 为前i个村庄中一共已经设立了j个邮局。那么为：`dp[i][j] = min { {dp[k][j - 1] + w (k + 1, i) } }`，其中k是枚举上一个邮局的右端点在哪个村庄，意思就是前面j - 1的邮局的花费加上从第i + 1个村庄全都到第j个邮局时的花费
- https://github.com/algorithmzuo/trainingcamp005/blob/master/src/class04/Code03_PostOfficeProblem.java     

#### 画家问题

![画家问题](/data/images/arch/algorithms-画家问题.png)

#### 棋子楼层问题

![棋子楼层问题.](/data/images/arch/algorithms-棋子楼层问题..png)



