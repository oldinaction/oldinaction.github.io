---
layout: "post"
title: "低代码/无代码开发"
date: "2023-08-15 21:12"
categories: [arch]
tags: [js,lowcode]
---

## 阿里lowcode-engine低代码引擎

### 简介

- [官网](https://lowcode-engine.cn/)
- [github](https://github.com/alibaba/lowcode-engine)
- [可视化演示](https://lowcode-engine.cn/demo/demo-general/index.html)
- 低代码引擎是一款为低代码平台开发者提供的，具备强大定制扩展能力的低代码设计器研发框架。阿里开源，基于React
- 说明
    - 适用于WEB、H5页面生成
    - 组件任意位置拖拽，拖拽体验好
    - 前端基于物料模式的拖拽布局
    - 支持出码
- DSL介绍：https://zhuanlan.zhihu.com/p/107947462

#### 名词

- [名词解释](https://lowcode-engine.cn/site/docs/guide/appendix/glossary)
- 插件: 如编辑器左侧/顶部/侧边工具栏对应功能可通过插件实现
    - 官方插件或自定义插件
    - 自定义插件支持在项目直接创建插件文件，或者在新的仓库中开发插件
- 物料
    - [官方物料库](https://github.com/alibaba/lowcode-materials)：包含基于fusion和antd前端框架对应物料库
- 渲染
    - 资产包数据 assets + 页面数据 schema 通过lowcode-engine直接渲染展示
- 出码: 低代码编排出的 schema 进行解析，结合前端模板，转换成最终可执行的代码
    - [使用出码功能](https://lowcode-engine.cn/site/docs/guide/expand/runtime/codeGeneration)
    - [出码模块设计](https://lowcode-engine.cn/site/docs/guide/design/generator)
    - lowcode-engine支持基于 Schema 的运行时渲染，也支持出码将Schema生成源代码(之后源码无法再通过低代码编辑器维护)
    - 适用场景: 想要极致的打开速度; 老项目 + 新需求; 协议不能描述部分代码逻辑
- 其他说明
  - 编辑器: 初始化低代码编辑器基座项目(lowcode-demo/demo-general已经安装了编辑器，内置了一些插件和物料)
  - 插件: 指为低代码编辑器增加插件，如顶部区域Logo为一个插件，可以在顶部区域或侧边栏增加插件模块
      - 在插件项目的 build.json 下面新增 "inject": true，则默认通过官方demo进行调试，设置成false则是本地调试
  - 物料: 指可以拖拽的组件元素

    ```bash
    # 报错: ERESOLVE unable to resolve dependency tree
    npm install --legacy-peer-deps
    ```

### 快速入门

- [lowcode-demo官方案例](https://github.com/alibaba/lowcode-demo)
- 参考：https://lowcode-engine.cn/site/docs/guide/quickStart/start
- 启动`demo-general`目录项目(其他目录为不同物料对应项目demo，如antd/fusion)
- demo-general目录
    - 设计器入口文件 src/index.ts 这个文件做了下述几个事情
        - 通过 plugins.register 注册各种插件，包括官方插件 (已发布 npm 包形式的插件) 和 plugins 目录下内置的示例插件
        - 通过 init 初始化低代码设计器
    - plugins 目录，存放的都是示例插件，如左侧/顶部/侧边工具栏对应功能可通过插件实现
    - services 目录，模拟数据请求、提供默认 schema、默认资产包等，此目录下内容在真实项目中应替换成真实的与服务端交互的服务。
    - preview.tsx 预览页面入口文件
- demo-general/plugins/plugin-demo 为测试时创建的插件案例(插件为文件级别)
- lowcode-plugin-demo2 为测试时创建的插件案例(插件为项目级别)
    - `yarn start`启动
    - 在此项目的 build.json 下面新增 "inject": true，就可以在 https://lowcode-engine.cn/demo/demo-general/index.html?debug 页面下进行调试了
- lowcode-material-demo 为测试时创建的自定义物料项目
    - `yarn lowcode:dev` 启动

### 源码解析

- 参考文章：https://zhuanlan.zhihu.com/p/587281277
- 参考源码解析备注：https://github.com/reading-code-zh/lowcode-engine

#### 本地调试lowcode-engine

- 谷歌浏览器安装ModHeader网页资源代理插件
- git下载lowcode-engine，并按要求启动
- 启动后控制台会出现几个Asset资源文件名(此时资源文件还未打包，本地不会创建打包文件，但可通过http进行访问)
- 启动官方`lowcode-demo/demo-general`案例模块，查看engine-core和react-simulator-renderer模拟器的资源地址
- 配置ModHeader文件代理规则，重新访问lowcode-demo即可

```bash
# Redirect URLs
https://uipaas-assets.com/prod/npm/@alilc/lowcode-engine/1.1.8-beta.2/dist/js/engine-core.js   http://localhost:5555/js/AliLowCodeEngine.js
https://uipaas-assets.com/prod/npm/@alilc/lowcode-engine/1.1.8-beta.2/dist/js/react-simulator-renderer.js   http://localhost:5555/js/ReactSimulatorRenderer.js
https://uipaas-assets.com/prod/npm/@alilc/lowcode-engine/1.1.8-beta.2/dist/css/engine-core.css   http://localhost:5555/css/AliLowCodeEngine.css
https://uipaas-assets.com/prod/npm/@alilc/lowcode-engine/1.1.8-beta.2/dist/css/react-simulator-renderer.css   http://localhost:5555/css/ReactSimulatorRenderer.css
```

#### lowcode-engine启动逻辑

- lowcode-demo案例启动(通过引入lowcode-engine进行测试的入口)
    
```js
// lowcode-demo/demo-general/src/index.ts
// 导入lowcode-engine init方法
import { init, plugins } from '@alilc/lowcode-engine';

(async function main() {
  await registerPlugins();
  
  // 挂载lce-container
  init(document.getElementById('lce-container')!, {
    locale: 'zh-CN',
    enableCondition: true,
    enableCanvasLock: true,
    // 默认绑定变量
    supportVariableGlobally: true,
    requestHandlersMap: {
      fetch: createFetchHandler(),
    },
    appHelper,
  });
})();
```
- lowcode-engine启动参考上文(只是暴露出一个UMD文件)
    - `npm start`
    - 启动了`packages/ignitor`(点火器) - build.json的entry入口参数 - AliLowCodeEngine(packages/engine)和ReactSimulatorRenderer(packages/simulator), RaxSimulatorRenderer可不用考虑(为阿里开源的类似React框架)

- `lowcode-engine/packages/engine/engine-core.ts`

```js
import { createElement } from 'react';
import { render } from 'react-dom';
import { Skeleton as InnerSkeleton } from '@alilc/lowcode-editor-skeleton';

// @alilc/lowcode-editor-core
// 保存eventBus等属性
const editor = new Editor();

// 设计器，包含了project对象(open的时候会createDocument创建doc对象用于传递到模拟器中)
const designer = new Designer({ editor, shellModelFactory });

// @alilc/lowcode-editor-skeleton
// leftArea topArea subTopArea toolbar leftFixedArea leftFloatArea rightArea mainArea bottomArea stages
const innerSkeleton = new InnerSkeleton(editor);
const common = new Common(editor, innerSkeleton);

export async function init(
  container?: HTMLElement,
  options?: IPublicTypeEngineOptions,
  pluginPreference?: PluginPreference,
  ) {
  await destroy();
  // ...
  engineConfig.setEngineOptions(engineOptions as any);

  const { Workbench } = common.skeletonCabin;
  // ...

  await plugins.init(pluginPreference as any);

  render(
    createElement(Workbench, {
      skeleton: innerSkeleton, // 编辑器(骨架)组件
      className: 'engine-main',
      topAreaItemClassName: 'engine-actionitem',
    }),
    engineContainer, // engineContainer => container => document.getElementById('lce-container')
  );
}
```
- `lowcode-engine/packages/editor-skeleton/src/layouts/workbench.tsx` 工作台渲染

```js
// lowcode-engine/packages/workspace/src/layouts/workbench.tsx 有一个类似的，暂未研究何时生效
render() {
    const {
        skeleton,
        className,
        topAreaItemClassName,
    } = this.props;
    return (
        <div className={classNames('lc-workbench', className)}>
        <SkeletonContext.Provider value={this.props.skeleton}>
            <TopArea area={skeleton.topArea} itemClassName={topAreaItemClassName} />
            <div className="lc-workbench-body">
            <LeftArea area={skeleton.leftArea} />
            <LeftFloatPane area={skeleton.leftFloatArea} />
            <LeftFixedPane area={skeleton.leftFixedArea} />
            <div className="lc-workbench-center">
                <Toolbar area={skeleton.toolbar} />
                <MainArea area={skeleton.mainArea} />
                <BottomArea area={skeleton.bottomArea} />
            </div>
            <RightArea area={skeleton.rightArea} />
            </div>
            <TipContainer />
        </SkeletonContext.Provider>
        </div>
    );
}
```

#### 编辑器实时画布iframe渲染说明

```bash
# 编辑器实时画布iframe渲染说明
packages/engine/src/engine-core.ts => `import { defaultPanelRegistry } from './inner-plugins/default-panel-registry';`
	packages/engine/src/inner-plugins/default-panel-registry.tsx => `import DesignerPlugin from '@alilc/lowcode-plugin-designer';`
		packages/plugin-designer/src/index.tsx <= @alilc/lowcode-plugin-designer
			import { DesignerView, Designer } from '@alilc/lowcode-designer'; => `packages/designer/src/designer/designer-view.tsx`
				import { ProjectView } from '../project'; <= `packages/designer/src/project/project-view.tsx`
					import { BuiltinSimulatorHostView } from '../builtin-simulator';
						export * from './host-view'; => `render iframe`
							import { BuiltinSimulatorHost, BuiltinSimulatorProps } from './host'; => `await createSimulator(this, iframe, vendors);`
								packages/designer/src/builtin-simulator/create-simulator.ts
```

#### 元素选中后显示工具栏

- `lowcode-engine/packages/designer`

```js
// ==> src/builtin-simulator/host-view.tsx
// BuiltinSimulatorHostView
return (
    <div className="lc-simulator">
        {/* progressing.visible ? <PreLoaderView /> : null */}
        <Canvas host={this.host} />
    </div>
);
// Canvas
return (
    <div className={className} style={canvas}>
        <div ref={(elmt) => sim.mountViewport(elmt)} className="lc-simulator-canvas-viewport" style={viewport}>
            <BemTools host={sim} />
            <Content host={sim} />
        </div>
    </div>
);
// Content
return (
    <div className="lc-simulator-content">
        <iframe
            name={`${viewName}-SimulatorRenderer`}
            className="lc-simulator-content-frame"
            style={frameStyle}
            // react支持一个ref属性，该属性可以添加到任何的组件上。该ref属性可接收一个回调函数，这个回调函数在组件挂载或者卸载的时候被调用，传入参数是DOM本身
            // iframe挂载成功后触发mountContentFrame方法，初始化时间监听
            ref={(frame) => sim.mountContentFrame(frame)}
        />
    </div>
);

// ==> src/builtin-simulator/host.tsx
// iframe挂载成功后触发mountContentFrame方法，从而初始化此事件监听
setupDragAndClick() {
    const { designer } = this;
    const doc = this.contentDocument!;

    // TODO: think of lock when edit a node
    // 事件路由
    doc.addEventListener(
      'mousedown',
      (downEvent: MouseEvent) => {
        // fix for popups close logic
        document.dispatchEvent(new Event('mousedown'));
        const documentModel = this.project.currentDocument;
        if (this.liveEditing.editing || !documentModel) {
          return;
        }
        const { selection } = documentModel;
        // ...
        const nodeInst = this.getNodeInstanceFromElement(downEvent.target);
        const { focusNode } = documentModel;
        const node = getClosestClickableNode(nodeInst?.node || focusNode, downEvent);
        // ...

        const checkSelect = (e: MouseEvent) => {
          doc.removeEventListener('mouseup', checkSelect, true);
          
          // ...
          // designer.project.currentDocument.selection(designer作为参数提前传入)
          // 此时监听到鼠标按下，然后抬起，将对应元素放到selection中
          selection.select(node.contains(focusNode) ? focusNode.id : id);
          // ...
        };

        // ...
        doc.addEventListener('mouseup', checkSelect, true);
      },
      true,
    );

    doc.addEventListener('click', ...);
}

// ==> src/builtin-simulator/bem-tools/index.tsx
@observer // mobx-react库(mobx状态管理器，类似vuex)
export class BemTools extends Component<{ host: BuiltinSimulatorHost }> {
  render() {
    const { host } = this.props;
    const { designMode } = host;
    // 获取模拟器iframe视图窗口滚动条
    const { scrollX, scrollY, scale } = host.viewport;
    if (designMode === 'live') {
      return null;
    }
    return (
      // 通过translate让工具栏悬浮在元素上
      <div className="lc-bem-tools" style={{ transform: `translate(${-scrollX * scale}px,${-scrollY * scale}px)` }}>
        { !engineConfig.get('disableDetecting') && <BorderDetecting key="hovering" host={host} /> }
        <BorderSelecting key="selecting" host={host} />
        { engineConfig.get('enableReactiveContainer') && <BorderContainer key="reactive-container-border" host={host} /> }
        <InsertionView key="insertion" host={host} />
        <BorderResizing key="resizing" host={host} />
        {
          host.designer.bemToolsManager.getAllBemTools().map(tools => {
            const ToolsCls = tools.item;
            return <ToolsCls key={tools.name} host={host} />;
          })
        }
      </div>
    );
  }
}

// ==> src/builtin-simulator/bem-tools/border-selecting.tsx
import NodeSelector from '../node-selector';

@observer
export class BorderSelectingInstance extends Component<{
  observed: OffsetObserver;
  highlight?: boolean;
  dragging?: boolean;
}> {
  componentWillUnmount() {
    this.props.observed.purge();
  }

  render() {
    // 属性值来源参考下文 BorderSelecting
    const { observed, highlight, dragging } = this.props;
    if (!observed.hasOffset) {
      return null;
    }

    const { offsetWidth, offsetHeight, offsetTop, offsetLeft } = observed;

    // 计算选中元素时，展示外框所在位置
    const style = {
      width: offsetWidth,
      height: offsetHeight,
      transform: `translate3d(${offsetLeft}px, ${offsetTop}px, 0)`,
    };

    const className = classNames('lc-borders lc-borders-selecting', {
      highlight,
      dragging,
    });

    const { hideSelectTools } = observed.node.componentMeta.advanced;

    if (hideSelectTools) {
      return null;
    }

    return (
      // 渲染工具栏
      <div className={className} style={style}>
        {!dragging && <Toolbar observed={observed} />}
      </div>
    );
  }
}

@observer
class Toolbar extends Component<{ observed: OffsetObserver }> {
  render() {
    const { observed } = this.props;
    const { height, width } = observed.viewport;
    // ...
    let style: any;
    // 计算 toolbar 的上/下位置。相对于选中元素时展示的外框
    if (observed.top > SPACE_HEIGHT) {
      style = {
        top: -SPACE_HEIGHT,
        height: BAR_HEIGHT,
      };
    }
    // ...

    return (
      <div className="lc-borders-actions" style={style}>
        {actions}
        <NodeSelector node={node} />
      </div>
    );
  }
}

@observer
export class BorderSelecting extends Component<{ host: BuiltinSimulatorHost }> {
  get host(): BuiltinSimulatorHost {
    return this.props.host;
  }
  
  // 从this.host.designer中取值
  get dragging(): boolean {
    return this.host.designer.dragon.dragging;
  }
  
  // 获取选中的节点，可以为多个
  @computed get selecting() {
    // 为DocumentModel对象，非document实例
    // 为 this.host.designer.projectSimulatorProps 中的属性
    const doc = this.host.currentDocument;
    if (!doc || doc.suspensed || this.host.liveEditing.editing) {
      return null;
    }
    const { selection } = doc;
    return this.dragging ? selection.getTopNodes() : selection.getNodes();
  }

  render() {
    const { selecting } = this;

    // 根据是否有选中决定是否渲染
    if (!selecting || selecting.length < 1) {
      return null;
    }

    return (
      <Fragment>
        {selecting.map((node) => (
          <BorderSelectingForNode key={node.id} host={this.props.host} node={node} />
        ))}
      </Fragment>
    );
  }
}

// node-selector.tsx
// 工具栏按钮选中后触发全局事件
onSelect = (node: INode) => (event: MouseEvent) => {
    if (!node) {
      return;
    }

    const canClick = canClickNode(node.internalToShellNode()!, event);

    if (canClick && typeof node.select === 'function') {
      node.select();
      const editor = node.document?.designer.editor;
      const npm = node?.componentMeta?.npm;
      const selected =
        [npm?.package, npm?.componentName].filter((item) => !!item).join('-') ||
        node?.componentMeta?.componentName ||
        '';
      editor?.eventBus.emit('designer.border.action', {
        name: 'select',
        selected,
      });
    }
};
```

## VTJ

- [VTJ官网](https://vtj.pro/)、[VTJ开源](https://gitee.com/newgateway/vtj)
    - 基于Vue3的MIT开源前端低代码开发工具。内置低代码引擎、渲染器和代码生成器，支持Vue源码与低代码DSL双向转换，支持AI。要求**Node v20**以上
    - 支持快速创建新的VTJ应用和项目集成(集成到已存的项目应用中)两种方式
        - 集成现有项目要求: 现有项目是基于 **Vite + TypeScript 的 Vue3 项目**
        - 集成之后先创建的可视化页面可直接变化，原来基于源码的页面无法直接可视化编辑(可将源码转成DSL再可视化编辑)
    - 官方提供集成 vue-element-plus-admin 的快速开发脚手架
- 启动
  - `npm run setup && npm run build && npm run app:dev` 启动本地(离线)设计器进行项目低代码配置 (其中`npm run build`会将项目中的公开包进行打包编译，此模式启动后修改这些包不会实时显示到编译器中)
  - `npm run setup && npm run build && npm run dev` 启动本地开发环境, 访问开发环境地址, 如选择包`@vtj/designer`, 点击`/designer/simple`路径可现实设计器(此时修改设计器代码会实时显示到浏览器, 但是修改依赖如`@vtj/local`仍然需要build local模块)
- 文档说明
  - **包结构参考**: https://vtj.pro/wiki/package/
    
    ```bash
    packages
        @vtj/base # 基础类型和实用程序. 依赖: dayjs, lodash-es 等
        @vtj/utils # 依赖: @vtj/base, axios, js-cookie 等
        @vtj/core # 核心数据模型和引擎抽象. 依赖: @vtj/base 等

        @vtj/renderer # 低代码 DSL 的运行时渲染器(**运行时核心**). 依赖: @vtj/core 等
            src/provider/provider.ts # Provider 是应用的核心提供者，负责管理整个应用的配置、状态、依赖加载和资源管理。它提供统一的接口来访问项目配置、API服务、路由系统以及动态组件渲染能力
        @vtj/designer # 可视化设计环境
            src/framework/engine.ts # Engine 是 VTJ 设计器的核心引擎类，负责管理整个设计器的生命周期和状态。它整合了项目管理、文件操作、历史记录、渲染等核心功能，是设计器架构的中枢系统
        @vtj/parser # 将 Vue 代码解析为 DSL 模型
        @vtj/coder # 从 DSL 模型生成 Vue 代码

        @vtj/local # 本地开发服务
        @vtj/cli # 构建和开发工具
        @vtj/node # Node.js实用程序

        @vtj/ui # 自带UI. 依赖: vxe-table, element-plus, sortablejs 等
        @vtj/uni # UniApp 支持包
        @vtj/charts # 依赖: echarts 等
        @vtj/icons
        @vtj/materials
    platforms
        @vtj/web # 实际需要引入到主应用的dependencies中(**web运行时需要**). 依赖: @vtj/core, @vtj/renderer, @vtj/utils, @vtj/ui, @vtj/icons, @vtj/charts
        @vtj/h5
        @vtj/uni-app # UniApp 平台实现. 依赖: @vtj/core, @vtj/renderer, @vtj/uni 等
        @vtj/pro # 设计器入口(开发环境核心). 依赖: @vtj/web 或 @vtj/uni-app; @vtj/designer, @vtj/local, @vtj/materials 等
    dev # 开发 VTJ 框架
    create-vtj # 快速创建vtj项目
    apps # 示例项目
        app # 示例项目
        uniapp # uniapp示例项目
    ```
  - 自定义设计器Logo: 参考功能扩展：https://vtj.pro/guide/extension.html
  - 自建低代码平台: 自定义AI、模板、认证参考设计器接入指南：https://vtj.pro/guide/base/access.html
  - 出码: 无需像在线环境一样出码(实际是下载一个模板项目 + `.vtj/**`文件夹, 去掉histories), 而本地启动的设计器通过发布即可得到`.vtj`文件夹
  - AI(参考dev@views/ai): 实际是先通过AI生成一份如基于element-plus的Vue单页面文件, 然后通过@vtj/parser解析Vue文件生成DSL

### 设计面板中保存源码功能代码分析
  
- 开发环境读取.vtj目录文件实现，通过 `/__vtj__/api/` 路由实现此路由的特殊处理，参考下文第3个问题：https://deepwiki.com/search/vtj_4279b221-6415-44b6-bc4c-c5a77b0af7f7

```bash
- apps/app -> vite.config.ts -> @vtj/pro -> @vtj/local
  - @vtj/pro —> vite.config.ts -> createDevTools
  - 注入API: @vtj/local -> plugin.ts -> apiServerPlugin -> setApis注入API钩子(DevToolsOptions.baseURL=`__vtj__/api`) -> router -> controller.ts -> local下service.ts -> JsonRepository -> writeJsonSync写文件
  - 注入静态资源: @vtj/local -> plugin.ts -> staticOptions.push({path: `/__vtj__/`, dir: `@vtj/pro/dist`})
  - 注入设计按钮: @vtj/local -> plugin.ts -> linkPlugin -> `__vtj__/entry/index.js` -> @vtj/pro下link.js -> id=vtjLink设计按钮
- id=vtjLink设计按钮 -> link.js -> 打开新窗口添加路径`/__vtj__/#/`
  - `/__vtj__/`(路由前缀) -> 根据上文静态文件映射到@vtj/pro/dist/index.html -> index.html -> /ide/main.ts
    -> views/index.vue -> new Engine(service=new LocalService()) -> Engine.constructor() -> this.provider = new Provider({ mode: ContextMode.Design }) 设计器模式, 创建设计器模式下的Provider
    --> views/preview.vue -> createProvider({ mode: ContextMode.Runtime }) 运行时模式(预览)
    --> views/page.vue 暂不清楚用处
- apps/app -> @vtj/pro -> @vtj/designer
    - @vtj/designer -> panel.vue保存 -> widgets/raw -> onSave -> (engine.)current.value?.update
      - DSL转Vue代码 -> current watch -> engine.service.genVueContent
      - 实时更新files/json文件 -> BlockModel.update -> emit(EVENT_BLOCK_CHANGE)
    - engine.ts -> on(EVENT_BLOCK_CHANGE) -> changeFile -> service.saveFile -> POST `/__vtj__/api/saveFile.json`(LocalService) --> @vtj/local下apiServerPlugin注入的API
```

### 设计器

- `/__vtj__`(路由前缀) -> 根据上文静态文件映射到@vtj/pro/dist/index.html -> index.html -> /ide/main.ts
- `/__vtj__/`(首页) -> `ide/views/index.vue`

```html
<template>
    <div class="designer" ref="container"></div>
</template>

<script lang="ts" setup>
    // ...
    const container = ref();
    const config: VTJConfig =
        (await service.getExtension().catch(() => null)) || {};
    const options = config ? await new Extension(config).load() : {};
    
    // 实例化 Engine
    const engine = new Engine({
        container, // div容器
        service,
        // ...
    });
    
    engine.ready(() => {
        // 基于页面id打开页面配置文件. 还会watch此id
        engine.openFile(route.query.id as string);
    });
</script>
```
- @vtj/designer/framework/engine.ts

```js
export class Engine extends Base {
    constructor(public options: EngineOptions) {
        // 初始化 Provider
        this.provider = new Provider({
            mode: ContextMode.Design,
            // ...
        }
        
        // 初始化模拟器(用于渲染设计器正中央的页面,基于写入iframe文档内容)
        this.simulator = new Simulator({
            engine: this,
            materialPath,
            enhance: this.getEnhanceConfig(enhance)
        });
        
        // 渲染 SkeletonWrapper(vue组件) 到div
        this.init(project as ProjectSchema).then(this.render.bind(this));
    }

    private async init(project: ProjectSchema) {
        // 读取dsl文件
        const dsl = await this.service.init(project).catch((e) => {
            logger.warn('VTJEngine service init fail.', e);
            return null;
        });
        if (dsl) {
            // ...
            // 封装成 ProjectModel
            this.project.value = new ProjectModel(dsl);
            // ...
            this.triggerReady();
        }
    }

    private render() {
        const container = unref(this.container);
        if (container) {
            const app = createApp(SkeletonWrapper);
            if (this.options.install) {
                app.use(this.options.install, this);
            }
            app.provide(engineKey, shallowReactive(this));
            app.mount(container);
            this.app = app;
        } else {
            logger.warn('VTJEngine constructor param [ container ] is undefined');
        }
    }
}
```
- SkeletonWrapper: @vtj/designer/wrappers/skeleton.vue 页面骨架
  - components/skeleton.vue
    - 页面顶部(v-skeleton__header): regions/action.vue <- `<RegionWrapper ref="actions" region="Actions"></RegionWrapper>`
    - 页面中间(v-skeleton__wrapper)
      - 左侧(v-skeleton__left): regions/apps.vue
        - 循环显示panelWidgets
      - 中间(v-skeleton__main): regions/workspace.vue 或 regions/preview.vue
      - 右侧(v-skeleton__right): regions/settings.vue
    - 页面底部(v-skeleton__footer): regions/status.vue
- apps.vue 中 panelWidgets 显示

```js
// regions/apps.vue
const { widgets, widgetsRef } = useRegion(props.region);

// useRegion
const widgets = computed(() => {
    // widgetManager.getWidgets('Apps')
    return widgetManager
        .getWidgets(unref(region), unref(group))
        .filter((n) => !n.invisible);
});

// managers/widget.ts
class WidgetManager {
    constructor() {
        // 初始化所有 widgets
        this.widgets = this.createWidgets();
    }

    private createWidgets() {
        const widgets: Record<string, Widget> = {};
        // builtInWidgets: managers/built-in/widgets.ts
        /*
            [{
                name: 'Pages',
                region: 'Apps',
                component: widgets.Pages, // components/widgets/pages/index.vue
                type: 'app',
                openType: 'panel',
                icon: VtjIconDocument,
                label: '页面管理'
            }]
        */
        for (const item of builtInWidgets) {
            widgets[item.name] = item;
        }
        return widgets;
    }
}
export const widgetManager = new WidgetManager();
```
- components/widgets/pages/index.vue 点击页面树型的某一项(设计器中切换页面)

```js
const pages = computed(() => project.value?.pages || []);

const onClick = async (file: PageFile) => {
    if (file.raw) {
        message('这是源码模式页面，不能在设计器中打开', 'warning');
    }
    if (file.dir || file.raw) {
        engine.project.value?.deactivate();
    } else {
        // => project.value.currentFile = file;
        engine.project.value?.active(file);
        // components/regions/workspace.vue
        const region = engine.skeleton?.getRegion('Workspace');
        if (region) {
            // workspace中打开(激活)设计视图TAB: components/widgets/designer/index.vue
            region.regionRef.openTab('Designer');
        }
    }
};
```
- openTab('Designer') workspace中打开(激活)设计视图TAB

```js
// components/widgets/designer/index.vue
const iframe = ref<HTMLIFrameElement>(); // iframe标签容器: <iframe ref="iframe" frameborder="0"></iframe>

const { designer, hover, dropping, selected, lines } = useDesigner(
    iframe,
    dependencies,
    apis,
    meta,
    config,
    uniConfig
);

// components/hooks/useDesigner.ts
export function useDesigner(...) {
    const engine = useEngine();
    
    // 初始化设计器引擎模拟器
    engine.simulator.init(iframe, dependencies, apis, meta, config, uniConfig);
    // ...
}

// framework/simulator.ts
init(
    iframe: Ref<HTMLIFrameElement | undefined>,
    deps: Ref<Dependencie[]>,
    apis: Ref<ApiSchema[]>,
    meta: Ref<MetaSchema[]>,
    config: Ref<ProjectConfig>,
    uniConfig: Ref<UniConfig>
) {
    watch(
        [iframe, deps, apis, meta, config, uniConfig],
        () => {
            if (iframe.value && deps.value.length) {
                this.resetReady();
                this.renderer?.dispose();
                this.renderer = null;
                // doc.write(`<!DOCTYPE html>...`) 往iframe中写入文档
                this.setup(iframe.value, deps.value);
                if (this.contentWindow) {
                    this.designer.value?.dispose();
                    // 初始化设计器 framework/designer.ts
                    this.designer.value = new Designer(
                        this.engine,
                        this.contentWindow,
                        deps,
                        this.devtools
                    );
                }
            }
        },
        { immediate: true, deep: true }
    );
}

private setup(iframe: HTMLIFrameElement, deps: Dependencie[]) {
    const cw = iframe.contentWindow;
    cw.__simulator__ = this;
    const doc = cw.document;
    doc.write(`
     <!DOCTYPE html>
     <html lang="zh-CN">
       ......
       <script>
       // 触发事件
       __simulator__.emitReady(${JSON.stringify(libraryExports)},
            ${JSON.stringify(materialExports)}, 
            ${JSON.stringify(materialMapLibrary)},
            ${JSON.stringify(libraryLocaleMap)}
        );
     </script> 
     </html>
    `);
}

async emitReady(
    libraryExports: string[] = [],
    materialExports: string[] = [],
    materialMapLibrary: Record<string, string> = {},
    libraryLocaleMap: Record<string, string> = {}
) {
    this.renderer?.dispose();
    const { assets, service, current, provider, project, report } = this.engine;
    // ...
    // 初始化渲染器 framework/renderer.ts
    this.renderer = new Renderer(
        env,
        service,
        provider,
        report,
        project.value,
        this.designer.value
    );
    if (current.value) {
        // 渲染区块(参考下文). public current: Ref<BlockModel | null> = ref(null); // 当前编辑的区块模型
        this.renderer.render(current.value, project.value?.currentFile);
        this.rendered.value = Symbol();
    }
    this.triggerReady();
}

// framework/renderer.ts 渲染区块
render(block: BlockModel, file?: PageFile | BlockFile | null) {
    // ...
    this.dsl = Vue.reactive(block.toDsl()) as BlockSchema;
    // renderer: 基于DSL创建的Vue组件. createDslRenderer 具体见下文
    const { renderer, context } = this.provider.createDslRenderer(this.dsl, ...);
    const { platform = 'web' } = this.project || {};

    this.app =
        platform === 'uniapp'
            ? this.createUniApp(platform, file, renderer)
            // 创建 Vue app
            : this.createApp(platform, file, renderer);
    
    emitter.on(EVENT_NODE_CHANGE, this.nodeChange as any);
    emitter.on(EVENT_BLOCK_CHANGE, this.blockChange as any);
    return this.app;
}

createApp(platform: PlatformType, file: PageFile | BlockFile, renderer: any) {
    // 手动写入app div
    const el = window.document.createElement('div');
    el.id = 'app';
    container.appendChild(el);

    const AppContainer = Vue.defineComponent({
        render() {
            return Vue.h(Vue.Suspense, [Vue.h(renderer)]);
        }
    });

    // 创建Vue app
    const app = Vue.createApp(AppContainer) as App;
    // app.use(this.provider); 安装 provider/enhance/plugin 等
    this.install(app, platform);
    Object.assign(
        app.config.globalProperties.$route.meta,
        (file as PageFile).meta || {}
    );
    // 挂载到dom
    app.mount(el);
    return app;
}
```
- createDslRenderer

```js
// render/block.ts 基于DSL渲染区块(单个页面/从模板中导入的区块)
export function createRenderer(options: CreateRendererOptions) {
    // ...

    const context = new Context({
        mode,
        dsl: dsl.value,
        attrs
    });
    
    // Vue.defineComponent: 基于DSL定义Vue组件
    const renderer: DefineComponent<any, any, any, any> = Vue.defineComponent({
        name: dsl.value.name, // 页面(组件)名称
        __scopeId: dsl.value.id ? `data-v-${dsl.value.id}` : undefined,
        props: {
            ...createProps(dsl.value.props ?? [], context)
        },
        setup(props: any) {
            context.$props = props;
            context.props = props;
            // ...
        },
        emits: createEmits(dsl.value.emits),
        expose: ['vtj'],
        render() {
            if (!dsl.value.nodes) return null;
            // 渲染页面节点
            const nodes: NodeSchema[] = dsl.value.nodes || [];
            if (nodes.length === 1) {
                return nodeRender(nodes[0], context, Vue, loader, nodes);
            } else {
                return nodes.map((child) =>
                    nodeRender(child, context, Vue, loader, nodes)
                );
            }
        },
        ...createLifeCycles(dsl.value.lifeCycles ?? {}, context)
    });

    return {
        renderer: Vue.markRaw(renderer), // markRaw: 用于标记一个对象或组件，使其不被 Vue 的响应式系统处理
        context
    };
}

// render/node.ts
export function nodeRender(
    dsl: NodeSchema,
    context: Context,
    Vue: any = globalVue,
    loader: BlockLoader = defaultLoader,
    brothers: NodeSchema[] = [],
    isBranch: boolean = false
): VNode | VNode[] | null {
    if (!dsl || !dsl.name || dsl.invisible) return null;

    const appContext = Vue.getCurrentInstance()?.appContext;

    const { id = null, directives = [] } = dsl;

    const { vIf, vElseIf, vElse, vFor, vShow, vModels, vBind, vHtml, others } =
        getDiretives(directives);
    
    // v-if
    if (vIf && !vIfRender(vIf, context)) {
        return branchRender(dsl, context, Vue, loader, brothers);
    }

    const render = (context: Context, seq: number = 0) => {
        const $components = context.$components;

        const component = (() => {
            // 内置组件 component
            if (dsl.name === 'component') {
                return createBuiltInComponent(context, dsl.props?.is as any);
            }
            // 内置插槽
            if (dsl.name === 'slot') return dsl.name;

            // 组件加载器,默认返回 dsl.name

            const name = loader(dsl.name, dsl.from, Vue);
            // ...
            return name;
        })();

        const props = parseNodeProps(id, dsl.props ?? {}, context);
        const events = parseNodeEvents(Vue, dsl.events ?? {}, context);

        // 插槽
        if (dsl.name === 'slot') {
            return renderSlot(Vue, dsl, props, context, loader);
        }

        // v-bind
        if (vBind) {
            Object.assign(props, context.__parseExpression(vBind.value));
        }

        // v-show ...
        // v-html ...
        // v-model ...
        
        const __scopeId = context?.__id ? `data-v-${context.__id}` : undefined;
        const styleScope = __scopeId ? { [__scopeId]: '' } : {};
        let vnode = Vue.createVNode(
            component,
            { key: `${id}_${seq}`, ...styleScope, ...props, ...events },
            slots
        );

        // v-others 绑定其他指令 ...

        return vnode;
    };

    // v-for
    if (vFor) {
        return vForRender(vFor, render, context);
    }

    return render(context);
}
```
### 渲染方式

- 设计器模式: ide/views/index.vue
  - 在 new Engine 中创建设计模式Provider: new Provider({ mode: ContextMode.Design })
  - 通过 doc.write 创建模板文件，再将 DSL 定义 Vue 组件进行渲染
- 设计器中预览: ide/views/preview.vue
  - 设计器展示仍然从 ide/views/index.vue 中进
  - 在点击预览按钮时, 页面骨架显示 preview region (components/regions/preview.vue)
  - 从而显示 Previewer widget (components/widgets/previewer/index.vue)
    - 里面通过 `<iframe v-if="src" ref="iframe" frameborder="0" :src="src"></iframe>` src 展示页面, 此 src 通过 path 函数动态组装
    
    ```js
    // ide/views/index.vue
    // 覆盖 Previewer widget 的 path 参数
    widgetManager.set('Previewer', {
        props: {
            path: (block: any, project: ProjectModel) => {
                const pathname = location.pathname;
                if (project.platform === 'uniapp') {
                    const host =
                        process.env.NODE_ENV === 'production'
                            ? ''
                            : 'http://localhost:8010';
                    return `${host}${pathname}uni/#/pages/${block.id}`;
                }
                // => /__vtj__/#/preview/26krwo44
                return `${pathname}#/preview/${block.id}`;
            }
        }
    });
    ```
  - 从而显示 ide/views/preview.vue 文件, 在其中重新创建运行时Provider: createProvider({ mode: ContextMode.Runtime })
    - 再通过 **provider.getRenderComponent** 获取需要渲染的 Vue 组件(先从Vue模板缓存中获取, 没有则基于 DSL 重新定义)
- 案例应用显示页面(vtj/apps/app)
  - 在 main.ts 中创建源码模式Provider: createProvider({ mode: ContextMode.Raw, router }), 并添加路由模板
  - 当触发路由模板时, 进行渲染 PageContainer 模板, 最终通过 **provider.getRenderComponent** 进行获取 DSL 信息进行渲染
  
```ts
// renderer/src/provider/provider.ts
export class Provider extends Base {
  constructor(public options: ProviderOptions) {
    //...
    // 设计模式在引擎已初始化了项目数据，这里不需要再次初始化
    if (project && mode !== ContextMode.Design) {
      // 如源码模式下
      this.load(project as ProjectSchema);
    } else {
      this.project = project as ProjectSchema;
    }
  }
  
  async load(project: ProjectSchema) {
    // ...
    /**
     * 源码模式只加载原生代码依赖
     * 其他模式加载完整资源(包括物料等)
     */
    if (this.mode === ContextMode.Raw) {
      await this.loadDependencies(_window);
    } else {
      await this.loadAssets(_window);
    }

    // 初始化Mock配置
    this.initMock(_window);
    // 创建API接口
    this.apis = createSchemaApis(apis, meta, this.adapter);
    // 清理并设置Mock API
    mockCleanup(_window);
    mockApis(apis, _window);

    // 非uniapp平台需要初始化路由
    if (project.platform !== 'uniapp') {
      // 初始化路由(添加模板路由)
      this.initRouter();
    }

    // 触发就绪事件
    this.triggerReady();
  }

  private initRouter() {
    const { router, project, options, adapter } = this;
    // 案例应用传入了路由. 而像接入
    if (!router) return;
    // ...
    const pageRoute: RouteRecordRaw = {
        // => /#/page/:id
        path: `${pathStart}${pageRouteName}/:id`,
        name: PAGE_ROUTE_NAME, // VtjPage
        component: PageContainer
    };
    const homeRoute: RouteRecordRaw = {
        path: pathStart,
        name: HOMEPAGE_ROUTE_NAME, // VtjHomepage
        component: project?.homepage
            ? PageContainer
            : adapter.startupComponent || StartupContainer,
        meta: routeMeta
    };
    if (router.hasRoute(PAGE_ROUTE_NAME)) {
        router.removeRoute(PAGE_ROUTE_NAME);
    }
    if (router.hasRoute(HOMEPAGE_ROUTE_NAME)) {
        router.removeRoute(HOMEPAGE_ROUTE_NAME);
    }
    // ...
    router.addRoute(pageRoute);
    router.addRoute(homeRoute);
  }
}

// renderer/src/provider/page.ts
export const PageContainer = defineComponent({
    name: 'VtjPageContainer',
    async setup() {
        const provider = useProvider();
        // ...
        const component = file ? await provider.getRenderComponent(file.id) : null;
        // ...
    },
    render() {
        const { component, query, sid } = this;
        if (component) {
            return h(component, { ...query, key: sid });
        } else {
            return h('div', '页面不存在');
        }
    }
});
```
- **主应用显示页面**(如: https://gitee.com/newgateway/vue-element-plus-admin/tree/dev-vtj)
    - 在 main.ts 中通过 setupElementAdmin 创建源码模式Provider: createProvider({ mode: ContextMode.Raw }), 尚未传入路由
    - 在 router/index.ts 中通过 setupElementAdminRoutes 添加路由
      - 读取 .vjt/projects/${project.id}.json 项目配置文件, 将pages循环添加到项目路由中, 并且每个路由指向的是 .vtj/vue/${id}.vue 页面源码文件

### renderer-provider依赖注入分析

- 参考: https://deepwiki.com/search/useprovider_9ec38dea-d0d1-4819-84df-71a90d0eb3c7

```js
// 1.初始化vtj: setupElementAdmin 为 @vtj/web/integrations/element-admin.ts 提供的集成工具函数
import { setupElementAdmin } from '@vtj/web'
setupElementAdmin({
    id: vtj.id,
    app,
    ready: () => {
        app.mount('#app')
    }
})

// 2.创建及安装 provider 插件
export function setupElementAdmin(options: SetupElementAdminOptions) {
  // ...
  // (主应用入口)创建 provider 插件
  // 设计模式入口创建 provider 插件参考: @vtj/pro/idea/views/page.vue
  const { provider, onReady } = createProvider({
    nodeEnv: process.env.NODE_ENV as NodeEnv,
    // ContextMode.Raw: 源码模式(默认不会初始化mock, 即设计模式下会显示mock数据, 但是嵌入到应用后不会显示mock数据)
    // 如果要在 ContextMode.Raw 模式下需要显示mock, 可在 main.ts 增加 import Mock from 'mockjs'; (window as any).Mock = Mock; 或如下动态判断
    // if (import.meta.env.DEV) {
    //     import('mockjs').then((Mock) => {
    //         (window as any).Mock = Mock.default || Mock
    //     })
    // }
    mode: ContextMode.Raw,
    modules,
    adapter,
    service,
    dependencies: {
      Vue: () => import('vue'),
      VueRouter: () => import('vue-router')
    },
    project: {
      id
    }
  });

  onReady(async () => {
    // 在Vue上安装 provider 插件
    app.use(provider);
    ready && ready();
  });
  // ...
}

// 3.@vtj/renderer/provider.ts
export function createProvider(options: ProviderOptions) {
  // 实例化 Provider 对象
  const provider = new Provider(options);
  const onReady = (callback: () => void) => provider.ready(callback);
  return {
    provider,
    onReady
  };
}

export const providerKey: InjectionKey<Provider> = Symbol('Provider');

export class Provider extends Base {
  constructor(public options: ProviderOptions) {
    // ...
    // load加载应用目录 .vtj/projects/${project.id}.json 配置文件
    if (project && mode !== ContextMode.Design) {
      // 加载 .vtj 目录文件, 加载依赖/物料, 初始化Mock配置, ...
      // this.triggerReady();
      this.load(project as ProjectSchema);
    } else {
      this.project = project as ProjectSchema;
    }
  }

  // 用于测试环境获取mock对象
  public createMock(func: (...args: any) => any) {
    return async (...args: any[]) => {
      let template = {};
      if (func) {
        try {
          template = await func.apply(func, args);
        } catch (e) {
          logger.warn('模拟数据模版异常', e);
        }
      }
      const Mock = getMock();
      return Mock?.mock(template);
    };
  }

  // ...
  // 提供Vue插件安装回调函数
  install(app: App) {
    // ...
    // 注入: 提供全局 Provider 实例
    app.provide(providerKey, this);
    app.config.globalProperties.$provider = this;
  }
}

export function useProvider(options: UseProviderOptions = {}): Provider {
  const provider = inject(providerKey, null);
  if (!provider) {
    throw new Error('Can not find provider');
  }
  if (provider.nodeEnv === 'development') {
    // ... 检查组件源码版本与运行时版本是否一致
  }
  return provider;
}

// 4.应用(生成的)代码中进行使用
import { useProvider } from '@vtj/renderer';

// @vjt/coder/src/templates.ts 中出码生成的
setup(props) {
    const provider = useProvider({ id: '26krwo44', version: '1749988203748' });
    const state = reactive({});
    return { state, props, provider };
}
```

## 百度amis

- [gitee](https://gitee.com/baidu/amis)
- [文档](https://baidu.github.io/amis/zh-CN/docs/index)
- [可视化演示](https://aisuda.github.io/amis-editor-demo/)
- amis 是一个低代码前端框架，它使用 JSON 配置来生成页面。百度开源
- 说明
    - 支持JS SDK(可以像 Vue/jQuery 那样外链代码就能使用)和React版本
    - 支持WEB、H5
    - 如果需要自定义组件，需要基于React实现

## 华为TinyEngine

- 华为 https://www.opentiny.design/tiny-engine#/home

## 腾讯tmagic-editor

### 简介

- [github](https://github.com/Tencent/tmagic-editor)
- [docs](https://tencent.github.io/tmagic-editor/docs/)
- [可视化演示](https://tencent.github.io/tmagic-editor/playground/index.html#/)
- 腾讯开源，支持Vue2/Vue3/React等
- 说明
    - 适用于H5页面生成
    - 组件任意位置拖拽
    - 支持组件较少

### tmagic-editor

- 核心内容，是包含在 packages/editor 中的编辑器，以及 runtime 和 packages/ui
    - packages 目录中提供的内容，我们都以 npm 包形式输出，开发者可以通过安装对应的包来使用
        - ui 基于Vue3提供常用组件，如按钮/图片/文本组件。这些组件最终是结合runtime进行展示
    - runtime目录 是我们提供的编辑器活动页和编辑器模拟器运行的页面项目示例。可以直接使用，也可以参考并自行实现
    - playground 是一个简单的编辑器项目示例。即使用了 packages 和 runtime 内容的集成项目。开发者可以参考 playground，使用魔方提供的能力实现一个满足业务方需求的编辑器
        - 可基于此自定义自己的可视化编辑器
        - src/config 为自定义组件和DSL样例数据

```bash
git clone git@github.com:Tencent/tmagic-editor.git
npm install -g pnpm
pnpm bootstrap
# 运行项目
# 基于pnpm的--filter过滤包名，相当于运行了playground和runtime/vue3两个项目
# 运行runtime/vue3的dev命令后，相当于执行了其build:libs命令，会根据dev.vite.config.ts的配置将打包的库文件放到playground/public/entry/vue3目录
# 然后将vue3的url地址设置成playground的编辑器可视化区地址(中间使用了一层代理)
pnpm playground
```

### tmagic-admin

- [tmagic-admin](https://github.com/vft-magic/tmagic-admin)
    - 基于tmagic-editor的活动页面管理程序，后端使用node

### 实现uniapp-runtime

- 参考: https://tencent.github.io/tmagic-editor/docs/guide/runtime.html
- 创建uniapp cli项目
- 创建playground目录和其打包逻辑

## vxe-table可视化模板

- https://vxeui.com/zero-code
- 演示: https://vxeui.com/zero-code-template/

## 研发测试记录

- vue动态component模式
    - 小程序不支持：https://uniapp.dcloud.net.cn/component/vue-component.html#component
    - taro编译的小程序支持动态component模式
- 将所有组件for循环后进行v-if展示
    - 必须引入所有组件
    - 编辑器参考：https://gitee.com/leadshop/panel/blob/master/src/pages/package/index.vue#L12
    - 渲染参考：https://gitee.com/leadshop/applet/blob/master/src/pages/index/index.vue#L38

### uniapp零散 

- [dragUI](https://ext.dcloud.net.cn/plugin?id=1035)
    - 设计器基于uniapp实现，保存json并通过ejs渲染文件模板生成源码文件
    
    ```html
    <!--设计器-->
    <draggable group="layouts" :list="list"
                :options="{
            }"
                @change="draggableChange"
                :style="[computedClassToStyle(phoneClass),phoneStyle]"
                style="position: absolute;top: 25px;bottom: 0;left: 0;right: 0"
                handle=".flex-draggalbe-handle"
    >
        <template v-for="(item,index) in list">
            <component :key="index" :is="item.componentName"
                        :dataIIndex="index + ''"
                        v-bind="item"
            ></component>
        </template>
    </draggable>

    <script>
        // 渲染模板
        let outExportStr = (list,customClass,fileStyleAndClass,mode = 'page') => {
            let x = ejs.render(fileTemplates, {list,
                // ...
            },{rmWhitespace:true},)

            x = formatStrByHtml(x)
            return x
        }
    </script>
    ```
- [diygw-ui](https://www.diygw.com/) 未开源
- [diyhey](https://we7.diyhey.com/admin/login) 未开源
- uni-lowcode
    - app(基于uni-app uview-ui的拖拽设计器) + api(基于node mogodb的后台服务)可得到组件排列的json数据
    - 存在问题
        - 使用的component动态渲染组件json，小程序不支持
    - app设计器
        - app/src/pages/index/design.vue -> r-vue-edit自定义模拟器组件(未使用iframe)

        ```html
        <!-- 外层传入的组件信息，可实现组件选择增加选中边框 -->
        <view
            v-for="(item, index) in options"
            :key="index"
            @click="focus(index, item.type)"
            :class="{ active: config.current === index }"
        >
            <!-- 删除组件按钮 -->
            <button
            
            @click.stop="remove(index)"
            v-if="config.current === index"
            class="delete"
            >X</button>
            <r-drag :index="index" @swapComp="swapComp" @addComp="addComp">
            <!-- 模拟器进行动态展示组件，小程序不支持此方式 -->
            <component
                :is="item.type"
                :option="item.option"
                :compStyle="item.compStyle"
            ></component>
            </r-drag>
        </view>
        ```
- uni-diy: https://gitee.com/qianyu_wyc/uni-diy
    - 基于v-if显示组件列表，参考: https://gitee.com/qianyu_wyc/uni-diy/blob/master/uni-demo/pages/index/index.vue#L8

### pageplug

- [pageplug](https://github.com/cloudtogo/pageplug)
- PagePlug 是 Appsmith 的中国化项目
- 移动端基于 Taro 实现，支持微信小程序
- 启动
    - 服务端启动(app/server)：https://github.com/cloudtogo/pageplug/blob/open-v1.8/contributions/ServerSetup.md
    - 前端画布启动(app/client)：https://github.com/cloudtogo/pageplug/blob/open-v1.8/contributions/ClientSetup.md
        - `./start-https.sh`启动nginx
            - 需修改nginx配置
        - `yarn start` 启动前端
        - 访问`https://dev.appsmith.com`
    - 启动taro(app/taro, 获取后端DSL配置进行展示)
        - 使用node14+ (mac i386架构安装)
        - npm install -g @tarojs/cli
        - yarn
        - yarn add @tarojs/plugin-framework-react
        - yarn dev:weapp
- 前端拖拽组件，将物料保存到后端数据库，并触发taro刷新(重新通过接口获取DSL，从而更新页面展示)

### lowcode-designable-taro-react

- 拖拽基于基于designable+formily(react)，移动端基于 Taro 实现，支持微信小程序
- https://github.com/weilaiqishi/lowcode-designable-taro-react
    - 技术文章：https://github.com/weilaiqishi/lowcode-designable-taro-react/tree/taro3.6/article
    - 编译好物料；通过编辑器拖拽组件，生成DSL；将DSL手动复制到taro模块中从而刷新页面展示

### 基于lowcode-engine和taro实现测试

- 参考lowcode-designable-taro-react、pageplug
- node v16 yarn
- lowcode-editor
    - yarn start
    - http://localhost:5555/preview.html 预览页已实现嵌入taro
- lowcode-taro
    - 简单的taro小程序demo
    - yarn run dev:weapp
- lowcode-ui
    - yarn组件物料案例
    - yarn lowcode:dev 将build.lowcode.js做为配置文件(默认为build.json)
    - 此时在build.lowcode.js中引入插件build.plugin.js对webpack进行二次配置（如设置alias和EnvironmentPlugin TARO_ENV）
    - @taroify样式需使用babel按需导入(babel.config.js)
        - 全量导入会出现 Module not found: Error: Can't resolve './fonts/number-keyboard.eot?o8m3qv'
        - 可考虑使用patch-package解决
    - 像素转换问题
        - 使用插件postcss-pageplug-pxtorem
    - 报错postcss-safe-parser `Class constructor Parser cannot be invoked without 'new'`
        - postcss-pageplug-pxtorem使用的是postcss 8.3, taro也是8.x, 需要结合postcss-safe-parser 6.x; 而lowcode build-script用的postcss-safe-parser是4.x
    - 报错`TypeError: Cannot read properties of undefined (reading 'unprefixed')`
        - 由于lowcode build-plugin-component依赖cssnano 4.x(postcss 7.x)，而postcss 8.x下的postcss-discard-overridden和postcss 7.x下的不兼容；只能选择postcss 7.x，从而又会出现postcss-pageplug-pxtorem无法使用(可自行考虑转换方案)
    - 存在问题
        - 打包的物料无法私有话部署，解决方案参考(可解决)：https://github.com/alibaba/lowcode-engine/issues/638
        - 项目无法内网部署问题：https://github.com/alibaba/lowcode-engine/issues/1285
    - '@tarojs/components' 中的图片CoverImage，使用@tarojs/components/dist-h5/react中的组件无法渲染成个，必须使用`import { defineCustomElements } from '@tarojs/components/dist/esm/loader.js';`解决，但是加上次代码之后只能在本地预览成功，远程调试和打包之后放到editor中都不显示图片
- lowcode-taro-ui
    - `npx yarn@1.19.0 add taro-ui` yarn 1.21.1版本会报错：`Invariant Violation: expected workspace package to exist for "string-width"`，参考：https://github.com/yarnpkg/yarn/issues/7807
- lowcode-taro
    - lowcode基于webpack4，taro基于webpack5，暂时只找到通过resolutions解决，根据运行的lowcode-eidtor或lowcode-taro不同的模块，决定是否添加`"webpack": "^5.69.0"`同一包处理
    - node_modules/@alilw/lowcode-utils/cursor.css 里面的*通配符小程序不支持，打包后临时手动修改dist文件，并修改app.js，将两个wxss的样式文件注释掉
    - 但是还在无法运行。无法解决：需要动态CDN加载物料库等文件，而小程序不支持动态加载

### 基于uniapp手动实现测试

- [vue-draggable-next](https://github.com/SortableJS/vue.draggable.next)
    - 官方案例：https://sortablejs.github.io/vue.draggable.next
    - 使用说明：https://www.itxst.com/vue-draggable-next/tutorial.html

## 开源项目

- https://github.com/JackySoft/marsview



