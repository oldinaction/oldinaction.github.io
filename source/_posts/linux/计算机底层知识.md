---
layout: "post"
title: "计算机底层知识"
date: "2020-06-16 20:50"
categories: [linux]
tags: [cpu, java]
---

## 书籍推荐

- 计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》
- 语言：C JAVA 《C程序设计语言》《C Primer Plus》
- 数据结构与算法：《Java数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》
- 操作系统：Linux内核源码解析、**Linux内核设计与实现**、30天自制操作系统
- 网络：机工《TCP/IP详解》卷一
- 编译原理：《编译原理》《编程语言实现模式》
- 数据库：SQLite源码、Derby(JDK自带数据库)

## 硬件基础知识

- 计算机的组成

    ![计算机的组成](/data/images/linux/计算机的组成.png)
- CPU制作
    - Intel cpu的制作过程：https://haokan.baidu.com/v?vid=11928468945249380709&pd=bjh&fr=bjhauthor&type=video
    - CPU是如何制作的(文字描述)：https://www.sohu.com/a/255397866_468626
- CPU的原理
    - 计算机需要解决的最根本问题：如何代表数字
    - 晶体管是如何工作的：https://haokan.baidu.com/v?vid=16026741635006191272&pd=bjh&fr=bjhauthor&type=video
    - 晶体管的工作原理：https://www.bilibili.com/video/av47388949?p=2
    - 发展过程
        - 硅 - 加入特殊元素 - P半导体 N半导体 - PN结 - 二极管 - 场效应晶体管 - 逻辑开关
        - 基于逻辑开关实现：与门、或门、非门(异或)，即基础逻辑电路
        - 再实现加法器、累加器、锁存器
        - 实现手动计算(通电一次，运行一次位运算)
        - 加入内存，实现自动运算(每次读取内存指令)。CPU的每个针脚可以读取一个0/1
    - CPU、内存、显卡等都是和主板进行连通
- 总线
    - 总线是计算机各部件之间传递信息的基本通道，将每根小线捆到一起的一根线即为总线
    - 依据传递的内容不同，总线又分为数据总线、地址总线、控制总线3种。CPU根据不同总线过来的从内存读取数据，从而区分哪些为立即数，哪些为指令(最终还是0101，因此需要根据总线类型区分)
- 汇编语言（机器语言）的执行过程
    - 最早手工输入：纸带计算机，纸带上有孔，有孔没孔可代表1/0。一次一只虫子堵住了此孔，因此产生了BUG
    - 汇编语言的本质：机器语言(0101)的助记符(mod)，其实它就是机器语言
    - 计算机通电 -> CPU读取内存中程序（电信号输入）-> 时钟发生器不断震荡通断电(相关的如CPU频率) -> 推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期）-> 计算完成 -> 写回（电信号）-> 写给显卡输出（sout，或者图形）
    - c编译完后直接是机器码，CPU可直接执行，即编译执行；java编译后是二进制码(ByteCode)，执行时通过虚拟机解释成机器语言进行执行，即解释执行
- 量子计算机
    - 量子比特，可同时表示1和0
    - 潘建伟18bit量子纠缠：使用6个光子(有3个特点：路径、偏振、角动力)得到6*3=18个bit，每个bit有2中状态，相当于2^18中可能。经典计算机只能表示2^18中的一个数，而量子计算则能同时表示2^18个数
- 启动
    - 通电 -> bios/uefi 工作 -> 自检 -> 到硬盘固定位置加载bootloader -> 读取可配置信息 -> CMOS(如保存开机密码，有一块额外的小电池通电，没电了数据就会丢失)

    ![电脑启动](/data/images/linux/电脑启动.png)

## CPU

### CPU的基本组成

- PC(Program Counter) 程序计数器(记录当前指令地址)
- Registers 寄存器，暂时存储CPU计算需要用到的数据，速度比内存快很多
    - Intel的寄存器如：AX/BX...(16位)，EAX/EBX...(32位)，RAX/RBX...(64位)
    - 64位机器(CPU)一般指寄存器一次性可以存储64位，ALU一次性也可读取64位
- ALU(Arithmetic & Logic Unit) 运算单元。如从寄存器的AX中读取2，BX中读取3，然后通过ALU进行运算得到5，并将5存储在如DX中，最好写会内存
- CU(Control Unit) 控制单元
- MMU(Memory Management Unit) 内存管理单元
- cache

### 超线程

- 一个ALU对应多个PC和Registers，即所谓的4核8线程，一个核如下

    ![超线程](/data/images/linux/超线程.png)

### 三级缓存和伪共享

- [三级缓存和伪共享](https://www.cnblogs.com/cyfonly/p/5800758.html)
- 按块读取
    - 从硬盘往内存读，从内存往缓存读都是按块读取的，从而提高效率。充分发挥总线、CPU针脚一次性读取更多数据的能力
- 三级缓存

    ![三级缓存](/data/images/linux/三级缓存.png)
    - CPU 缓存可以分为一级缓存(L1)，二级缓存(L2)，部分高端 CPU 还具有三级缓存(L3)
    - 每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小，所以 L1 缓存很小但很快。L1,L2只能被单独的 CPU 核使用，L3被单个插槽上的所有 CPU 核共享
    - 主存(常说的内存)则由全部插槽上的所有 CPU 核共享
- MESI 协议及 RFO 请求
    - 每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时，另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据，该怎么办呢？
        - 有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输
        - 所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次
        - 由此，第2个核修改了这份数据，那么第1个核原来的数据就成了脏数据，解决方式就是通过EMSI协议进行缓存行操作
    - MSI、MESI(M修改, E专有, S共享, I无效)、MOSI及Dragon Protocol等都是为了解决缓存一致性的协议
    - RFO(Request For Owner)请求，为MESI协议中需要将当前核心的某缓存行设置为E，将其他核心的该缓存行设置为I
- 伪共享 
    - 缓存系统中是以缓存行(cache line, 通常是 64 字节)为单位存储的，当多线程修改互相独立的变量时(发起的RFO请求会耗性能)，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享
- 解决伪共享
    - JDK7中很多采用缓存行填充(空间换时间)。Disruptor就是通过缓存行填充实现
    - JDK8开始可以使用@Contended注解(需加JVM参数：-XX:-RestrictContended)来避免伪共享
- 缓存行对齐(缓存行填充)
    - 对于有些特别敏感的数字，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存航对齐的编程方式

### WC合并写技术

- WC(Write Combining) 合并写
- 某些计算机在寄存器和三级缓存之间还有其他缓存，如与L1之间有Load Buffer、Store Buffer，与L2之间有WC Buffer，他们的空间很小，但是速度比三级缓存快
- 由于ALU速度太快，所以在写入L1的同时写入一个WC Buffer，满了之后，再直接更新到L2(因为L1最终需要写入到L2)，大小一般是4个字节

<details>
<summary>WC合并写技术程序证明</summary>

```java
// runCaseTwo比runCaseOne更快(但是runCaseTwo循环次数更多，且写入的数据多)
public final class WriteCombining {

    private static final int ITERATIONS = Integer.MAX_VALUE;
    private static final int ITEMS = 1 << 24;
    private static final int MASK = ITEMS - 1;

    private static final byte[] arrayA = new byte[ITEMS];
    private static final byte[] arrayB = new byte[ITEMS];
    private static final byte[] arrayC = new byte[ITEMS];
    private static final byte[] arrayD = new byte[ITEMS];
    private static final byte[] arrayE = new byte[ITEMS];
    private static final byte[] arrayF = new byte[ITEMS];

    public static void main(final String[] args) {

        for (int i = 1; i <= 3; i++) {
            System.out.println(i + " SingleLoop duration (ns) = " + runCaseOne());
            System.out.println(i + " SplitLoop  duration (ns) = " + runCaseTwo());
        }
    }

    public static long runCaseOne() {
        long start = System.nanoTime();
        int i = ITERATIONS;

        while (--i != 0) {
            int slot = i & MASK;
            // 7个写操作
            byte b = (byte) i;
            arrayA[slot] = b;
            arrayB[slot] = b;
            arrayC[slot] = b;
            arrayD[slot] = b;
            arrayE[slot] = b;
            arrayF[slot] = b;
        }
        return System.nanoTime() - start;
    }

    public static long runCaseTwo() {
        long start = System.nanoTime();
        int i = ITERATIONS;
        while (--i != 0) {
            int slot = i & MASK;
            // 4个写操作
            byte b = (byte) i;
            arrayA[slot] = b;
            arrayB[slot] = b;
            arrayC[slot] = b;
        }
        i = ITERATIONS;
        while (--i != 0) {
            int slot = i & MASK;
            // 4个写操作
            byte b = (byte) i;
            arrayD[slot] = b;
            arrayE[slot] = b;
            arrayF[slot] = b;
        }
        return System.nanoTime() - start;
    }
}
```
</details>

### 乱序执行与防止指令重排

- 乱序执行
    - CPU执行命令时并不一定完全按照程序代码一行行的执行，而会进行指令重排，当CPU在进行读等待的同时执行指令，最终结果不会有影响。CPU乱序的是为了提高效率
    - as-if-serial：不管如何重排序，单线程执行的结果不变，看上去像是serial
    - 程序证明：[jvm/jmm/Disorder.java](https://preshing.com/20120515/memory-reordering-caught-in-the-act/)
- 禁止乱序
    - CPU层面
        - 使用内存屏障或锁总线
            - 如Intel底层使用内存屏障，对应原语(lfence读屏障 sfence写屏障 mfence混合屏障)。sfence表示：在某个sfence指令之前的写指令为A指令集，在其后的写指令为B指令集，此时A指令必须在B指令之前完成
            - 如Intel lock汇编指令，执行后会锁住内存子系统来确保执行顺序，甚至跨多个CPU
        - lock指令一般CPU都有，但是内存屏障可能部分品牌没有内存屏障原语支持，HotSpot直接使用了lock指令来防止指令重排
    - JVM层级
        - JSR(JVM规范)内存屏障(LL LS SL SS)
            - LoadLoad(LL)：对于Load1;LoadLoad;Load2;这样的指令，Load2即之后读操作要在Load1读操作之后完成。其他如LoadStore类似
        - volatile实现细节，读写操作都加了内存屏障
            - StoreStoreBarrier;volatile写操作;StoreLoadBarrier;
            - LoadLoadBarrier;volatile读操作;LoadStoreBarrier;
        - volatile一个对象时，只要对象任何属性有变化则会有禁止指令重排
- JVM规定重排序必须遵守8个hanppens-before原则
- 案例：DCL单例(双重检查单例，Double Check Lock)必须配合volatile，此时volatile即达到了指令重排的作用

### NUMA

- UMA(Uniform Memory Access)：多个CPU通过一个总线访问同一个内存。但缺点是CPU增加导致资源抢占，工业测试证明4颗效果最好
- NUMA(Non Uniform Memory Access)：非同一内存访问
- ZGC - NUMA aware：分配内存会优先分配该线程所在CPU的最近内存

![UMA-NUMA](/data/images/linux/UMA-NUMA.png)

## OS

### 内核

- kernel内核作用：负责调度CPU，管理内存、文件系统、进度调度、设备驱动等
- 内核分类
    - 宏内核：PC、phone
    - 微内核：弹性部署、5G、IoT。用户请求某个内核，这个内核可能无法处理，他会请求其他内核进行处理(也可能联网请求，如控制冰箱内核、电视内核等)
    - 外核：为应用定制操作系统，科研中(多租户 request-based GC JVM)
- 内核态与用户态
    - cpu分不同的指令级别：0 1 2 3
    - linux内核跑在ring 0级，用户程序跑在ring 3，对于系统的关键访问(如访问硬件)，需要经过kernel的同意，保证系统健壮性
    - 内核执行的操作：200多个系统调用，sendfile read write pthread fork等
    - 站在OS老大的角度，JVM就是个普通程序

### 进程/线程/纤程

- 进程和线程
    - 进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径
    - 进程是OS分配资源的基本单位，线程是执行调度的基本单位。分配资源最重要的是：独立的内存空间，线程调度执行（线程共享进程的内存空间，没有自己独立的内存空间）
- 纤程
    - 用户态的线程，线程中的线程，切换和调度不需要经过OS。java的new Thread与OS系统的线程一一对应
    - 优势
        - 切换和调度不需要和内核打交道。如线程要和内核打交道，因此中途会调用80软中断(见下文)，效率会低
        - 占有资源很少，OS启动一个线程大约要1M空间，启动一个Fiber纤程大约需要4K
        - 纤程切换比较简单，线程切换较耗时。可以启动很多个10W+，OS启动1W个线程时进行切换就会较耗时
    - 目前支持内置纤程的语言：Kotlin、Scala、Go、Python(lib)... Java(需要open jdk的loom库支持)
- 进程在linux中也称task，是系统分配资源的基本单位
    - 资源：独立的地址空间、内核数据结构(进程描述符等)、全局变量、数据段等
    - 进程描述符：PCB(Process Control Block)
- 进程创建和启动
    - 系统函数fork() exec()
    - 从A中fork B的话，A称之为B的父进程
- 僵尸进程
    - 父进程产生子进程后，会维护子进程的一个PCB结构，子进程退出，由父进程释放；如果父进程没有释放，那么子进程成为一个僵尸进程
    - `ps -ef | grep defunct` 查询所有的僵尸进程，此时只能杀掉父进程才会从ps中消失
- 孤儿进程
    - 子进程结束之前，父进程已经退出，孤儿进程会成为init进程的孩子，由1号进程进行维护

<details>
<summary>僵尸进程和孤儿进程案例</summary>

```c
// 僵尸进程
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>
​
int main() {
    // 复制一个子进程出来
    pid_t pid = fork();
​
    if (0 == pid) {
        // 会在子进程中运行
        printf("child id is %d\n", getpid());
        printf("parent id is %d\n", getppid());
    } else {
        // 会在主进程中运行
        while(1) {}
    }
}

// 孤儿进程
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>
​
int main() {
    pid_t pid = fork();
​
    if (0 == pid) {
        printf("child ppid is %d\n", getppid());
        sleep(10);
        printf("parent ppid is %d\n", getppid());
    } else {
        printf("parent id is %d\n", getpid());
        sleep(5);
        exit(0);
    }
}
```
</details>

- 进程类型
    - IO密集型：大部分时间用于等待IO
    - CPU密集型：大部分时间用于计算
- 进程(任务)调度
    - 发展过程为从单任务独占到多任务分时，最大限度的压榨CPU资源
    - 多任务的抢占式和非抢占式
        - 非抢占式(cooperative multitasking)：除非进程主动让出cpu(yielding)，否则一直运行
        - 抢占式(preemptive multitasking，采用较多)：由进程调度器强制开始或暂停(抢占)某一进程的执行
- linux进程调度
    - linux2.5采用经典Unix O(1)调度策略(执行时间均匀分配)，偏向服务器，但对UI交互不友好
    - linux2.6.23采用CFS(Completely Fair Scheduler)完全公平调度算法
        - 按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间少于他应该分配的比例，则优先执行
- 进程优先级
    - 实时进程 > 普通进程(0-99)
    - 普通进程则按照nice值(-20-19)
    - linux默认调度策略
        - 实时进程：使用SCHED_FIFO(按照优先级来)和SCHED_RR(优先级一样则轮询)两种
        - 普通进程：使用CFS
        - 默认执行等级为FIFO的实时进程，且linux会一致执行它，除非自己让出CPU、更高等级的FIFO、同FIFO等级的RR抢占它。只有实时进程主动让出或者执行完毕，普通进程才有机会执行

### 中断

- 中断为硬件或软件要和内核打交道的处理信号
- 中断处理过程
    - 键盘按下 - 中断控制器收到 - 传递给芯片 - 到内存中固定位置找执行程序 - 通知kernel - 中断处理程序(对应有一个中断向量表。记录如键盘对应的处理程序，鼠标对应的处理程序等)
- 软中断
    - 又称80中断/系统调用。指软件产生的中断，即用户空间的处理程序需要调用内核空间的函数
    - 软中断方式：int 0x80(80中断) 或者 sysenter原语(更先进)
    - 调用过程：通过ax寄存器填入系统调用号(内核函数的编号)，参数通过bx cx dx si di传入内核，返回值写到ax进行返回
    - 如java读网络的中断过程：jvm read() - c库read() - 内核空间 - system_call()系统调用处理程序 - sys_read()
- 基于汇编理解软中断
    - `yum install nasm` 搭建汇编环境
    - 编译 `nasm -f elf  hello.asm -o hello.o`
    - 链接 `ld -m elf_i386 -o hello hello.o` 生成一个hello可执行文件
    - 执行 `./hello`

```ini
;hello.asm
;分号开头为注释
;write(int fd, const void *buffer, size_t nbytes)
;fd 文件描述符 file descriptor(不同的介质对应不同的文件描述符，如网络、文件、标准输出) - linux下一切皆文件

section data ;数据段声明
    msg db "Hello", 0xA ;要输出的字符串加换行
    len equ $ - msg ;字符串长度

section .text ;代码段声明
global _start ;指定入口函数
_start: ;在屏幕上显示一个字符串的函数

    mov edx, len ;参数三，将len数据保存在寄存器dx中
    mov ecx, msg ;参数二
    mov ebx, 1 ;参数一，文件描述符1 std_out
    mov eax, 4 ;write函数系统调用号 4
    int 0x80 ;调用80中断，即调用内核功能(write)

    mov ebx, 0 ;参数一，退出代码
    mov eax, 1 ;sys_exit函数系统调用号
    int 0x80
```
- 一个程序的执行过程，要么处于用户态，要么处于内核态(调用了软中断)

## 内存管理

- 内存管理的发展历程
    - DOS时代：同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）。内存大概64K数量级
    - windows9x(windows95等)：多个进程装入内存，内存大概16M数量级。产生了问题：内存不够用、互相打扰
    - 为了解决上述两个问题，诞生了现在的内存管理系统：虚拟地址、分页装入、软硬件结合寻址
- 分页(内存不够用)，内存中分成固定大小的页框(4K)，把程序(硬盘上)分成4K大小的块，用到哪一块，加载那一块，加载的过程中，如果内存已经满了，会把最不常用的一块放到swap分区，把最新的一块加载进来，这个就是著名的**LRU算法(Least Recently Used)**(见[msb#一#161#00:58:13])
- 虚拟内存(解决相互打扰问题)
    - DOS Win31等，各进程间内存可互相访问，容易相互影响
    - 虚拟内存让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到B进程的空间
    - 虚拟空间大小为寻址空间大小，64位系统为2^64 byte，比物理空间大很多
- 内存映射
    - 偏移量 + 段的基地址 = 线性地址(虚拟空间地址)，线性地址再通过 OS + MMU(Memory Management Unit)硬件映射为物理地址()
- 缺页中断：需要用到页面内存中没有，产生缺页异常(中断)，由内核处理并从磁盘加载到内存

### ZGC

- ZGC(zero paused GC)，使用算法为Colored Pointer
- GC信息记录在指针上，不是记录在Java对象的头部。如果记录在头部要回收则需要修改头信息，而ZGC只需要修改指针信息。优点是immediate memory use
- 在64位系统中，ZGC利用了对象引用的4bit，低42位为对象的实际地址(因此最大寻址空间为2^42=4T)，高18位为预留

    ![jvm-ZGC](/data/images/java/jvm-ZGC.png)
    - Marked0/marked1: 判断对象是否已标记
    - Remapped: 判断应用是否已指向新的地址
    - Finalizable: 判断对象是否只能被Finalizer访问
- JDK13最大寻址空间为16T=2^44
    - 理论上64位系统(指针地址大小为64位)，去掉4位标记信息，剩下的为2^60寻址空间可用
    - 但是由于主板制造商为了节约成本，地址总线并没有提供64根，而是48根，从而最大寻址空间为2^(48-4)=2^44=16T

## 内核同步机制

- 基本概念
    - 临界区（critical area）:访问或操作共享数据的代码段。简单理解：synchronized大括号中部分（原子性）
    - 竞争条件（race conditions）两个线程同时拥有临界区的执行权
    - 数据不一致：data unconsistency 由竞争条件引起的数据破坏
    - 同步（synchronization）避免race conditions
    - 锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在）。上锁解锁必须具备原子性
    - 原子性（象原子一样不可分割的操作）
    - 有序性（禁止指令重排）
    - 可见性（一个线程内的修改，另一个线程可见）
- 内核同步常用方法
    - **原子操作** – 内核中类似于java的AtomicXXX(基于cas，但是内核的原子操作是基于原语完成的)，位于`linux/types.h`
    - **自旋锁** – 内核中通过汇编支持的cas，位于`asm/spinlock.h`
    - 读-写自旋 – 类似于ReadWriteLock，可同时读，只能一个写。读的时候是共享锁，写的时候是排他锁
    - **信号量** – 类似于Semaphore(PV操作 down up操作 占有和释放)。重量级锁，线程会进入wait(Java的Semaphore是通过cas完成)，适合长时间持有的锁情况
    - 读-写信号量 – downread upread downwrite upwrite（多个写，可以分段写，比较少用）分段锁
    - 互斥体(mutex) – 特殊的信号量（二值信号量），类似synchronized
    - 完成变量 – 特殊的信号量（A发出信号给B，B等待在完成变量上）。vfork() 在子进程结束时通过完成变量叫醒父进程，类似于(Latch)
    - BKL：大内核锁（早期，现在已经不用）
    - **顺序锁**(内核 v2.6开始) – 线程可以挂起的读写自旋锁，基于序列计数器：从0开始，写时+1，写完释放+1；读前发现单数，说明有写线程，可进行等待或读取临时值；读前未偶数，说明已经写完，可进行读取；读前读后序列一样，说明没有写线程打断
    - 禁止抢占 – preempt_disable()
    - 内存屏障 – 见[乱序执行与防止指令重排](#乱序执行与防止指令重排)

## IO






166 174 177 184 185 



## 汇编实现引导程序

- 编写汇编码

```ini
; 文件名 boot.asm
 
org 7c00h                     ; BIOS读入MBR后，从0x7c00h处开始执行。因此必须是7c00h
 
; 下面部分和10h有关中断，10h中断用来显示字符
mov ax, cs
mov es, ax
mov ax, msg
mov bp, ax                    ; ES:BP表示显示字符串的地址
mov cx, msgLen                ; CX存字符长度
mov ax, 1301h                 ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）
mov bx, 000fh                 ; BH=00h表示页号，BL=0fh表示颜色
mov dl, 0                     ; 列
int 10h
  
msg: db "hello world, welcome to OS!"
msgLen: equ $ - msg           ; 字符串长度
times 510 - ($ - $$) db 0     ; 填充剩余部分
dw 0aa55h                     ; 魔数，必须有这两个字节BIOS才确认是MBR
```
- 编译和制作启动软盘

```bash
# 在centos上运行即可
yum install nasm # 安装汇编环境
nasm boot.asm -o boot.bin # 编译

# 制作启动软盘
dd if=/dev/zero of=floppy.img bs=1474560 count=1 # 生成空白软盘镜像，大小必须为1.44M
dd if=boot.bin of=myos.img bs=512 count=1 # 制作包含主引导记录boot.bin的启动镜像文件
dd if=floppy.img of=myos.img skip=1 seek=1 bs=512 count=2879 # 在 bin 生成的镜像文件后补上空白，成为合适大小的软盘镜像，一共2880个扇区，略过第一个
```
- 用软盘启动系统
    - 将上述制作的软盘myos.img下载到windows
    - VMWare创建空的虚拟机
        - 文件 - 创建新的虚拟机 - 典型 - 稍后安装操作系统 - 其他(版本其他) - 一路next 完成
        - 虚拟机设置：去掉CD/DVD选项中"启动时连接" - 网络，选择"仅主机模式"，勾选"启动时连接" - 添加软盘驱动器，使用软盘映像，找到myos.img
        - 启动虚拟机
        - 显示 hello world, welcome to OS!
- [为什么主引导记录的内存地址是0x7C00?](http://www.ruanyifeng.com/blog/2015/09/0x7c00.html)



