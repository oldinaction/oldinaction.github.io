---
layout: "post"
title: "计算机底层知识"
date: "2020-06-16 20:50"
categories: [linux]
tags: [cpu, java]
---

## 书籍推荐

- 计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》
- 语言：C JAVA 《C程序设计语言》《C Primer Plus》
- 数据结构与算法：《Java数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》
- 操作系统：Linux内核源码解析、**Linux内核设计与实现**、30天自制操作系统
- 网络：机工《TCP/IP详解》卷一
- 编译原理：《编译原理》《编程语言实现模式》
- 数据库：SQLite源码、Derby(JDK自带数据库)

## 硬件基础知识

- 计算机的组成

    ![计算机的组成](/data/images/linux/计算机的组成.png)
- CPU制作
    - Intel cpu的制作过程：https://haokan.baidu.com/v?vid=11928468945249380709&pd=bjh&fr=bjhauthor&type=video
    - CPU是如何制作的(文字描述)：https://www.sohu.com/a/255397866_468626
- CPU的原理
    - 计算机需要解决的最根本问题：如何代表数字
    - 晶体管是如何工作的：https://haokan.baidu.com/v?vid=16026741635006191272&pd=bjh&fr=bjhauthor&type=video
    - 晶体管的工作原理：https://www.bilibili.com/video/av47388949?p=2
    - 发展过程
        - 硅 - 加入特殊元素 - P半导体 N半导体 - PN结 - 二极管 - 场效应晶体管 - 逻辑开关
        - 基于逻辑开关实现：与门、或门、非门(异或)，即基础逻辑电路
        - 再实现加法器、累加器、锁存器
        - 实现手动计算(通电一次，运行一次位运算)
        - 加入内存，实现自动运算(每次读取内存指令)。CPU的每个针脚可以读取一个0/1
    - CPU、内存、显卡等都是和主板进行连通
    - 总线指将每根线捆到一起的一根线
- 汇编语言（机器语言）的执行过程
    - 最早手工输入：纸带计算机，纸带上有孔，有孔没孔可代表1/0。一次一只虫子堵住了此孔，因此产生了BUG
    - 汇编语言的本质：机器语言(0101)的助记符(mod)，其实它就是机器语言
    - 计算机通电 -> CPU读取内存中程序（电信号输入）-> 时钟发生器不断震荡通断电(相关的如CPU频率) -> 推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期）-> 计算完成 -> 写回（电信号）-> 写给显卡输出（sout，或者图形）
    - c编译完后直接是机器码，CPU可直接执行，即编译执行；java编译后是二进制码(ByteCode)，执行时通过虚拟机解释成机器语言进行执行，即解释执行
- 量子计算机
    - 量子比特，可同时表示1和0
    - 潘建伟18bit量子纠缠：使用6个光子(有3个特点：路径、偏振、角动力)得到6*3=18个bit，每个bit有2中状态，相当于2^18中可能。经典计算机只能表示2^18中的一个数，而量子计算则能同时表示2^18个数

## CPU

### CPU的基本组成

- PC(Program Counter) 程序计数器(记录当前指令地址)
- Registers 寄存器，暂时存储CPU计算需要用到的数据，速度比内存快很多
    - Intel的寄存器如：AX/BX...(16位)，EAX/EBX...(32位)，RAX/RBX...(64位)
    - 64位机器(CPU)一般指寄存器一次性可以存储64位，ALU一次性也可读取64位
- ALU(Arithmetic & Logic Unit) 运算单元。如从寄存器的AX中读取2，BX中读取3，然后通过ALU进行运算得到5，并将5存储在如DX中，最好写会内存
- CU(Control Unit) 控制单元
- MMU(Memory Management Unit) 内存管理单元
- cache

### 超线程

- 一个ALU对应多个PC和Registers，即所谓的4核8线程，一个核如下

    ![超线程](/data/images/linux/超线程.png)

### 三级缓存和伪共享

- [三级缓存和伪共享](https://www.cnblogs.com/cyfonly/p/5800758.html)
- 按块读取
    - 从硬盘往内存读，从内存往缓存读都是按块读取的，从而提高效率。充分发挥总线、CPU针脚一次性读取更多数据的能力
- 三级缓存

    ![三级缓存](/data/images/linux/三级缓存.png)
    - CPU 缓存可以分为一级缓存(L1)，二级缓存(L2)，部分高端 CPU 还具有三级缓存(L3)
    - 每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小，所以 L1 缓存很小但很快。L1,L2只能被单独的 CPU 核使用，L3被单个插槽上的所有 CPU 核共享
    - 主存(常说的内存)则由全部插槽上的所有 CPU 核共享
- MESI 协议及 RFO 请求
    - MSI、MESI(M修改, E专有, S共享, I无效)、MOSI及Dragon Protocol等都是为了解决缓存一致性的协议
    - RFO(Request For Owner)请求，为MESI协议中需要将当前核心的某缓存行设置为E，将其他核心的该缓存行设置为I
- 伪共享 
    - 缓存系统中是以缓存行(cache line)为单位存储的，当多线程修改互相独立的变量时(发起的RFO请求会耗性能)，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享
- 解决伪共享
    - JDK7中很多采用缓存行填充(空间换时间)。Disruptor就是通过缓存行填充实现
    - JDK8开始可以使用@Contended注解(需加JVM参数：-XX:-RestrictContended)来避免伪共享
- 缓存行对齐
    - 对于有些特别敏感的数字，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存航对齐的编程方式

### WC合并写技术

- WC(Write Combining) 合并写
- 某些计算机在寄存器和三级缓存之间还有其他缓存，如与L1之间有Load Buffer、Store Buffer，与L2之间有WC Buffer，他们的空间很小，但是速度比三级缓存快
- 由于ALU速度太快，，所以在写入L1的同时写入一个WC Buffer，满了之后，再直接更新到L2(因为L1最终需要写入到L2)，大小一般是4个字节

### 乱序执行与防止指令重排

- 乱序执行
    - CPU执行命令时并不一定完全按照程序代码一行行的执行，而会进行指令重排，当CPU在进行读等待的同时执行指令，最终结果不会有影响。CPU乱序的是为了提高效率
    - as-if-serial：不管如何重排序，单线程执行的结果不变，看上去像是serial
    - 程序证明：[jvm/jmm/Disorder.java](https://preshing.com/20120515/memory-reordering-caught-in-the-act/)
- 禁止乱序
    - CPU层面
        - 使用内存屏障或锁总线
            - 如Intel底层使用内存屏障，对应原语(lfence读屏障 sfence写屏障 mfence混合屏障)。sfence表示：在某个sfence指令之前的写指令为A指令集，在其后的写指令为B指令集，此时A指令必须在B指令之前完成
            - 如Intel lock汇编指令，执行后会锁住内存子系统来确保执行顺序，甚至跨多个CPU
        - lock指令一般CPU都有，但是内存屏障可能部分品牌没有内存屏障原语支持，HotSpot直接使用了lock指令来防止指令重排
    - JVM层级
        - JSR(JVM规范)内存屏障(LL LS SL SS)
            - LoadLoad(LL)：对于Load1;LoadLoad;Load2;这样的指令，Load2即之后读操作要在Load1读操作之后完成。其他如LoadStore类似
        - volatile实现细节
            - StoreStoreBarrier;volatile写操作;StoreLoadBarrier;
            - LoadLoadBarrier;volatile读操作;LoadStoreBarrier;
        - volatile一个对象时，只要对象任何属性有变化则会有禁止指令重排
- JVM规定重排序必须遵守8个hanppens-before原则
- 案例：DCL单例(双重检查单例，Double Check Lock)必须配合volatile，此时volatile即达到了指令重排的作用

### NUMA

- UMA(Uniform Memory Access)：多个CPU通过一个总线访问同一个内存。但缺点是CPU增加导致资源抢占，工业测试证明4颗效果最好
- NUMA(Non Uniform Memory Access)：非同一内存访问
- ZGC - NUMA aware：分配内存会优先分配该线程所在CPU的最近内存

![UMA-NUMA](/data/images/linux/UMA-NUMA.png)

## 启动

- 通电 -> bios/uefi 工作 -> 自检 -> 到硬盘固定位置加载bootloader -> 读取可配置信息 -> CMOS

![电脑启动](/data/images/linux/电脑启动.png)

## OS

### 内核

- kernel内核作用：负责调度CPU，管理内存、文件系统、进度调度、设备驱动等
- 内核分类
    - 宏内核：PC、phone
    - 微内核：弹性部署、5G、IoT。用户请求某个内核，这个内核可能无法处理，他会请求其他内核进行处理(也可能联网请求，如控制冰箱内核、电视内核等)
    - 外核：为应用定制操作系统，科研中(多租户 request-based GC JVM)
- 内核态与用户态
    - cpu分不同的指令级别：0 1 2 3
    - linux内核跑在ring 0级，用户程序跑在ring 3，对于系统的关键访问(如访问硬件)，需要经过kernel的同意，保证系统健壮性
    - 内核执行的操作：200多个系统调用，sendfile read write pthread fork等
    - 站在OS老大的角度，JVM就是个普通程序

### 进程/线程/纤程

- 进程和线程区别
    - 进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径
    - 专业：进程是OS分配资源的基本单位，线程是执行调度的基本单位。分配资源最重要的是：独立的内存空间，线程调度执行（线程共享进程的内存空间，没有自己独立的内存空间）
- 纤程
    - 用户态的线程，线程中的线程，切换和调度不需要经过OS

优势：1：占有资源很少 OS : 线程1M Fiber：4K 2：切换比较简单 3：启动很多个10W+

目前2020 3 22支持内置纤程的语言：Kotlin Scala Go Python(lib)... Java? （open jdk : loom）

