---
layout: "post"
title: "加密解密"
date: "2018-10-23 16:07"
categories: extend
tags: [网络安全]
---

## SSL/TLS

> 参考：https://segmentfault.com/a/1190000009002353#articleHeader5

### 介绍

- `SSL`(Secure Sockets Layer)和`TLS`(Transport Layer Security)的关系就像windows XP和windows 7的关系，升级后改了个名字而已
- 最初的SSL只支持TCP，现在已经可以支持UDP
- `HTTPS=HTTP+TLS`、`FTPS=FTP+TLS`。SSH和SSL/TLS是两个不同的协议，SSH并不依赖于SSL/TLS

### 加密相关的概念

- `对称加密`
    - 这是加密文件常用的方式，加密的时候输入一个密码，解密的时候也用这个密码，加密和解密都用同一个密码，所以叫对称加密。常见的算法有[AES](#AES)、`3DES`
- `非对称加密`
    - 非对称加密有两个不一样的密码，一个叫私钥，另一个叫公钥，用其中一个加密的数据只能用另一个密码解开，用自己的都解不了，也就是说用公钥加密的数据只能由私钥解开，反之亦然
    - 私钥一般自己保存，而公钥是公开的，同等加密强度下，非对称加密算法的速度比不上对称加密算法的速度，所以非对称加密一般用于数字签名和密码(对称加密算法的密码)的交换。常见的算法有`RSA`、`DSA`、`ECC`
- `摘要算法`
    - 摘要算法不是用来加密的，其输出长度固定，相当于计算数据的`指纹`，**主要用来做数据校验，验证数据的完整性和正确性**。常见的算法有`MD5`、`SHA1`、`SHA256`、`CRC`
- `数字签名`
    - 数字签名就是 **"非对称加密+摘要算法"**，其目的不是为了加密，而是用来防止他人篡改数据
    - 其核心思想是
        - 比如A要给B发送数据，A先用摘要算法得到数据的指纹，然后用A的私钥加密指纹，加密后的指纹就是A的签名，B收到数据和A的签名后，也用同样的摘要算法计算指纹，然后用A公开的公钥解密签名，比较两个指纹，如果相同，说明数据没有被篡改，确实是A发过来的数据
        - 假设C想改A发给B的数据来欺骗B，因为篡改数据后指纹会变，要想跟A的签名里面的指纹一致，就得改签名，但由于没有A的私钥，所以改不了，如果C用自己的私钥生成一个新的签名，B收到数据后用A的公钥根本就解不开

### 证书概念

- `私钥`：私钥就是一个算法名称加上密码串，自己保存，从不给任何人看
- `公钥`：公钥也是一个算法名称加上密码串，一般不会单独给别人，而是嵌在证书里面一起给别人
- `CA`：专门用自己的私钥给别人进行签名的单位或者机构
- `申请签名文件`：在公钥的基础上加上一些申请人的属性信息，比如我是谁，来自哪里，名字叫什么，证书适用于什么场景等的信息，然后带上进行的签名，发给CA(私下安全的方式发送)，带上自己签名的目的是为了防止别人篡改文件
- `证书文件`：**证书由公钥加上描述信息，然后经过私钥签名之后得到**。一般都是一个人的私钥给另一个人(一般是CA)的公钥签名；如果是自己的私钥给自己的公钥签名，就叫`自签名`
- 签名过程
    - CA收到申请文件后，会走核实流程，确保申请人确实是证书中描述的申请人，防止别人冒充申请者申请证书，核实通过后，会用CA的私钥对申请文件进行签名
    - 签名后的证书包含：申请者的基本信息，CA的基本信息，证书的使用年限，申请人的公钥，签名用到的摘要算法，CA的签名
    - 签完名之后，证书就可以用了
- 证书找谁签名合适
    - 别人认不认你的证书要看上面签的是谁的名，所以签名一定要找权威的人来签，否则别人不认，哪谁是权威的人呢？那就是CA，哪些CA是受人相信的呢？那就要看软件的配置，配置相信谁就相信谁，比如浏览器、操作系统等，安装好了之后里面就内置了很多信任的CA的证书，只要是那些CA签名的证书，操作系统/浏览器都会相信。而自己写的程序，可以由你自己指定信任的CA(即使用自签名证书)；浏览器使用自签名证书时必须将CA证书添加为信任的证书，否则会有警告
- 那么CA的证书又是谁签的名呢？一般CA都是分级的，CA的证书都是由上一级的CA来签名，而最上一级CA的证书是自签名证书
- 以浏览器为例，说明证书的验证过程
    - 在TLS握手的过程中，浏览器得到了网站的证书
    - 打开证书，查看是哪个CA签名的这个证书
    - 在自己信任的CA库中，找相应CA的证书
    - 用CA证书里面的公钥解密网站证书上的签名，取出网站证书的校验码(指纹)，然后用同样的算法(比如sha256)算出出网站证书的校验码，如果校验码和签名中的校验码对的上，说明这个证书是合法的，且没被人篡改过
    - 读出里面的CN，对于网站的证书，里面一般包含的是域名
    - 检查里面的域名和自己访问网站的域名对不对的上，对的上的话，就说明这个证书确实是颁发给这个网站的
    - 到此为止检查通过
    - 如果浏览器发现证书有问题，一般是证书里面的签名者不是浏览器认为值得信任的CA，浏览器就会给出警告页面，这时候需要谨慎，有可能证书被掉包了。如访问12306网站，由于12306的证书是自己签的名，并且浏览器不认为12306是受信的CA，所以就会给警告，但是一旦把12306的根证书安装到了你的浏览器中，那么下次就不会警告了，因为配置了浏览器让它相信12306是一个受信的CA

### TLS握手过程

```bash
+--------+                                                                                                +--------+
|        |   1. ClientHello(发送TLS版本及密码套件/算法)                                                     |        |
|        |----------------------------------------------------------------------------------------------->|        |
|        |                                                                                                |        |
|        |   2. ServerHello(确认TLS版本及密码套件)                                                          |        |
|        |   3. Certificate(发送服务器证书)                                                                |        |
|        |   4. ServerKeyExchange (optional. 如DHE_RSA非对称加密算法需要发送一个消息给客户端生成premaster)    |        |
|        |   5. CertificateRequest (optional. 如使用U盾访问银行网站需要)                                    |        |
|        |   6. ServerHelloDone                                                                           |        |
|        |<-----------------------------------------------------------------------------------------------|        |
| Client |                                                                                                | Server |
|        |   7. Certificate (optional. 发送客户端证书给服务器验证)                                          |        |
|        |   8. ClientKeyExchange(生成premaster, RSA可直接生成, DHE_RSA需4.ServerKeyExchange中的消息)       |        |
|        |   9. CertificateVerify (optional. 配合7.Certificate, 验证客户端证书对应的私钥确实是在客户端手里)   |        |
|        |  10. Finished                                                                                  |        |
|        |----------------------------------------------------------------------------------------------->|        |
|        |                                                                                                |        |
|        |  11. Finished                                                                                  |        |
|        |<-----------------------------------------------------------------------------------------------|        |
+--------+                                                                                                +--------+
```

### 证书生成示例

```bash
mkdir cert && cd cert
## CA机构：生成CA的私钥和证书(openssl参数说明见下文)
# 生成的过程中会要求填一些信息，除了`Common Name`(CN)要取一个容易区分的名字之外，如网站域名(如ca.com)，其它都可以随便填写
openssl req -newkey rsa:2048 -nodes -sha256 -keyout ca.key -x509 -days 365 -out ca.crt

## 普通程序商：生成私钥(aezo.key)和证书签名申请文件(aezo.csr)
# 这里和上面的区别就是这里是-new生成一个证书签名申请文件，而上面用-x509生成一个自签名文件，其它的参数意义都一样，如网站域名(如aezo.cn)
# 可知CA的私钥和普通人的私钥没什么区别，唯一的区别就是CA用私钥自签名的证书受别人相信，而普通人的自签名证书别人不信，所以需要CA来给证书签名
openssl req -newkey rsa:2048 -nodes -sha256 -keyout aezo.key -new -out aezo.csr

## 使用CA的私钥对申请文件进行签名(从而得到证书文件 aezo.crt)
# 由于需要往生成的证书里写入签名者的信息，所以这里需要ca.crt；ca.key里面只有私钥的信息
openssl x509 -CA ca.crt -CAkey ca.key -in aezo.csr -req -days 365 -out aezo.crt -CAcreateserial -sha256

## 查看证书内容
# 上面生成的证书文件格式都是pem格式，需通过下列命令查看
openssl x509 -text -noout -in ca.crt
openssl x509 -text -noout -in aezo.crt # 可以看到Issuer对应的是ca.com(CA签名信息)
```
- openssl参数说明
    - `-newkey rsa:2048`：生成一个长度为2048的采用RSA算法的私钥
    - `-nodes`：这个私钥在本地存储的时候不加密(可以通过其它参数来加密私钥，这样存储比较安全)
    - `-sha256`：生成的证书里面使用sha256作为摘要算法
    - `-keyout ca.key`：输出私钥到`ca.key`(或者取名`key.pem`)
    - `-x509`：证书文件格式为`x509`，目前TLS默认只支持这种格式的证书
    - `-days 365`：证书有效期1年
    - `-out ca.crt`：生成的证书文件保存到`ca.crt`(或者取名`cert.pem`)

## AES

### 简介

- 密码学中的高级加密标准 (Advanced Encryption Standard，`AES`)，又称高级加密标准Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的`DES`，已经被多方分析且广为全世界所使用。高级加密标准已然成为对称密钥加密中最流行的算法之一。该算法为比利时密码学家Joan Daemen和VincentRijmen所设计，结合两位作者的名字，以`Rijndael`命名之 [1]

### java实现

#### 基于`AES/CBC/PKCS5Padding`或`AES/CBC/PKCS7Padding`的256位(32字节)秘钥进行加密解密

- `AES/CBC/PKCS5Padding`和`AES/CBC/PKCS7Padding`效果一样，**建议使用`AES/CBC/PKCS5Padding`**
- java默认不支持PKCS7，如果非要指定PKCS7需要借助`BouncyCastle`类
    
    ```xml
    <!-- AES/CBC/PKCS7Padding 加解密 -->
    <!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on -->
    <dependency>
        <groupId>org.bouncycastle</groupId>
        <artifactId>bcprov-jdk15on</artifactId>
        <version>1.55</version>
    </dependency>
    ```
- **java的jdk不支持256位(32字节)AES密钥，需要安装扩展包。**
    - 如果是128位(16字节)则无需安装扩展包
    - [oracle官方下载](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)。下载之后得到`local_policy.jar`，`US_export_policy.jar`两个jar包，把这两个jar包放到`jre/lib/security`目录下替换原来的两个jar包即可
- 示例(基于jdk1.8测试)

```java
import org.apache.tomcat.util.codec.binary.Base64;
import sun.misc.BASE64Decoder;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.spec.AlgorithmParameterSpec;

public class AesU {
    public static void main(String args[]) throws Exception {
        System.out.println(encrypt("aezo.cn")); // U7fKj3r+hCydAkG20p0ZOw==
        System.out.println(decrypt("U7fKj3r+hCydAkG20p0ZOw==")); // aezo.cn
        System.out.println(decrypt("7gerc9kKbi7d7/rskLzq/H/+9Zb9lqa/XhiWkgeaThw=")); // aezo.cn
        System.out.println(encrypt2("aezo.cn")); // 7gerc9kKbi7d7/rskLzq/H/+9Zb9lqa/XhiWkgeaThw=
        System.out.println(decrypt2("U7fKj3r+hCydAkG20p0ZOw==")); // aezo.cn
    }

    private static final String CHARSET_NAME = "UTF-8";
    private static final String AES_NAME = "AES";
    private static final String ALGORITHM = "AES/CBC/PKCS5Padding"; // "AES/CBC/PKCS7Padding"
    private static final String KEY = "aabcw334^#^&#*^$W1233qwreqwr12  "; // 秘钥 32字节
    private static final String IV = "abc8j*Ghg7!rNI84"; // 偏移 16字节

    // static {
    //     // 使用"AES/CBC/PKCS7Padding"时需要开启
    //     Security.addProvider(new BouncyCastleProvider());
    // }

    /**
     * 加密
     * @param content
     * @return
     * @throws Exception
     */
    public static String encrypt(String content) throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(CHARSET_NAME), AES_NAME);
        AlgorithmParameterSpec paramSpec = new IvParameterSpec(IV.getBytes());
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, paramSpec);
        byte[] result = cipher.doFinal(content.getBytes(CHARSET_NAME));
        return Base64.encodeBase64String(result);
    }

    /**
     * 解密
     * @param content
     * @return
     * @throws Exception
     */
    public static String decrypt(String content)  throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(CHARSET_NAME), AES_NAME);
        AlgorithmParameterSpec paramSpec = new IvParameterSpec(IV.getBytes());
        cipher.init(Cipher.DECRYPT_MODE, keySpec, paramSpec);
        return new String(cipher.doFinal(Base64.decodeBase64(content)), CHARSET_NAME);
    }

    /**
     * 加密
     * @param content
     * @return
     * @throws Exception
     */
    public static String encrypt2(String content) throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        int blockSize = cipher.getBlockSize();

        byte[] dataBytes = content.getBytes();
        int plaintextLength = dataBytes.length;
        if (plaintextLength % blockSize != 0) {
            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));
        }

        byte[] plaintext = new byte[plaintextLength];
        System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);

        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());

        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
        byte[] encrypted = cipher.doFinal(plaintext);

        return new sun.misc.BASE64Encoder().encode(encrypted);
    }

    /**
     * 解密
     * @param content
     * @return
     * @throws Exception
     */
    public static String decrypt2(String content) throws Exception {
        byte[] encrypted = new BASE64Decoder().decodeBuffer(content);

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());

        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

        byte[] original = cipher.doFinal(encrypted);
        return new String(original);
    }

}
```


---

参考文章

[^1]: https://my.oschina.net/Jacker/blog/86383 (AES加密CBC模式兼容互通四种编程语言平台PHP、Javascript、Java、C#)
[^2]: https://www.cnblogs.com/cocoajin/p/6164790.html (java aes_cbc_256 加密解密)


