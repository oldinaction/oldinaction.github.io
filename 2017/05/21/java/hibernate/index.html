<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="db,"><link rel="alternate" href="/atom.xml" title="Smalle's Blog | AEZOCN" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="介绍 ORM框架(对象关系映射) JDBC操作数据库很繁琐 Sql语句编写并不是面向对象的 可以在对象和关系表之间建立关联来简化编程 0/R Mapping 简化编程 0/R Mapping跨越数据库平台   ssh流程/hibernate流程(视频01、02)、hibernate原理(视频06(反射)、hiberbate内部大多直接以生成二进制码的形式实现) O/RMapping编程模型（映射接"><meta name="keywords" content="db"><meta property="og:type" content="article"><meta property="og:title" content="Hibernate"><meta property="og:url" content="http://blog.aezo.cn/2017/05/21/java/hibernate/index.html"><meta property="og:site_name" content="Smalle&#39;s Blog | AEZOCN"><meta property="og:description" content="介绍 ORM框架(对象关系映射) JDBC操作数据库很繁琐 Sql语句编写并不是面向对象的 可以在对象和关系表之间建立关联来简化编程 0/R Mapping 简化编程 0/R Mapping跨越数据库平台   ssh流程/hibernate流程(视频01、02)、hibernate原理(视频06(反射)、hiberbate内部大多直接以生成二进制码的形式实现) O/RMapping编程模型（映射接"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2022-07-18T10:54:56.014Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Hibernate"><meta name="twitter:description" content="介绍 ORM框架(对象关系映射) JDBC操作数据库很繁琐 Sql语句编写并不是面向对象的 可以在对象和关系表之间建立关联来简化编程 0/R Mapping 简化编程 0/R Mapping跨越数据库平台   ssh流程/hibernate流程(视频01、02)、hibernate原理(视频06(反射)、hiberbate内部大多直接以生成二进制码的形式实现) O/RMapping编程模型（映射接"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"BWD6R9FA4K",apiKey:"3330f3cbaa099dfc30395de5f5b20151",indexName:"blog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}}}</script><link rel="canonical" href="http://blog.aezo.cn/2017/05/21/java/hibernate/"><title>Hibernate | Smalle's Blog | AEZOCN</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=cnzz_stat_icon_1276691827&web_id=cnzz_stat_icon_1276691827" language="JavaScript"></script></div></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Smalle's Blog | AEZOCN</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Better Code, Better Life</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2017/05/21/java/hibernate/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="smalle"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Smalle's Blog | AEZOCN"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Hibernate</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T15:39:00+08:00">2017-05-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><div></div><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>ORM框架(对象关系映射)<ul><li>JDBC操作数据库很繁琐</li><li>Sql语句编写并不是面向对象的</li><li>可以在对象和关系表之间建立关联来简化编程</li><li>0/R Mapping 简化编程</li><li>0/R Mapping跨越数据库平台</li></ul></li><li>ssh流程/hibernate流程(<strong>视频01、02</strong>)、hibernate原理(<strong>视频06(反射)、hiberbate内部大多直接以生成二进制码的形式实现</strong>)</li><li>O/RMapping编程模型（<strong>映射接口使用jpa的，编程接口使用hibernate的</strong>）<ul><li>映射模型<ul><li>jpa annotation(java提供的annotation配置–常用)</li><li>hibernate annotation extension(Hibernate扩展的annotation配置–较少用)</li><li>hibernate xml(Hibernate的xml配置方式–常用)</li><li>jpa xml(java提供的xml配置–较少用)</li></ul></li><li>编程接口（做CRUD）<ul><li>Jpa(不常用)</li><li>hibernate(现在用)</li></ul></li><li>数据査询语言<ul><li>HQL(常用)</li><li>EJBQL(JPQL)：是HQL的一个子集. EJB必须用在容器(application server)中，而hibernate可以在j2se中使用</li></ul></li></ul></li><li>JPA：Java Persistence API. JPA是接口/规范，hibernate是其实现. JPA是hibernate的作者基于hibernate抽象出来的. JPA是EJB3.0的的一部分</li><li>本文档基于hibernate3.3.2</li><li>资源下载：<a href="https://sourceforge.net/projects/hibernate/files/hibernate3/3.3.2.GA/hibernate-distribution-3.3.2.GA-dist.tar.gz/download" target="_blank" rel="noopener">hibernate-distribution-3.3.2.GA</a>、<a href="https://sourceforge.net/projects/hibernate/files/hibernate-annotations/3.4.0.GA/hibernate-annotations-3.4.0.GA.zip/download" target="_blank" rel="noopener">hibernate-annotations-3.4.0.GA</a>、<a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12/1.5.8" target="_blank" rel="noopener">slf4jl.5.8</a>、<a href="https://mvnrepository.com/artifact/log4j/log4j/1.2.15" target="_blank" rel="noopener">log4j-1.2.15</a></li><li><p>jar包如下：(日志使用的log4j)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">antlr-2.7.6.jar</span><br><span class="line">commons-collections-3.1.jar</span><br><span class="line">dom4j-1.6.1.jar</span><br><span class="line">ejb3-persistence.jar</span><br><span class="line">hibernate3.jar</span><br><span class="line">hibernate-annotations.jar</span><br><span class="line">hibernate-commons-annotations.jar</span><br><span class="line">javassist-3.9.0.GA.jar</span><br><span class="line">jta-1.1.jar</span><br><span class="line">junit-4.7.jar</span><br><span class="line">log4j-1.2.15.jar</span><br><span class="line">mysql-connector-java-5.1.26-bin.jar</span><br><span class="line">slf4j-api-1.5.8.jar</span><br><span class="line">slf4j-log4j12-1.5.8.jar</span><br></pre></td></tr></table></figure><ul><li><code>slf4j-api</code>是一个日志接口，其实现可以为<code>log4j</code>(需要对应的适配器进行接口转换，如<code>slf4j-log4j12-1.5.8.jar</code>)、<code>slf nodep</code>、<code>jdk logging api</code>、<code>apache commons-logging</code></li></ul></li></ul><h2 id="Springboot对hibernate的默认支持-JPA-2017-07-23"><a href="#Springboot对hibernate的默认支持-JPA-2017-07-23" class="headerlink" title="Springboot对hibernate的默认支持(JPA) 2017-07-23"></a>Springboot对hibernate的默认支持(JPA) 2017-07-23</h2><blockquote><p><a href="http://www.cnblogs.com/rulian/tag/jpa/" target="_blank" rel="noopener">Spring Data JPA博文</a></p><ul><li>继承接口查询(JpaRepository/JpaSpecificationExecutor等)：<a href="http://www.cnblogs.com/rulian/p/6557471.html" target="_blank" rel="noopener">http://www.cnblogs.com/rulian/p/6557471.html</a></li><li>方法定义规则查询：<a href="http://www.cnblogs.com/rulian/p/6434631.html" target="_blank" rel="noopener">http://www.cnblogs.com/rulian/p/6434631.html</a></li><li>Example实例查询：<a href="http://www.cnblogs.com/rulian/p/6533109.html" target="_blank" rel="noopener">http://www.cnblogs.com/rulian/p/6533109.html</a></li></ul></blockquote><ul><li><p>引入数据库和jpa</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jpa是ORM框架的API(基于hibernate完成), jdbc是java操作数据库的API(执行sql语句)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数据库添加配置</p></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line">    <span class="comment"># 打印sql执行语句, 查询和建表</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line">      <span class="comment"># 自动执行ddl语句(create/create-drop/update，基于Model注解执行表结构创建)</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line">        <span class="comment"># 格式化打印语句</span></span><br><span class="line"><span class="attr">        format_sql:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 懒加载配置</span></span><br><span class="line"><span class="attr">        enable_lazy_load_no_trans:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 增加此配置即可通过@Autowired获取到SessionFactory</span></span><br><span class="line"><span class="attr">        current_session_context_class:</span> <span class="string">org.springframework.orm.hibernate5.SpringSessionContext</span></span><br></pre></td></tr></table></figure><ul><li><p><code>User.java</code>实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span></span><br><span class="line">	<span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>) <span class="comment">// 不能为空，不进行更新</span></span><br><span class="line">	<span class="keyword">private</span> Long username;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long groupId;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Generated</span>(GenerationTime.INSERT)</span><br><span class="line">	<span class="meta">@Column</span>(columnDefinition=<span class="string">" BIT default 1 "</span>) <span class="comment">// 默认插入1(就算new User的时候设置成0最终保存的仍然是1)。注意：必须是Boolean的包装类型才可以</span></span><br><span class="line">	<span class="keyword">private</span> Boolean yesValid;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Generated</span>(GenerationTime.INSERT)</span><br><span class="line">	<span class="meta">@Column</span>(insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>, columnDefinition=<span class="string">"timestamp default current_timestamp comment '加入时间'"</span>)</span><br><span class="line">	<span class="keyword">private</span> Timestamp createTime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getter/setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>UserDao.java</code>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了JpaRepository(JpaRepository又继承了CrudRepository已经定义好了基本增删查改相关方法)</span></span><br><span class="line">   <span class="comment">// getOne是"Returns a reference" findOne比getOne更通用。推荐使用findOne（CrudRepository中定义的通用方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClassDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserClass</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// spring data 根据属性名和查询关键字自动生成查询方法(spring data会自动实现)</span></span><br><span class="line">	<span class="function">UserClass <span class="title">findByClassName</span><span class="params">(String className)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">List&lt;UserClass&gt; <span class="title">findByClassNameIn</span><span class="params">(List&lt;String&gt; classNames)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>UserController.java</code>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/users"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 前台传一个类似的user对象，会把此对象做作为条件进行查询</span></span><br><span class="line">       Example&lt;User&gt; example = Example.of(user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行模糊匹配</span></span><br><span class="line">	<span class="comment">// ExampleMatcher matcher = ExampleMatcher.matching().withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);</span></span><br><span class="line">	<span class="comment">// Example&lt;User&gt; example = Example.of(user, matcher);</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> userDao.findAll(example);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Query</code>查询示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao定义的查询语句. org.springframework.data.jpa.repository.Query</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select u.classId, u.sex, count(u.classId) as count from User u "</span> +</span><br><span class="line">        <span class="string">"   where u.password = :password "</span> +</span><br><span class="line">        <span class="string">"   group by u.classId, u.sex"</span>)</span><br><span class="line">List&lt;Object[]&gt; countUser(<span class="meta">@Param</span>(<span class="string">"password"</span>) String password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生sql</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"select u.* from user u, user_class uc where uc.class_id = u.class_id and uc.class_name = 'one'"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">List&lt;Object[]&gt; findUsers();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @Query自定义sql语句. http://127.0.0.1:9526/api/user-query</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user-query"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    result.put(<span class="string">"count"</span>, userDao.countUser(<span class="string">"123456"</span>));</span><br><span class="line">    result.put(<span class="string">"users"</span>, userDao.findUsers());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    count: [</span><br><span class="line">        [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    users: [</span><br><span class="line">        [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="string">"smalle"</span>,</span><br><span class="line">            <span class="string">"123456"</span>,</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="string">"aezo"</span>,</span><br><span class="line">            <span class="string">"123456"</span>,</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Pageable</code>分页查询：Pageable里面常用参数<code>page</code>(页码, 0代表第一页)、<code>size</code>(页长)、<code>order</code>(排序规则) <a href="[hibernate查询分页](http://www.cnblogs.com/softidea/p/6287788.html)">^1</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询UserClass信息, 并获取子表User的前5条数据. http://127.0.0.1:9526/api/classes?className=one</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/classes"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">findClasses</span><span class="params">(UserClass userClass)</span> </span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 前台传一个类似的UserClass对象，会把此对象做作为条件进行查询</span></span><br><span class="line">       Example&lt;UserClass&gt; example = Example.of(userClass);</span><br><span class="line">       result.put(<span class="string">"userClass"</span>, userClassDao.findAll(example));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 分页获取User数据：如果使用classes.getUsers()获取则需要写实体对应关系(@OneToMany), 且会产生外键. 此时单表查询不需关联关系</span></span><br><span class="line">       Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>, <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"id"</span>)); <span class="comment">// 获取第1页, 每页显示5条, 按照id排序</span></span><br><span class="line">       result.put(<span class="string">"users"</span>, userDao.findAll(pageable));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页(page为页码, 0代表第1页; size代表页长). http://127.0.0.1:9526/api/users-page?page=0</span></span><br><span class="line"><span class="comment">// 排序：`?sort=firstname&amp;sort=lastname,desc` 表示在按firstname正序排列基础上按lastname倒序排列</span></span><br><span class="line">   <span class="comment">// org.springframework.data.domain.Pageable、org.springframework.data.domain.Example</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/users-page"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">findUsersPage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           @RequestParam(value = <span class="string">"username"</span>, defaultValue = <span class="string">"smalle"</span>)</span> String username,</span></span><br><span class="line"><span class="function">           Pageable pageable) </span>&#123;</span><br><span class="line">       <span class="comment">// 前台传一个类似的user对象，会把此对象做作为条件进行查询</span></span><br><span class="line">       Example&lt;User&gt; example = Example.of(<span class="keyword">new</span> User(username));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> userDao.findAll(example, pageable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>查询UserClass信息返回数据如下(已经美化去除引号)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	userClass: [</span><br><span class="line">		&#123;</span><br><span class="line">			classId: <span class="number">1</span>,</span><br><span class="line">			className: <span class="string">"one"</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	users: &#123;</span><br><span class="line">		content: [</span><br><span class="line">			&#123;</span><br><span class="line">				id: <span class="number">2</span>,</span><br><span class="line">				classId: <span class="number">1</span>,</span><br><span class="line">				username: <span class="string">"aezo"</span>,</span><br><span class="line">				password: <span class="string">"123456"</span>,</span><br><span class="line">				sex: <span class="number">1</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				id: <span class="number">1</span>,</span><br><span class="line">				classId: <span class="number">1</span>,</span><br><span class="line">				username: <span class="string">"smalle"</span>,</span><br><span class="line">				password: <span class="string">"123456"</span>,</span><br><span class="line">				sex: <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		totalElements: <span class="number">2</span>,</span><br><span class="line">		totalPages: <span class="number">1</span>,</span><br><span class="line">		last: <span class="literal">true</span>,</span><br><span class="line">		number: <span class="number">0</span>,</span><br><span class="line">		size: <span class="number">5</span>,</span><br><span class="line">		first: <span class="literal">true</span>,</span><br><span class="line">		numberOfElements: <span class="number">2</span>,</span><br><span class="line">		sort: [</span><br><span class="line">			&#123;</span><br><span class="line">				direction: <span class="string">"DESC"</span>,</span><br><span class="line">				property: <span class="string">"id"</span>,</span><br><span class="line">				ignoreCase: <span class="literal">false</span>,</span><br><span class="line">				nullHandling: <span class="string">"NATIVE"</span>,</span><br><span class="line">				ascending: <span class="literal">false</span>,</span><br><span class="line">				descending: <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><blockquote><p><code>test/cn.aezo.hibernate.hello.StudentTest</code></p></blockquote><ol><li><p>配置<code>hibernate.cfg.xml</code>(配置数据源、加入)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- hibernate使用xml配置数据库映射的helloworld案例。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"cn.aezo.hibernate.hello"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Student"</span> <span class="attr">table</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span><span class="comment">&lt;!-- 定义id自动生成器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 当使用联合主键时的配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 因为使用UTF-8编码是主键长度不能超过256个字节，而默认id长度是int(11),name长度是varchar(255)，则超出长度，故此处应该定义长度 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;composite-id name="pk" class="cn.aezo.hibernate.model.StudentPK"&gt;</span></span><br><span class="line"><span class="comment">        	&lt;key-property name="id"&gt;&lt;/key-property&gt;</span></span><br><span class="line"><span class="comment">        	&lt;key-property name="name" length="50"&gt;&lt;/key-property&gt;</span></span><br><span class="line"><span class="comment">        &lt;/composite-id&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Student的映射关系(Student.hbm.xml，需要放在对应类的同级目录)，并将其加入hibernate.cfg.xml中(<code>&lt;mapping resource=&quot;cn/aezo/hibernate/hello/Student.hbm.xml&quot;/&gt;</code>)</p></li></ol><h3 id="Annotation注解-常用"><a href="#Annotation注解-常用" class="headerlink" title="Annotation注解 (常用)"></a>Annotation注解 (常用)</h3><blockquote><p><code>test/cn.aezo.hibernate.hello.TeacherTest</code></p></blockquote><ol><li>配置<code>hibernate.cfg.xml</code>(配置数据源、加入)</li><li>给Teacher加注解</li><li>将Teacher映射加入到hibernate.cfg.xml中(<code>&lt;mapping class=&quot;cn.aezo.hibernate.hello.Teacher&quot;/&gt;</code>)</li></ol><h2 id="hibernate-cfg-xml配置"><a href="#hibernate-cfg-xml配置" class="headerlink" title="hibernate.cfg.xml配置"></a>hibernate.cfg.xml配置</h2><ul><li>此配置文件需要放入在src目录</li><li><p>配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置链接数据信息，配置后不需要自己写连接代码Database connection settings --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hiber<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JDBC connection pool (use the built-in) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="connection.pool_size"&gt;1&lt;/property&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 方言,告诉hibernate使用的sql语言是mysql规定的 SQL dialect--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 通过getCurrentSession()获取此上下文的session，没有则自动创建。thread表示线程级别,jta用于分布式事物管理(不同的数据库服务器),使用时需要中间件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Disable the second-level cache  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache.provider_class"</span>&gt;</span>org.hibernate.cache.NoCacheProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 展示sql语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 展示sql语句是格式化一下，更加美观 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 自动生成建表语句：hibernate建表后的字段顺序并不是和model字段顺序一致(内部使用TreeMap保存) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 测试那个就映射那个，将其他映射先去掉防止干扰 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/aezo/hibernate/hello/Student.hbm.xml"</span>/&gt;</span><span class="comment">&lt;!-- 使用xml方式需要的映射格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"cn.aezo.hibernate.hello.Teacher"</span>/&gt;</span><span class="comment">&lt;!-- 使用annotation方式需要的映射格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="相关注解类"><a href="#相关注解类" class="headerlink" title="相关注解类"></a>相关注解类</h2><p><strong>注解要么写在字段上，要么写在get方法上，千万不能混合使用，否则会报：</strong> <code>Could not determine type for: java.util.List, at table</code></p><ul><li>注解应该导入jpa的注解，如<strong><code>javax.persistence.*</code></strong></li><li><p>类级别</p><ul><li><strong><code>@Entity</code></strong>: 注解实体类, 最终会和数据库的表对应. <strong>注解了之后需要将该类加到hibernate.cfg.xml的mapping中</strong></li><li><strong><code>@Table(name=&quot;_teacher&quot;)</code></strong> 当实体类的类名和对应的表名不一致时批注,此时对应表的实际名为_teacher</li><li><p><code>@IdClass(TeacherPK.class)</code> 定义联合主键的类</p><blockquote><p>如 <code>cn.aezo.hibernate.hello.Teacher</code></p></blockquote><ul><li><code>@EmbeddedId</code>/<code>@ Embeddable</code>也可以定义联合主键</li></ul></li><li><p>ID生成策略</p><ul><li>常用ID生成策略有native identity sequence uuid(xml配置)<ul><li><code>@SequenceGenerator</code> Id生成策略使用sequence</li><li><code>@TableGenerator</code> 用一张表存储所有表主键的当前值</li></ul></li><li>如果没有ID生成策略则所有的表使用同一个主键自增序列(HIBERNATE_SEQUENCE)</li><li><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID生成策略(可以定义在全局、表、字段上)</span></span><br><span class="line"><span class="comment">// allocationSize 此时表示步长</span></span><br><span class="line"><span class="meta">@SequenceGenerator</span>(name = <span class="string">"seq_test"</span>, sequenceName = <span class="string">"seq_test"</span>, allocationSize = <span class="number">1</span>)</span><br><span class="line"><span class="comment">// allocationSize表示内存中缓存数(每次启动应用会重新缓存此大小的主键)</span></span><br><span class="line"><span class="meta">@TableGenerator</span>(name = <span class="string">"tg"</span>, table = <span class="string">"sequence_value"</span>, pkColumnName = <span class="string">"name"</span>,</span><br><span class="line">            valueColumnName = <span class="string">"value"</span>, allocationSize = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联ID生成策略</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="comment">// 会自动创建sequence_value, 且将表名做为name存储到此表，value为当前序列值</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.TABLE, generator = <span class="string">"tg"</span>)</span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.SEQUENCE, generator = <span class="string">"seq_test"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>@BatchSize(size=5)</code> 发出sql语句时一次性取出5条数据</p></li></ul></li><li><p>字段/方法级别</p><ul><li><strong><code>@Id</code></strong> 主键</li><li><code>@Basic</code> 其他属性,可省略</li><li><strong><code>@GeneratedValue</code></strong> 批注后主键会自动生成值，默认使用id生成策略是AUTO。@GeneratedValue(strategy=GenerationType.AUTO)，其中(strategy=GenerationType.AUTO)可以省略，会自动根据mysql/oracle转换，相当于xml方式中的native</li><li><strong><code>@Column(name=&quot;_title&quot;)</code></strong> 当实际的字段名和类的属性名不一致时才需批注,此时表示对应的表中的字段实际名为_title。最好一致<ul><li><code>@Column(columnDefinition=&quot; BIT default 1 &quot;)</code> 设置默认值(BIT对应Boolean，其中的空格不能少)</li><li><code>@Column(columnDefinition=&quot;TEXT&quot;)</code> 设置字段类型(java中的String对应db中的TEXT). 存储长文本<ul><li>存储长文本建议使用TEXT：<code>TINYTEXT</code> 256bytes、<code>TEXT</code> 64kb、<code>MEDIUMTEXT</code> 16Mb、<code>LONGTEXT</code> 4GB (mysql)</li><li><code>CLOB</code>/<code>BLOB</code>以二进制存储，前台参数无法直接映射成类</li></ul></li></ul></li><li><code>@JoinColumn</code>、<code>@OneToMany</code>等见下文关系映射</li><li><code>@OrderBy(&quot;name ASC&quot;)</code> 排序</li><li><code>@Transient</code> 透明的. 表示此字段在更新时不保存到数据库中,即不参加持久化.这是annotation的写法,在xml中则不写此属性即可</li><li><code>@Temporal(value=TemporalType.DATE)</code> 表示相应日期类型只记录日期,最终表的字段类型是DATE。不写的话默认是记录日期和时间,字段类型是TIMESTAMP。此处可以省略”value=”。不常用</li><li><p><code>@Enumerated(EnumType.STRING)</code> 声明枚举类型。EnumType.STRING表示在表中生成的字段类型是varchar;EnumType.ORDINAL表示表中生成的字段类型是int，并且拿枚举的下表存储</p><blockquote><p>如 <code>test/cn.aezo.hibernate.hello.TeacherTest</code></p></blockquote></li></ul></li><li><p>annotation字段映射位置：可以在field上或者get方法上(建议)，如果写在field则破坏了面向对象的机制，写在get方法是public的，所有一般写在get方法上</p></li></ul><h2 id="核心开发接口"><a href="#核心开发接口" class="headerlink" title="核心开发接口"></a>核心开发接口</h2><ol><li><p>示例</p><blockquote><p>如 <code>test/cn.aezo.hibernate.coreapi.TeacherTest</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configuration cfg = Configuration().configure(); // xml可以使用</span></span><br><span class="line">AnnotationConfiguration acfg = <span class="keyword">new</span> AnnotationConfiguration().configure(); <span class="comment">// xml和Annotation都能使用</span></span><br><span class="line"></span><br><span class="line">SessionFactory　session = acfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">Session session = sf.getCurrentSession(); <span class="comment">//从上下文找(要在hibernate配置文件中配置session运行的上下文)，如果有直接用，如果没有重新创建。事务提交自动close，下次获取的就是新的session</span></span><br><span class="line"><span class="comment">// Session session =  sf.openSession(); //每次都是新的，需要close</span></span><br><span class="line"></span><br><span class="line">session.beginTransaction(); <span class="comment">//开始一个事物</span></span><br><span class="line"></span><br><span class="line">session.save(teacher1);</span><br><span class="line">Teacher1 teacher1 = (Teacher1)session.load(Teacher1.class, <span class="number">1</span>); <span class="comment">// 存在懒加载</span></span><br><span class="line"><span class="comment">// Teacher1 teacher1 = (Teacher1)session.get(Teacher1.class, 1); // 不存在懒加载</span></span><br><span class="line"></span><br><span class="line">session.getTransaction().commit(); <span class="comment">//提交事物</span></span><br><span class="line"><span class="comment">// session.close();</span></span><br><span class="line"></span><br><span class="line">System.out.println(teacher1.getName()); <span class="comment">// 懒加载时，此处会报错</span></span><br></pre></td></tr></table></figure></li><li><p>接口</p><ul><li><code>Configuration</code> / <code>AnnotationConfiguration</code>: 管理配置信息(hibernate.cfg.xml), 用来产生SessionFactory(使用buildSessionFactory方法产生Session)<ul><li>方法：<code>buildSessionFactory</code></li></ul></li><li><code>SessoinFactor</code>: 用来产生和管理Session, 通常情况下每个应用只需要一个SessionFactory(除非要访间多个数据库)<ul><li>方法：<code>getCurrentsession</code>(从上下文中获取，如果上下文中没有则创建一个新的。常在事物中使用，事物提交后此session则关闭)、<code>openSession</code>(每次都是新的session，需要close)</li><li>getCurrentsession的上下文配置：<code>&lt;property name=&quot;current_session_context_classs&quot;&gt;thread&lt;/property&gt;</code>(jta、thread常用 managed、custom.Class少用)<ul><li>上下文主要有thread和jta两种。thread依赖于数据库本身的，简称Connection事务，只针对一个数据库。jta从分布式界定事物</li><li><strong><code>jta</code>(全称java transaction api) java分布式事务管理（多数据库访问）, jta需要application server支持，由中间件提供（jboss、WebLogic等，tomcat不支持）</strong></li></ul></li></ul></li><li><code>Session</code>: 管理一个数据库的任务单元（简单说就是增 删 改 查）<ul><li>方法：<code>sava</code>、<code>delete</code>、<code>get</code>、<code>load</code>、<code>update</code>、<code>saveOrUpdate</code>、<code>clear</code>、<code>flush</code></li><li><strong>get与load的区别</strong><ul><li>不存在对应记录时表现不一样</li><li>load返回的是代理对象，等到真正用到对象的内容时才发出sql语句(懒加载的)</li><li>get直接从数据库加载，不会延迟</li><li><code>User3 user3 = (User3)session.get(User3.class, 1);</code>、<code>User3 user3 = (User3)session.load(User3.class, 1);</code></li></ul></li><li>update(视频32)<ul><li>用来更新detached对象，更新完成后转为persistent状态</li><li>update时默认会更新全部字段，更新部分字段的解决办法<ul><li>使用 HQL(EjBQL)(建议）</li><li>xml设定property标签的update属性，annotation设定@Column的updatable=false，不过这种方式很少用，因为不灵活</li><li>xml中使用dynamic-update。同一个session可以，跨session不行，不过可以用merge方法</li></ul></li></ul></li><li>clear：无论是load还是get,都会首先査找缓存（一级缓存)，如果没有才会去数据库査找。调用clear()方法可以强制清除session缓存</li><li>flush<ul><li>强制将内存(session缓存)与数据库同步. 默认情况下是session的事务提交(commit)时才同步!</li><li>session的FlushMode设置, 可以设定在什么时候同步缓存与数据库(很少用)</li></ul></li></ul></li></ul></li><li><p>三种对象状态(transient、persistent、detached)</p><ul><li>三种状态：<ul><li>transient：内存中一个对象，内存和缓存(session缓存)中都没有ID。刚new 对象之后</li><li>persistent：ID在内存、缓存、数据库中都有。save了之后</li><li>detached：ID在内存和数据库中有，在缓存中没有。事物提交后(session关闭)</li></ul></li><li>三种状态的区分关键在于有没有ID，ID在数据库中有没有，在内存中有没有，在session缓存中有没有</li></ul></li></ol><h2 id="关系映射-视频35-52"><a href="#关系映射-视频35-52" class="headerlink" title="关系映射 (视频35-52)"></a>关系映射 (视频35-52)</h2><p>一对一：<code>@0neTo0ne</code>、<code>@JoinColumn</code>；一对多/多对一：<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@JoinColumn</code>；多对多：<code>@ManyToMany</code>、<code>@JoinTable</code>（<strong>字段定义和set方法省略</strong>）</p><ol><li><p>一对一</p><ul><li><code>@0neTo0ne</code> 指定关系, <code>@JoinColumn</code> 用于指定外键名称, 省略该注解则使用默认的外键名称, <code>@JoinColumns</code> 联合主键使用, <code>@Embedded</code> 组件映射使用</li><li><p><strong>一对一单向外键关联</strong>(src/cn.aezo.hibernate.one2one_uni_fk)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Husband类的被约束表字段的get方法上加@0neTo0ne @JoinColumn. 最终会在Husband的表中生成外键</span></span><br><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"wifeId"</span>)<span class="comment">// 指定生成的数据库字段名，不写@JoinColumn则默认生成外键名为wife_id</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Wife <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Husband表会多出一个字段wifeId, 即为外键</strong></li><li><p>xml设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"cn.aezo.hibernate.one2one_uni_fk.Husband"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"wife"</span> <span class="attr">column</span>=<span class="string">"wifeId"</span> <span class="attr">unique</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>一对一双向外键关联</strong>(src/cn.aezo.hibernate.one2one_bi_fk, 视频37)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Husband1类</span></span><br><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"wife1Id"</span>)<span class="comment">//指定生成的数据库字段名，否则默认生成外键名为wife_id. 最终只会在Husband的表中生成外键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Wife1 <span class="title">getWife1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wife1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wife1类</span></span><br><span class="line"><span class="comment">// 此处表示Husband中对"getWife"中的wife字段设置的外键是主导，此处只是指明关系但是并不会在Wife1表中生成外键。双向关系必须指明</span></span><br><span class="line"><span class="comment">// 双向时这个地方也需要一个关联关系，但是Husband1中wife1已经指明了关联关系且有一个外键了，故不应该再在Wife1生成一个外键。mappedBy就表明此处参考(映射到)Husband1中的wife1字段</span></span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"wife1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Husband1 <span class="title">getHusband1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> husband1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>凡是双向关联，必设<code>mappedBy</code></strong></li><li><strong><code>一对一单向外键关联与一对一双向外键关联在数据库的表的格式是一样的,区别在于java程序中. 双向外键关联可通过Hibernate在两个类间互相调用彼此,而单向外键关联只能单方向调用.</code></strong></li></ul></li><li>一对一单向主键关联(<code>@OneToOne、@primaryKeyJoinColumn</code>)</li><li>一对一双向主键关联(<code>@OneToOne、@primaryKeyJoinColumn</code>)</li><li><p><strong>一对一的单向联合主键的外键关联</strong>(src/cn.aezo.hibernate.one2one_uni_fk_composite)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Husband2类(Wife2是一个联合主键类, name是只最终会在Husband2中生成的字段名即外键名, referencedColumnName指这个外键参考的字段)</span></span><br><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name=<span class="string">"wife2Id"</span>, referencedColumnName=<span class="string">"id"</span>),</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name=<span class="string">"wife2Name"</span>, referencedColumnName=<span class="string">"name"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Wife2 <span class="title">getWife2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wife2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件映射(src/cn.aezo.hibernate.component)</p><ul><li>一个对象是另外一个对象的一部分，java中有两个对象，但是保存在一张表中</li><li><code>@Embedded</code> 注解的字段表明该对象是从别的位置嵌入过来的,是不需要单独映射的表</li><li><code>@AttributeOverride</code> 注解需要写在getWife方法上, 可以重新指定生成的Wife类组件生成的字段名, 例如:Husband与Wife两个类中都有name字段,这样在生成表的时候会有冲突, 此时采用@AttributeOverride注解可以指定Wife类中的name属性对应新的字段名”wifename”</li><li>xml中使用 <code>&lt;component&gt;</code></li></ul></li></ul></li><li><p><strong>多对一、一对多</strong></p><ul><li>指当前类(写注解的类)相对于注解属性(对应的类)的关系</li><li><p>多对一单向关联：<code>@ManyToOne</code>(src/cn.aezo.hibernate.many2one_uni)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User类. 外键保存在User类中</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Group <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    cascade取值all,none,save-update,delete,对象间的级联操作,只对增删改起作用.</span></span><br><span class="line"><span class="comment">    在存储时User时,设置了cascade="all"会自动存储相应的t_group.而不用管user关联的对象(通常情况下会优先存储关联的对象,然后再存储user)</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"group"</span> <span class="attr">column</span>=<span class="string">"groupid"</span> <span class="attr">cascade</span>=<span class="string">"all"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>一对多单向关联：<code>@OneToMany</code>(src/cn.aezo.hibernate.one2many_uni)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group1类. 外键保存在User1类中</span></span><br><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"groupId"</span>)<span class="comment">// Hibernate默认将OneToMany理解为ManyToMany的特殊形式，如果不指定生成的外键列@JoinColumn(name="groupId")，则会默认生成多对多的关系,产生一张中间表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;User1&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"groupId"</span>/&gt;</span>指定生成外键字段的名字</span><br><span class="line">    <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"cn.aezo.hibernate.one2many_uni.User1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>一对多/多对一双向关联(src/cn.aezo.hibernate.one2many_many2one_bi)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User2类</span></span><br><span class="line"><span class="meta">@ManyToOne</span> <span class="comment">// 配置规则:一般以多的一端为主,先配置多的一端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Group2 <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group2类</span></span><br><span class="line"><span class="meta">@OneToMany</span>(mappedBy=<span class="string">"group"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;User2&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多对多(会生成中间表)</p><ul><li><code>@ManyToMany</code>、<code>@JoinTable</code></li><li><p>多对多单向外键关联(src/cn.aezo.hibernate.many2many_uni)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Teacher2类</span></span><br><span class="line"><span class="meta">@ManyToMany</span><span class="comment">// 多对多关联 Teacher是主的一方 Student是附属的一方</span></span><br><span class="line"><span class="meta">@JoinTable</span>(</span><br><span class="line">    joinColumns=&#123;<span class="meta">@JoinColumn</span>(name=<span class="string">"teacherId"</span>)&#125;,<span class="comment">//本类主键在中间表生成的对应字段名</span></span><br><span class="line">    inverseJoinColumns=&#123;<span class="meta">@JoinColumn</span>(name=<span class="string">"student2Id"</span>)&#125;<span class="comment">//对方类主键在中间表生成的对应字段名</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Student2&gt; <span class="title">getStudent2s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> student2s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多对多双向外键关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在Teacher这一端的students上配置</span><br><span class="line">@ManyToMany</span><br><span class="line">@JoinTable(</span><br><span class="line">    name=&quot;t_s&quot;,</span><br><span class="line">    joinColumns=&#123;@JoinColumn(name=&quot;teacher_id&quot;)&#125;,</span><br><span class="line">    inverseJoinColumns=&#123;@JoinColumn(name=&quot;student_id&quot;)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 在Student一端的teachers只需要配置</span><br><span class="line">@ManyToMany(mappedBy=&quot;students&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关联关系中的CRUD、Cascade(级联)、Fetch(test/cn.aezo.hibernate.one2many_many2one_bi_curd)</p><ul><li><p><strong>设定<code>cascade</code>以设定在持久化时对于关联对象的操作（CUD，R归Fetch管）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group3类</span></span><br><span class="line"><span class="meta">@OneToMany</span>(</span><br><span class="line">    mappedBy=<span class="string">"group"</span>,</span><br><span class="line">    cascade=&#123;CascadeType.ALL&#125;<span class="comment">//cascade=CascadeType.ALL表示存储user表时把与他相关联的表也存储，否则需要自己先手动存储关联的那个表</span></span><br><span class="line">    <span class="comment">//,fetch=FetchType.EAGER//取一对多时，默认只会取出一不会取出多,即fetch默认是lazy，此时设置了eager则会在取组的同时取出用户信息。一般不这么用</span></span><br><span class="line">)<span class="comment">//cascade设定CUD，fetch设定R</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;User3&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User3类</span></span><br><span class="line"><span class="meta">@ManyToOne</span>(cascade=&#123;CascadeType.ALL&#125;)<span class="comment">//cascade=CascadeType.ALL表示存储user表时把与他相关联的表也存储，否则需要自己先手动存储关联的那个表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Group3 <span class="title">getGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只要有关联关系(包括所有关联类型)，默认保存A，hibernate不会自动保存B. 设置在A中设置cascade可以让hibernate在保存A的时候也保持B. 如果需要保存B也保存A，则需要在B中也设置cascade</li><li>CascadeType取值：<ul><li><code>ALL</code> Cascade all operations所有情况(CUD)</li><li><code>MERGE</code> Cascade merge operation合并(merge=save+update)</li><li><code>PERSIST</code> Cascade persist operation存储 persist()</li><li><code>REFRESH</code> Cascade refresh operation刷新</li><li><code>REMOVE</code> Cascade remove operation删除</li></ul></li></ul></li><li><p><strong><code>fetch</code>获取数据的方式</strong></p><ul><li>查询时@ManyToOne默认会把一的那一方取出来(默认为EAGER)，@OneToMany则不会默认把多的那一方取出来(默认为LAZY). 修改fetch则可以改变默认取值方式</li><li>取值有：<code>FetchType.LAZY</code>(懒惰) 和 <code>FetchType.EAGER</code>(渴望)</li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line">Session session = sf.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line"><span class="comment">// User3 user3 = (User3)session.load(User3.class, 1);</span></span><br><span class="line">User3 user3 = (User3)session.get(User3.class, <span class="number">1</span>); <span class="comment">//当多对一时，取多时，默认会把一也取出来。此时取用户的信息时也会把组的信息取出来放到内存中</span></span><br><span class="line">session.getTransaction().commit();</span><br><span class="line">System.out.println(user3.getGroup().getName()); <span class="comment">// 可以正常获取, @ManyToOne默认是EAGER。如果上面是load则此处会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">Session session = sf.getCurrentSession();</span><br><span class="line">session.beginTransaction();</span><br><span class="line">Group3 group3 = (Group3)session.get(Group3.class, <span class="number">1</span>);<span class="comment">//取一对多时，默认只会取出一不会取出多。但如果在关联的批注处设定了fetch=FetchType.EAGER，则会同时取出用户信息</span></span><br><span class="line"><span class="comment">// Set&lt;User3&gt; user3s = group3.getUsers(); // ### 如果fetch没有设定了eager，则可以在此处手动把User都拿出来放到内存中. 一般是一对多时手动获取多的那一方 ###</span></span><br><span class="line">session.getTransaction().commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 如果fetch设定了eager则已经将用户信息取到内存中了. 否则此处会报错 ###</span></span><br><span class="line"><span class="keyword">for</span>(User3 u : group3.getUsers()) &#123;</span><br><span class="line">    System.out.println(u.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除操作：如果Group和User都设置了CascadeType.ALL，则在删除user时也会把group删除. 解决办法</p><ul><li>直接写Hql语句执行删除（推荐）</li><li>去掉@ManyToOne(cascade={CascadeType.All})设置, 手动执行CRU</li><li><p>将user对象的group属性设为null，相当于打断User与Group间的关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session.beginTransaction();</span><br><span class="line">User user = (User)session.load(User.class,<span class="number">1</span>);</span><br><span class="line">user.setGroup(<span class="keyword">null</span>);</span><br><span class="line">session.delete(user);</span><br><span class="line">session.getTransaction().commit();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>集合映射(src/cn.aezo.hibernate.collections_mapping)</p><ul><li><p>多的一方是什么的存储方式：Set(常用)、List、Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Map存储</span></span><br><span class="line"><span class="meta">@OneToMany</span>(mappedBy=<span class="string">"group"</span>,cascade=&#123;CascadeType.ALL&#125;)</span><br><span class="line"><span class="meta">@MapKey</span>(name=<span class="string">"id"</span>)<span class="comment">//以users中user的id作为map的key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Integer, User4&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>继承映射(视频55)</p><ul><li><code>SINGLE_TABLE</code> 一张总表保存</li><li><code>TABLE_PER_CLASS</code> 每个类分别一张表(最终也会生成3张表，使用@TableGenerator的id生成策略映射)<ul><li>使用多态查询时会查3张表并进行合并</li></ul></li><li><code>JOINED</code> 每个子类一张表(最终也会生成3张表，使用@Inheritance(strategy=InheritanceType.JOINED))<ul><li>查询必须使用进行联合</li></ul></li></ul></li><li><p>树状结构设计(src/cn.aezo.hibernate.tree)</p><ul><li><p>在一个类中同时使用一对多和多对一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Org组织类，对应表Org(id, pid, name)</span></span><br><span class="line"><span class="meta">@OneToMany</span>(</span><br><span class="line">    mappedBy=<span class="string">"parent"</span>,</span><br><span class="line">    cascade=&#123;CascadeType.ALL&#125;</span><br><span class="line">    <span class="comment">//,fetch=FetchType.EAGER//只适合小级别的树，同时取出所有的，打印就可以打印在一起了；否则就在需要的时候发起sql语句</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Org&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"parent_id"</span>)<span class="comment">//只需写在关联处即可，所有也可写在@OneToMany的下面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Org <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>易错点</p><ul><li>在一个实体文件中，所有的注解要么全部放在字段上，要么全部放在get方法上，不能混合使用. 否则报错<code>Caused by: org.hibernate.MappingException: Could not determine type for...</code></li></ul></li></ol><h2 id="HQL-test-cn-aezo-hibernate-hql1-2"><a href="#HQL-test-cn-aezo-hibernate-hql1-2" class="headerlink" title="HQL (test/cn.aezo.hibernate.hql1/2)"></a>HQL (test/cn.aezo.hibernate.hql1/2)</h2><ol><li>查询语言：NativeSQL(oracle/mysql原生) &gt; HQL(hibernate查询语言) &gt; EJBQL(JPQL 1.0, 可以跨ORM框架) &gt; QBC(Query By Criteria) &gt; QBE(Query By Example)</li><li><p>举例(查询、修改、删除)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> org.hibernate.Query;</span><br><span class="line">  <span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HQL 面向对象的查询语言，此处要写类名而不是表名，可以省略 select *</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Category c where c.name &gt; 'c5' order by c.name desc"</span>);</span><br><span class="line">  List&lt;Category&gt; categories = (List&lt;Category&gt;) q.list(); <span class="comment">// q.iterate()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链式编程</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Category c where c.id &gt; :min and c.id &lt; :max"</span>)</span><br><span class="line">                   .setInteger(<span class="string">"min"</span>, <span class="number">2</span>)</span><br><span class="line">                   .setInteger(<span class="string">"max"</span>, <span class="number">8</span>);</span><br><span class="line">  List&lt;Category&gt; categories = (List&lt;Category&gt;) q.list();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setParameter会自动转换参数类型</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Category c where c.id &gt; ? and c.id &lt; ?"</span>);</span><br><span class="line">  q.setParameter(<span class="number">0</span>, <span class="number">2</span>).setParameter(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分页(取第二条到第4条数据)</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Category c order by c.name desc"</span>);</span><br><span class="line">  q.setMaxResults(<span class="number">4</span>);</span><br><span class="line">  q.setFirstResult(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取Topic的Category类的属性id (Topic下的Category是@ManyToOne，默认在查询Topic的会取Category)</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic t where t.category.id = 1"</span>);</span><br><span class="line">  <span class="comment">// 如果设置成Lazy，则当调用t.getCategory()的时候才会查询Category</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从实体中取出一个VO/DTO（下面的MsgInfo不是一个实体，是一个VO/DTO，他需要一个对应的构造方法）</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"select new cn.aezo.hibernate.hql1.MsgInfo(m.id, m.cont, m.topic.title, m.topic.category.name) from Msg m"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// join连接(left join)</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"select t.title, c.name from Topic t join t.category c"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象查询（调用的是equals方法）</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Msg m where m = :MsgToSearch"</span>);</span><br><span class="line">  Msg m = <span class="keyword">new</span> Msg();</span><br><span class="line">  m.setId(<span class="number">1</span>);</span><br><span class="line">  q.setParameter(<span class="string">"MsgToSearch"</span>, m);</span><br><span class="line">  Msg mResult = (Msg) q.uniqueResult(); <span class="comment">// 返回唯一结果(确定里面只有一条)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// is empty 和 is not empty（最终sql语句使用了exists、not exists）</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic1 t where t.msgs is empty"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic1 t where not exists (select m.id from Msg1 m where m.topic.id=t.id)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取时间</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"select current_date, current_time, current_timestamp, t.id from Topic1 t"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 时间比较</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic1 t where t.createDate &lt; :date"</span>);</span><br><span class="line">  q.setParameter(<span class="string">"date"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分组</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"select t.title, count(*) from Topic1 t group by t.title"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"select t.title, count(*) from Topic1 t group by t.title having count(*) &gt;= 1"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原生sql查询</span></span><br><span class="line">  SQLQuery q = session.createSQLQuery(<span class="string">"select * from category limit 2,4"</span>).addEntity(Category1.class);</span><br><span class="line">  List&lt;Category1&gt; categories = (List&lt;Category1&gt;)q.list();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常用查询</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"select count(*) from Msg m"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"select max(m.id), min(m.id), avg(m.id), sum(m.id) from Msg m"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Msg m where m.id between 3 and 5"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Msg m where m.id in (3,4, 5)"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Msg m where m.cont is not null"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic1 t where t.title like '%5'"</span>);</span><br><span class="line">  Query q = session.createQuery(<span class="string">"from Topic1 t where t.title like '_5'"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别名查询</span></span><br><span class="line">  <span class="comment">// (1) 在实体上进行注解查询语句，去别名topic.selectCertainTopic（原生sql语句查询别名注解@NamedNativeQueries）</span></span><br><span class="line">  <span class="meta">@NamedQueries</span>(&#123;</span><br><span class="line">     <span class="meta">@NamedQuery</span>(name=<span class="string">"topic.selectCertainTopic"</span>, query=<span class="string">"from Topic t where t.id = :id"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topic1</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="comment">// (2) 使用上叙别名</span></span><br><span class="line">  Query q = session.getNamedQuery(<span class="string">"topic.selectCertainTopic"</span>);</span><br><span class="line">  q.setParameter(<span class="string">"id"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行修改/删除</span></span><br><span class="line">  Query q = session.createQuery(<span class="string">"update Topic1 t set t.title = upper(t.title)"</span>) ;</span><br><span class="line">  q.executeUpdate();</span><br></pre></td></tr></table></figure></li><li><p>QBC/QBE (test/cn.aezo.hibernate.qbc/qbe)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QBC (Query By Criteria). 此时不需要sql语句, 纯面向对象了</span></span><br><span class="line"><span class="comment">// criterion 约束/标准/准则</span></span><br><span class="line">Criteria c = session.createCriteria(Topic2.class) <span class="comment">// from Topic</span></span><br><span class="line">             .add(Restrictions.gt(<span class="string">"id"</span>, <span class="number">2</span>)) <span class="comment">// greater than = id &gt; 2</span></span><br><span class="line">             .add(Restrictions.lt(<span class="string">"id"</span>, <span class="number">8</span>)) <span class="comment">// little than = id &lt; 8</span></span><br><span class="line">             .add(Restrictions.like(<span class="string">"title"</span>, <span class="string">"t_"</span>))</span><br><span class="line">             .createCriteria(<span class="string">"category"</span>)</span><br><span class="line">             .add(Restrictions.between(<span class="string">"id"</span>, <span class="number">3</span>, <span class="number">5</span>)) <span class="comment">// category.id &gt;= 3 and category.id &lt;=5</span></span><br><span class="line">             ;</span><br><span class="line"><span class="comment">// DetachedCriterea</span></span><br><span class="line"><span class="keyword">for</span>(Object o : c.list()) &#123;</span><br><span class="line">    Topic2 t = (Topic2) o;</span><br><span class="line">    System.out.println(t.getId() + <span class="string">"-"</span> + t.getTitle());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QBE (Query By Example)</span></span><br><span class="line">Topic3 tExample = <span class="keyword">new</span> Topic3();</span><br><span class="line">tExample.setTitle(<span class="string">"T_"</span>);</span><br><span class="line"></span><br><span class="line">Example e = Example.create(tExample)</span><br><span class="line">            .ignoreCase().enableLike();</span><br><span class="line">Criteria c = session.createCriteria(Topic3.class)</span><br><span class="line">             .add(Restrictions.gt(<span class="string">"id"</span>, <span class="number">2</span>))</span><br><span class="line">             .add(Restrictions.lt(<span class="string">"id"</span>, <span class="number">8</span>))</span><br><span class="line">             .add(e)</span><br><span class="line">             ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Object o : c.list()) &#123;</span><br><span class="line">    Topic3 t = (Topic3)o;</span><br><span class="line">    System.out.println(t.getId() + <span class="string">"-"</span> + t.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ol><li><code>session.clear()</code>的运用，尤其在不断分页循环的时候<ul><li>在一个大集合中进行遍历，遍历msg，取出其中的含有敏感字样的对象</li><li>另外一种形式的内存泄露(面试题：Java在语法级别没有内存泄漏，但是可由java引起。例如：连接池不关闭或io读取后不关闭)</li></ul></li><li>1+N问题<ul><li>使用LAZY。<code>@ManyToOne</code> 默认是EAGER（默认在查询主表是，也会查询子表的数据，发出sql语句）。可将其改为<code>@ManyToOne(fetch=FetchType.LAZY)</code>，此时当使用的时候(如:t.getCategory().getName()时)才会发出sql语句</li><li>hql语句中使用<code>join fetch</code>。如将hql语句改成<code>from Topic t left join fetch t.category c</code></li><li>QBC。如使用createCriteria查询，会自动生成含join fetch的sql语句</li></ul></li><li>list和iterate不同之处<ul><li>list取所有；iterate先取ID，等用到的时候再根据ID来取对象</li><li>session中list第二次发出仍会到数据库査询；iterate第二次首先找session级缓存</li></ul></li><li><p>一级缓存和二级缓存和査询缓存(指两次查询的条件一样)</p><ul><li>一级缓存是session级别的缓存；二级缓存是SessionFactory级别的缓存，可以跨越session存在；</li><li><p>二级缓存</p><ul><li><p>打开二级缓存，hibernate.cfg.xml设定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--使用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache.provider_class"</span>&gt;</span>org.hibernate.cache.EhCacheProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--使用EhCache提供商提供的二级缓存--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>@Cache</code>注解(由hibernate扩展提供)</p><ul><li><code>@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)</code></li><li>使用EhCache二级缓存 需要导入ehcache-1.2.3.jar及commons-logging-1.0.4.jar包</li></ul></li><li>二级缓存的使用场景：<strong>经常被访问、改动不大或不会经常改动、数重有限（如权限信息、组织信息）</strong></li><li>load默认使用二级缓存；iterate默认使用二级缓存；list默认往二级缓存加数据，但是查询的时候不使用</li><li>查询缓存(指两次查询的条件一样)<ul><li><code>&lt;property name=&quot;cache.use_query_cache&quot;&gt;true&lt;/property&gt;</code> 查询缓存依赖与二级缓存，需要打开二级缓存</li><li>调用Query的<code>setCachable(true)</code>方法指明使用二级缓存，如：<code>session.createQuery(&quot;from Category&quot;).setCacheable(true).list();</code></li></ul></li><li>缓存算法：LRU、LFU、FIFO<ul><li>LRU: Least Recently Used 最近很少被使用，按使用时间</li><li>LFU: Least Frequently Used 按命中率高低</li><li>FIFO: First In First Out 按顺序替换</li></ul></li></ul></li></ul></li><li>事务并发处理<ul><li>事务：ACID (Atomic原子性、Consistency一致性、Itegrity独立性、Durability持久性)</li><li>事务并发时可能出现的问题<ul><li><code>dirty read</code>脏读(读到了另一个事务在处理中还未提交的数据)</li><li><code>non-repeatable read</code>不可重复读(一个事物中两次读取的数据不一致，被其他事物影响了)</li><li><code>phantom read</code>幻读(主要针对插入和删除，在读的过程中，另外一个事物插入或删除了一条数据影响了读的结果)</li></ul></li><li>数据库的事务隔离机制<ul><li>查看 <code>java.sql.Connection</code> 文档</li><li>1：<code>read-uncommitted</code> 2：<code>read-committed</code> 4：<code>repeatable read</code> 8：<code>serializable</code>（数字代表对应值或级别，级别越高越安全但是效率约低）<ul><li><code>read-uncommitted</code>(允许读取未提交的数据) 会出现dirty read, phantom-read, non-repeatable read 问题</li><li><strong><code>read-commited</code></strong>(读取已提交的数据 项目中一般都使用这个)不会出现dirty read，因为只有另一个事务提交才会读出来结果，但仍然会出现 non-repeatable read 和 phantom-read。使用read-commited机制可用悲观锁、乐观锁来解决non-repeatable read 和 phantom-read问题</li><li><code>repeatable read</code>(事务执行中其他事务无法执行修改或插入操作，较安全)</li><li><code>serializable</code> 解决一切问题(顺序执行事务 不并发，实际中很少用)</li><li>为什么取值要使用 1 2 4 8 而不是 1 2 3 4。1=0000 2=0010 4=0100 8=1000(位移计算效率高)</li></ul></li><li>hibernate设置<ul><li>设定hibernate的事务隔离级别(使用hibernate.connection.isolation配置，取值1、2、4、8)</li><li>hibernate.connection.isolation = 2（如果不设 默认依赖数据库本身的级别）</li><li>用悲观锁解决repeatable read的问题（依赖于数据库的锁）<ul><li>法一：<code>select ... for update</code></li><li>法二：使用另一种load方法：<code>load(xxx.class, i, LockMode.Upgrade)</code> i=1/2/4/8</li></ul></li><li>Hibernate(JPA)乐观锁定(ReadCommitted)<ul><li>实体类中增加version属性(数据库也会对应生成该字段,初始值为0)，并在其get方法前加<code>@Version</code>注解，则在操作过程中没更新一次该行数据则version值加1，即可在事务提交前判断该数据是否被其他事务修改过</li></ul></li></ul></li></ul></li></ul></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="JPA字段为null时不进行保存"><a href="#JPA字段为null时不进行保存" class="headerlink" title="JPA字段为null时不进行保存"></a>JPA字段为null时不进行保存</h3><ul><li><a href="https://blog.csdn.net/perfect_red/article/details/102692990" target="_blank" rel="noopener">https://blog.csdn.net/perfect_red/article/details/102692990</a></li></ul><h3 id="获取SessionFactory和Session"><a href="#获取SessionFactory和Session" class="headerlink" title="获取SessionFactory和Session"></a>获取SessionFactory和Session</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加此配置即可通过@Autowired获取到SessionFactory</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line"><span class="attr">        current_session_context_class:</span> <span class="string">org.springframework.orm.hibernate5.SpringSessionContext</span></span><br></pre></td></tr></table></figure><ul><li>获取Session<ul><li>session 与 connection 是多对一的关系，每个 session 都有一个与之对应的connection，一个 connection 不同时刻可以供多个 session 使用</li><li>获取session方法<ul><li>openSession 和 getCurrentSession</li><li>openSession() 是可以直接使用的；而 getCurrentSession() 需要在 hibernate.hbm.xml 文件中进行配置，然后才可以使用</li><li>openSession 需要手动的关闭 session ，如果使用 openSession 而没有手动关闭 session ，多次之后就会导致连接池的溢出；而 getCurrentSession 获得的 session 在事务提交或者回滚之后就会自动的关闭</li><li>openSession 每次得到的都是新的 session 对象；而 getCurrenSession 方法得到的 session 是单例的，也就是每次得到的 session 对象是同一个对象</li><li>openSession 中在获得了 session 之后就可以通过 session.doWork() 方法获得 connection 对象;getCurrentSession 中需要先打开事务，才能通过 session.doWork() 方法获得 connection 对象</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.getCurrentSession();</span><br><span class="line">Session session = sessionFactory.openSession();</span><br></pre></td></tr></table></figure><h3 id="直接运行SQL"><a href="#直接运行SQL" class="headerlink" title="直接运行SQL"></a>直接运行SQL</h3><ul><li>还需要增加<code>@EnableTransactionManagement</code>注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, Object&gt;&gt; querySql(String sql) &#123;</span><br><span class="line">    Seesion session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NativeQuery&lt;Map&lt;String, Object&gt;&gt; query = session.createSQLQuery(sql);</span><br><span class="line">        query.setResultTransformer( Transformers.ALIAS_TO_ENTITY_MAP );</span><br><span class="line">        <span class="keyword">return</span> query.list();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">querySql</span><span class="params">(String sql, Class&lt;R&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Seesion session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NativeQuery&lt;R&gt; query = session</span><br><span class="line">            .createSQLQuery(sql)</span><br><span class="line">            .addEntity(clazz);</span><br><span class="line">        <span class="keyword">return</span> query.list();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">List&lt;R&gt; <span class="title">querySql</span><span class="params">(String sql, Class&lt;R&gt; clazz, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    Seesion session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NativeQuery&lt;R&gt; query = session.createSQLQuery(sql);</span><br><span class="line">        query.addEntity(clazz);</span><br><span class="line">        query.setFirstResult(startIndex);</span><br><span class="line">        query.setMaxResults(size);</span><br><span class="line">        <span class="keyword">return</span> query.list();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hibernate自动生成的表字段顺序乱了"><a href="#Hibernate自动生成的表字段顺序乱了" class="headerlink" title="Hibernate自动生成的表字段顺序乱了"></a>Hibernate自动生成的表字段顺序乱了</h3><ul><li>参考 <a href="https://blog.csdn.net/weixin_34321753/article/details/92363155" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34321753/article/details/92363155</a><ul><li>复制<code>org.hibernate.cfg.PropertyContainer</code>源码到项目中(在本项目中创建一个和源码类一样的包结构和一样名字的类)</li><li>替换所有的TreeMap为LinkedHashMap</li></ul></li></ul><hr><p>参考文章</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> smalle</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.aezo.cn/2017/05/21/java/hibernate/" title="Hibernate">http://blog.aezo.cn/2017/05/21/java/hibernate/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/db/" rel="tag"># db</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/05/10/extend/windows/" rel="next" title="Windows"><i class="fa fa-chevron-left"></i> Windows</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2017/05/22/java/mybatis/" rel="prev" title="Mybatis">Mybatis<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400" alt="smalle"><p class="site-author-name" itemprop="name">smalle</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">161</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">141</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Springboot对hibernate的默认支持-JPA-2017-07-23"><span class="nav-number">2.</span> <span class="nav-text">Springboot对hibernate的默认支持(JPA) 2017-07-23</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World"><span class="nav-number">3.</span> <span class="nav-text">Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xml配置"><span class="nav-number">3.1.</span> <span class="nav-text">xml配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Annotation注解-常用"><span class="nav-number">3.2.</span> <span class="nav-text">Annotation注解 (常用)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hibernate-cfg-xml配置"><span class="nav-number">4.</span> <span class="nav-text">hibernate.cfg.xml配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关注解类"><span class="nav-number">5.</span> <span class="nav-text">相关注解类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心开发接口"><span class="nav-number">6.</span> <span class="nav-text">核心开发接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系映射-视频35-52"><span class="nav-number">7.</span> <span class="nav-text">关系映射 (视频35-52)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HQL-test-cn-aezo-hibernate-hql1-2"><span class="nav-number">8.</span> <span class="nav-text">HQL (test/cn.aezo.hibernate.hql1/2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能问题"><span class="nav-number">9.</span> <span class="nav-text">性能问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">10.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA字段为null时不进行保存"><span class="nav-number">10.1.</span> <span class="nav-text">JPA字段为null时不进行保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取SessionFactory和Session"><span class="nav-number">10.2.</span> <span class="nav-text">获取SessionFactory和Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接运行SQL"><span class="nav-number">10.3.</span> <span class="nav-text">直接运行SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hibernate自动生成的表字段顺序乱了"><span class="nav-number">10.4.</span> <span class="nav-text">Hibernate自动生成的表字段顺序乱了</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">smalle</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class="powered-by"> 由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="powered-by"> 主题 - <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="theme-info cnzz" style="margin:0 0 -5px 10px"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1276691827'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s23.cnzz.com/z_stat.php%3Fid%3D1276691827%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div></div><div class="ad"> <span style="font-weight:700">AD&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=oby5nolb">阿里云大礼包</a></div></div><div class="aezocn"> <span style="font-weight:700">@AEZO.CN&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="http://shop.aezo.cn/">杂货铺</a></div></div><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script></body></html>