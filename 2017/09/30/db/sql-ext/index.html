<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="mysql,oracle,sql,"><link rel="alternate" href="/atom.xml" title="Smalle's Blog | AEZOCN" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="基本原则 mysql书写顺序和执行顺序都是按照select-from-where-group by-having-order by-limit进行的 MySQL中子结果集必须使用别名，而Oracle中不需要特意加别名  不同数据库差异 Oracle迁移MySQL注意事项  数据类型转换 mysql：cast()和 convert() 可将一个类型转成另外一个类型 语法：cast(expr as t"><meta name="keywords" content="mysql,oracle,sql"><meta property="og:type" content="article"><meta property="og:title" content="sql进阶"><meta property="og:url" content="http://blog.aezo.cn/2017/09/30/db/sql-ext/index.html"><meta property="og:site_name" content="Smalle&#39;s Blog | AEZOCN"><meta property="og:description" content="基本原则 mysql书写顺序和执行顺序都是按照select-from-where-group by-having-order by-limit进行的 MySQL中子结果集必须使用别名，而Oracle中不需要特意加别名  不同数据库差异 Oracle迁移MySQL注意事项  数据类型转换 mysql：cast()和 convert() 可将一个类型转成另外一个类型 语法：cast(expr as t"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-over-1.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-over-2.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-keep-1.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-keep-2.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-keep-3.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/oracle-keep-4.png"><meta property="og:updated_time" content="2022-09-05T13:49:18.648Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="sql进阶"><meta name="twitter:description" content="基本原则 mysql书写顺序和执行顺序都是按照select-from-where-group by-having-order by-limit进行的 MySQL中子结果集必须使用别名，而Oracle中不需要特意加别名  不同数据库差异 Oracle迁移MySQL注意事项  数据类型转换 mysql：cast()和 convert() 可将一个类型转成另外一个类型 语法：cast(expr as t"><meta name="twitter:image" content="http://blog.aezo.cn/data/images/db/oracle-over-1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"BWD6R9FA4K",apiKey:"3330f3cbaa099dfc30395de5f5b20151",indexName:"blog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}}}</script><link rel="canonical" href="http://blog.aezo.cn/2017/09/30/db/sql-ext/"><title>sql进阶 | Smalle's Blog | AEZOCN</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=cnzz_stat_icon_1276691827&web_id=cnzz_stat_icon_1276691827" language="JavaScript"></script></div></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Smalle's Blog | AEZOCN</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Better Code, Better Life</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2017/09/30/db/sql-ext/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="smalle"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Smalle's Blog | AEZOCN"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">sql进阶</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T12:51:00+08:00">2017-09-30</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><div></div><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul><li>mysql书写顺序和执行顺序都是按照<code>select-from-where-group by-having-order by-limit</code>进行的</li><li>MySQL中子结果集必须使用别名，而Oracle中不需要特意加别名</li></ul><h2 id="不同数据库差异"><a href="#不同数据库差异" class="headerlink" title="不同数据库差异"></a>不同数据库差异</h2><ul><li><a href="https://z.itpub.net/article/detail/981AEFD121E9C508F063228A878ED6E0" target="_blank" rel="noopener">Oracle迁移MySQL注意事项</a></li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>mysql：<code>cast()</code>和 <code>convert()</code> 可将一个类型转成另外一个类型<ul><li>语法：cast(expr as type)、convert(expr, type)、convert(expr using transcoding_name)</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql、h2。可用类型：二进制 BINARY、字符型，可带参数 CHAR()、日期 DATE、TIME、DATETIME、浮点数 DECIMAL、整数 SIGNED、无符号整数 UNSIGNED</span></span><br><span class="line"><span class="comment">-- 可将LONG/CLOB等转成字符串</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">cast</span>(<span class="keyword">ID</span> <span class="keyword">as</span> <span class="built_in">char</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日期时间转换</span></span><br><span class="line"><span class="comment">-- mysql</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">date_format</span>(<span class="keyword">now</span>(), <span class="string">'%Y-%m-%d %H:%i:%s'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'2016-01-02 10:00:00.000'</span>,<span class="string">'%Y-%m-%d %H:%i:%s.%f'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_days</span>(<span class="keyword">now</span>()); <span class="comment">-- 727666 从0年开始到当前的天数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_days</span>(<span class="string">'2016-01-02'</span>);</span><br><span class="line"><span class="comment">-- oracel(oracle也支持cast)</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>, <span class="string">'yyyy-MM-dd HH24:mi:ss'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2016-01-02 10:00:00'</span>, <span class="string">'yyyy-MM-dd HH24:mi:ss'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">cast</span>(<span class="number">100</span> <span class="keyword">as</span> varchar2(<span class="number">10</span>)) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--sqlserver</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CONVERT</span>(<span class="built_in">VARCHAR</span>(<span class="number">10</span>), <span class="keyword">GETDATE</span>(), <span class="number">120</span>); <span class="comment">-- 格式化日期(120为一种格式) 2000-01-01</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CONVERT</span>(datetime, <span class="string">'2000-01-01'</span>, <span class="number">20</span>); <span class="comment">-- 字符串转日期 2000-01-01 00:00:00.000</span></span><br></pre></td></tr></table></figure><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql</span></span><br><span class="line">date_sub(now(), interval 7 day) <span class="comment">-- 当前时间-7天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- oracle</span></span><br><span class="line">sysdate + interval '1' year <span class="comment">-- 当前日期加1年，还可使用：month、day、hour、minute、second</span></span><br><span class="line">sysdate + interval '1 1:1' day to minute <span class="comment">-- 当前日期 + 1日1时1分</span></span><br><span class="line">sysdate + 1 <span class="comment">-- 加1天</span></span><br><span class="line">sysdate - 1/24/60/60 <span class="comment">-- 减1秒</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span>, add_months(<span class="keyword">sysdate</span>, <span class="number">-12</span>) <span class="keyword">from</span> dual; <span class="comment">-- 减1年</span></span><br><span class="line"><span class="keyword">select</span> TRUNC(<span class="keyword">SYSDATE</span>) <span class="keyword">FROM</span> dual; <span class="comment">-- 取得当天0时0分0秒</span></span><br><span class="line"><span class="keyword">SELECT</span> TRUNC(<span class="keyword">SYSDATE</span>)+<span class="number">1</span><span class="number">-1</span>/<span class="number">86400</span> <span class="keyword">FROM</span> dual; <span class="comment">-- 取得当天23时59分59秒(在当天0时0分0秒的基础上加1天后再减1秒)</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm'</span>)||<span class="string">'-01'</span> firstday, </span><br><span class="line">       to_char(<span class="keyword">last_day</span>(<span class="keyword">sysdate</span>),<span class="string">'yyyy-mm-dd'</span>) lastday <span class="keyword">from</span> dual; <span class="comment">-- 在oracle中如何得到当天月份的第一天和最后一天</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'1970'</span>, <span class="string">'yyyy'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sqlserver</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">GETDATE</span>(), <span class="comment">-- 获取当前时间(带时间) 2000-01-01 08:11:12.000</span></span><br><span class="line">    <span class="keyword">GETUTCDATE</span>(), <span class="comment">-- 当前UTC时间 2000-01-01 00:11:12.000</span></span><br><span class="line">    <span class="keyword">DATEDIFF</span>(<span class="keyword">hour</span>, <span class="keyword">GETUTCDATE</span>(), <span class="keyword">GETDATE</span>()), <span class="comment">-- 获取当前时间-当前UTC时间的相差小时 8</span></span><br><span class="line">    <span class="keyword">DATEADD</span>(<span class="keyword">hour</span>, <span class="keyword">DATEDIFF</span>(<span class="keyword">hour</span>, <span class="keyword">GETUTCDATE</span>(), <span class="keyword">GETDATE</span>()), <span class="keyword">GETUTCDATE</span>()); <span class="comment">-- 对UTC时间增加时区差 2000-01-01 08:11:12.000</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DATEADD</span>(<span class="keyword">DAY</span>, <span class="number">0</span>, <span class="keyword">DATEDIFF</span>(<span class="keyword">DAY</span>, <span class="number">0</span>, <span class="keyword">GETDATE</span>())); <span class="comment">-- 2000-01-01 00:00:00.000</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CAST</span>(<span class="keyword">CAST</span>(<span class="keyword">GETDATE</span>() <span class="keyword">as</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) + <span class="string">' 00:00:00'</span>; <span class="comment">-- 2000-01-01 00:00:00.000</span></span><br></pre></td></tr></table></figure><ul><li>日期数据类型转换见上文</li></ul><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>关键字转义</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`user`</span>; <span class="comment">-- mysql</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> [<span class="keyword">Order</span>]; <span class="comment">-- sqlserver</span></span><br></pre></td></tr></table></figure><ul><li>空值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- oracle null包含了空字符串('' == null)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> last_name <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> last_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">nvl(counts, 0)</span><br><span class="line"><span class="comment">-- mysql null不包含空字符串('' != null)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> last_name <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> last_name = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> last_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">and</span> last_name != <span class="string">''</span>;</span><br><span class="line">ifnull(counts, 0)</span><br><span class="line"><span class="comment">-- sqlserver</span></span><br><span class="line">isnull(counts, 0)</span><br></pre></td></tr></table></figure><ul><li>字符串类型值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Mysql 可以使用单引号或双引号，Oracle只能使用单引号</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"smalle"</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'smalle'</span>;</span><br></pre></td></tr></table></figure><ul><li>as</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Mysql/Oracle两种写均支持。只不过mybatis操作oracle返回map时，第一种写法的key全部为大写，第二种写法的key为小写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"smalle"</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> <span class="string">"username"</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"smalle"</span>;</span><br></pre></td></tr></table></figure><ul><li>多字段查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- oracle</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> t <span class="keyword">where</span> (t.name, t.sex) <span class="keyword">in</span> ((<span class="string">'张三'</span>, <span class="number">1</span>)); <span class="comment">-- 此处用=也得在外面多加一层括号</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>控制排序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order by my_field [asc|desc] nulls [first|last] <span class="comment">-- oracle</span></span><br><span class="line">order by if(isnull(my_field),1,0), my_field [asc|desc] <span class="comment">-- mysql默认将null值放在下面</span></span><br><span class="line">order by if(isnull(my_field),0,1), my_field [asc|desc] <span class="comment">-- mysql默认将null值放在上面</span></span><br></pre></td></tr></table></figure><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设两个字段一个是number(10, 2)的, 一个是FLOAT的则比较可能会有问题，可进行cast/round转换再比较</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> num1 &gt; <span class="keyword">cast</span>(num2 <span class="keyword">as</span> <span class="built_in">number</span>(<span class="number">10</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><ul><li>count是统计该字段不为空的行数，可结合distinct使用，如<code>count(distinct case when u.sex = &#39;1&#39; then u.city else null end )</code></li></ul><h3 id="基于用户属性表统计每个公司不同用户属性的用户数"><a href="#基于用户属性表统计每个公司不同用户属性的用户数" class="headerlink" title="基于用户属性表统计每个公司不同用户属性的用户数"></a>基于用户属性表统计每个公司不同用户属性的用户数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1个公司对于多个用户，1个用户对应多个属性</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	c.id,</span><br><span class="line">	c.name,<span class="comment">-- 公司名称</span></span><br><span class="line">	<span class="keyword">count</span>( <span class="keyword">distinct</span> u.id ) count_user,<span class="comment">-- 该公司的用户数</span></span><br><span class="line">	<span class="keyword">count</span>( <span class="keyword">case</span> <span class="keyword">when</span> ua.key = <span class="string">'JobTitle'</span> <span class="keyword">and</span> ua.value = <span class="string">'employee'</span> <span class="keyword">then</span> c.id <span class="keyword">end</span> ) count_employee,<span class="comment">-- 该公司的普通员工数。也可加上`else null`(因为count是统计该字段不为空的行数); 还可以加上 distinct 进行去重</span></span><br><span class="line">	<span class="keyword">count</span>( <span class="keyword">case</span> <span class="keyword">when</span> ua.key = <span class="string">'JobTitle'</span> <span class="keyword">and</span> ua.value = <span class="string">'manager'</span> <span class="keyword">then</span> c.id <span class="keyword">end</span> ) count_manager,<span class="comment">-- 该公司的经理数</span></span><br><span class="line">	<span class="keyword">count</span>( <span class="keyword">case</span> <span class="keyword">when</span> ua.key = <span class="string">'Sex'</span> <span class="keyword">and</span> ua.value = <span class="string">'boy'</span> <span class="keyword">then</span> c.id <span class="keyword">end</span> ) count_boy <span class="comment">-- 该公司男性用户数</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	company c</span><br><span class="line">	<span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">users</span> u <span class="keyword">on</span> c.id = u.company_id</span><br><span class="line">	<span class="keyword">left</span> <span class="keyword">join</span> user_attr ua <span class="keyword">on</span> ua.user_id = u.id </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	c.id,</span><br><span class="line">	c.name</span><br></pre></td></tr></table></figure><h3 id="基于关系表统计多个关系同时存在的主表记录"><a href="#基于关系表统计多个关系同时存在的主表记录" class="headerlink" title="基于关系表统计多个关系同时存在的主表记录"></a>基于关系表统计多个关系同时存在的主表记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通知表：notice</span></span><br><span class="line"><span class="comment">通知-用户关系表：notice_relation</span></span><br><span class="line"><span class="comment">发布通知时可选择部分用户，此时查询出用户1、2、3同时收到的通知记录，并统计出每个通知的已读和未读人数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> nr.notice_id, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> send_user_counts,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> nm.read_status = <span class="number">1</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) yes_read,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">case</span> <span class="keyword">when</span> nm.read_status = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) no_read</span><br><span class="line"><span class="keyword">from</span> notice_relation nr</span><br><span class="line"><span class="keyword">where</span> nr.user_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> nr.notice_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="行转列-列转行"><a href="#行转列-列转行" class="headerlink" title="行转列/列转行"></a>行转列/列转行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-- course</span></span><br><span class="line"><span class="comment">id  stu_no  course_name course_score</span></span><br><span class="line"><span class="comment">1   1       yuewen      90</span></span><br><span class="line"><span class="comment">2   1       shuxue      80</span></span><br><span class="line"><span class="comment">3   1       yingyu      85</span></span><br><span class="line"><span class="comment">4   2       yuewen      95</span></span><br><span class="line"><span class="comment">5   2       shuxue      100</span></span><br><span class="line"><span class="comment">6   2       yingyu      55</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- course2</span></span><br><span class="line"><span class="comment">stu_no  yuewen  shuxue  yingyu</span></span><br><span class="line"><span class="comment">1       90      80      85</span></span><br><span class="line"><span class="comment">2       95      100     55</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="oracle"><a href="#oracle" class="headerlink" title="oracle"></a>oracle</h4><ul><li><p>使⽤ decode 与聚合函数实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.name,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">decode</span>(t.course,<span class="string">'chinese'</span>, score, <span class="literal">null</span>)) <span class="keyword">as</span> CHINESE,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">decode</span>(t.course,<span class="string">'math'</span>, score, <span class="literal">null</span>)) <span class="keyword">as</span> MATH,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">decode</span>(t.course,<span class="string">'english'</span>, score, <span class="literal">null</span>)) <span class="keyword">as</span> ENGLISH</span><br><span class="line"><span class="keyword">from</span> students t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t.name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t.name</span><br></pre></td></tr></table></figure></li><li><p>使⽤ case when 与聚合函数实现，类似decode</p></li><li><p>使⽤ pivot 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>, chhinese, math, english <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">pivot</span>(</span><br><span class="line">        <span class="keyword">max</span>(score) <span class="comment">-- max ⾥是要转的列的值</span></span><br><span class="line">        <span class="keyword">for</span> course <span class="comment">-- 需要转的列名称</span></span><br><span class="line">        <span class="keyword">in</span>(<span class="string">'chinese'</span> chhinese, <span class="string">'math'</span> math, <span class="string">'english'</span> english)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 扩展说明: pivot的xml字句</span></span><br><span class="line"><span class="comment">-- bill_fee_cod_xml为xmltype格式(mybatis无法解析), getstringval为转成XML字符串(但是最大长度时4000), getclobval为转成clob格式(内容还是xml)</span></span><br><span class="line"><span class="keyword">select</span> ship_no, bill_nbr, bill_fee_cod_xml, (bill_fee_cod_xml).getstringval(), (bill_fee_cod_xml).getclobval() </span><br><span class="line">    <span class="keyword">from</span> bill_fee</span><br><span class="line">    <span class="comment">-- 以 XML 格式显示 pivot 操作的输出，在plsql中显示成了xmltype；此时对应字段为bill_fee_cod的后面加上_xml</span></span><br><span class="line">    <span class="keyword">pivot</span> <span class="keyword">xml</span> (<span class="keyword">sum</span>(MONEY_NUM) <span class="keyword">for</span> bill_fee_cod <span class="keyword">in</span>(<span class="keyword">select</span> BILL_FEE_COD <span class="keyword">from</span> bill_fee <span class="keyword">where</span> port_id = <span class="string">'1'</span> <span class="keyword">and</span> trust_cod = <span class="string">'CUL'</span>))</span><br><span class="line"><span class="keyword">where</span> port_id = <span class="string">'1'</span> <span class="keyword">and</span> trust_cod = <span class="string">'CUL'</span></span><br></pre></td></tr></table></figure></li><li><p>动态行转列(列名不固定)</p><ul><li>基于存储过程动态拼接SQL，参考<a href="/_posts/db/db-procedure.md#sql_pivot_dynamic_col动态行转列">db-procedure.md#sql_pivot_dynamic_col动态行转列</a></li><li>基于存储过程动态拼接SQL和视图 <a href="https://blog.csdn.net/Huay_Li/article/details/82924443" target="_blank" rel="noopener">https://blog.csdn.net/Huay_Li/article/details/82924443</a><ul><li>查询每次新增临时查询ID和时间，再定时删掉老的数据；第一次查询创建几百个字段的视图(无实际意义的字段名)，并把列头以一行值的形式显示到结果中(第一行值充当列头)</li></ul></li></ul></li><li>合并到一个字段<ul><li>参考<a href="#wm_concat行转列">wm_concat行转列</a></li><li>参考<a href="#listagg%20within%20group行转列">listagg within group行转列, 类似wm_concat</a></li></ul></li></ul><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 参考：https://www.cnblogs.com/xiaoxi/p/7151433.html</span></span><br><span class="line"><span class="comment">-- 行转列</span></span><br><span class="line"><span class="keyword">select</span> stu_no,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="string">`course_name`</span> <span class="keyword">when</span> <span class="string">'yuewen'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'yuewen'</span>,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="string">`course_name`</span> <span class="keyword">when</span> <span class="string">'shuxue'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'shuxue'</span>,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="string">`course_name`</span> <span class="keyword">when</span> <span class="string">'yingyu'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'yingyu'</span></span><br><span class="line"><span class="keyword">from</span> course </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu_no</span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>(userid,<span class="string">'total'</span>) <span class="keyword">as</span> userid,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="string">`course_name`</span>=<span class="string">'yuewen'</span>,course_score,<span class="number">0</span>)) <span class="keyword">as</span> yuewen, <span class="comment">-- IF(condition, value_if_true, value_if_false)</span></span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="string">`course_name`</span>=<span class="string">'shuxue'</span>,course_score,<span class="number">0</span>)) <span class="keyword">as</span> shuxue,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="string">`course_name`</span>=<span class="string">'yingyu'</span>,course_score,<span class="number">0</span>)) <span class="keyword">as</span> yingyu,</span><br><span class="line">    <span class="keyword">sum</span>(course_score) <span class="keyword">as</span> total </span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu_no <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br><span class="line"><span class="comment">-- 方式三：适用于不确定的列</span></span><br><span class="line"><span class="keyword">SET</span> @EE=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @EE :=<span class="keyword">CONCAT</span>(@EE,<span class="string">'sum(if(course_name=\''</span>,course_name,<span class="string">'\',course_score,0)) as '</span>,course_name, <span class="string">','</span>) <span class="keyword">AS</span> aa <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> course_name <span class="keyword">FROM</span> course) A; <span class="comment">-- (1) sum(if(`subject`='语文',score,0)) as 语文; (2) sum(if(`subject`='语文',score,0)) as 语文, sum(if(`subject`='数学',score,0)) as 数学; ...</span></span><br><span class="line"><span class="keyword">SET</span> @QQ = <span class="keyword">CONCAT</span>(<span class="string">'select ifnull(stu_no,\'-NA-\')as stu_no,'</span>,@EE,<span class="string">' from course group by stu_no'</span>);</span><br><span class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> @QQ;</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt;</span><br></pre></td></tr></table></figure><h4 id="sqlserver"><a href="#sqlserver" class="headerlink" title="sqlserver"></a>sqlserver</h4><ul><li>行转列：<code>PIVOT</code>用于将列值旋转为列名；也可用聚合函数配合CASE语句实现</li><li>列转行：<code>UNPIVOT</code>用于将列明转为列值；也可以用UNION来实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ## 行转列</span></span><br><span class="line"><span class="comment">-- 基于pivot</span></span><br><span class="line"><span class="keyword">select</span> a.stu_no, <span class="keyword">max</span>(a.yuwen) <span class="keyword">as</span> yuwen, <span class="keyword">max</span>(a.shuxue) <span class="keyword">as</span> shuxue, <span class="keyword">max</span>(a.yingyu) <span class="keyword">as</span> yingyu</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">pivot</span>(<span class="keyword">max</span>(course_score) <span class="keyword">for</span> course_name <span class="keyword">in</span>(yuwen,shuxue,yingyu)) a </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.stu_no</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于case when</span></span><br><span class="line"><span class="keyword">select</span> stu_no,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> course_name <span class="keyword">when</span> <span class="string">'yuwen'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'yuwen'</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> course_name <span class="keyword">when</span> <span class="string">'shuxue'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'shuxue'</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> course_name <span class="keyword">when</span> <span class="string">'yingyu'</span> <span class="keyword">then</span> course_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'yingyu'</span></span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">group</span> <span class="keyword">by</span> stu_no</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ## 列转行</span></span><br><span class="line"><span class="keyword">select</span> a.stu_no , a.course_name, a.course_score <span class="keyword">from</span> course2 <span class="keyword">unpivot</span>(course_score <span class="keyword">for</span> course_name <span class="keyword">in</span>(yuwen,shuxue,yingyu)) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t.stu_no, t.course_name, t.course_score <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> stu_no, course_name=<span class="string">'yuwen'</span>, course_score=yuwen <span class="keyword">from</span> course2</span><br><span class="line">	<span class="keyword">union</span> all</span><br><span class="line">	<span class="keyword">select</span> stu_no, course_name=<span class="string">'shuxue'</span>, course_score=shuxue <span class="keyword">from</span> course2</span><br><span class="line">	<span class="keyword">union</span> all</span><br><span class="line">	<span class="keyword">select</span> stu_no, course_name=<span class="string">'yingyu'</span>, course_score=yingyu <span class="keyword">from</span> course2</span><br><span class="line">) t <span class="keyword">order</span> <span class="keyword">by</span> t.stu_no, <span class="keyword">case</span> t.course_name <span class="keyword">when</span> <span class="string">'yuwen'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">when</span> <span class="string">'shuxue'</span> <span class="keyword">then</span> <span class="number">2</span> <span class="keyword">when</span> <span class="string">'yingyu'</span> <span class="keyword">then</span> <span class="number">3</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="拆分以逗号分隔的字符串为多行"><a href="#拆分以逗号分隔的字符串为多行" class="headerlink" title="拆分以逗号分隔的字符串为多行"></a>拆分以逗号分隔的字符串为多行</h4><ul><li>oracle参考下文<a href="#正则表达式">正则表达式 regexp_substr</a></li></ul><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>查询空格问题。如：<code>select * from test t where t.name = &#39;ABC&#39;;</code>和<code>select * from test t where t.name = &#39;ABC &#39;;</code>(后面有空格)结果一致，<code>ABC</code>和<code>ABC</code>都可以查询到数据库中<code>ABC</code>的数据<ul><li>使用like：<code>select * from test t where t.name like &#39;ABC&#39;;</code>(不要加%，<strong>使用<code>mybatis-plus</code>插件可开启字符串like查询</strong>)</li><li>使用关键字 binary：<code>select * from test t where t.name = binary&#39;ABC&#39;;</code></li><li>使用length：<code>select * from test t where t.name = &#39;ABC&#39; and length(t.name) = length(&#39;ABC&#39;);</code></li></ul></li><li>字段值不区分大小写问题(<strong>oracle默认区分大小写，sqlserver也不区分大小写</strong>)<ul><li>如果字段为<code>utf8_general_ci</code>存储时，可以在字段前加<code>binary</code>强行要求此字段进行二进制查询，即区分大小写。如<code>select * from</code>t_test<code>where binary username = &#39;aezocn&#39;</code></li><li>设置字段排序规则为<code>utf8_bin</code>(<code>utf8_general_ci</code>中<code>ci</code>表示case insensitive，即不区分大小写)。设置成<code>utf8_bin</code>只是说字段值中每一个字符用二进制数据存储，区分大小写，显示和查询并不是二进制</li></ul></li><li><code>null</code>判断问题<ul><li>判空需要使用<code>is null</code>或者<code>is not null</code></li><li><code>select * from t_test where username = &#39;smalle&#39; and create_tm &gt; &#39;2000-01-01&#39;</code> 直接使用 =、&gt; 等字符比较，包含了此字段不为空的含义</li><li><code>select * from t_test where (username is not null or username != &#39;&#39;)</code> 这样判断才能确保username不为空白字符串(<strong>oracle的<code>&#39;&#39;</code>和<code>null</code>相同，判断is not null即可</strong>)</li></ul></li><li><code>null</code>排序问题<ul><li>字段排序时，null默认最小</li><li><code>select * from t_test order by username is null, username asc;</code> 此时先按照是否为null进行排序，是空的排在下面(返回1)</li></ul></li><li>字段类型和大小<ul><li>varchar(10)表示可以显示10个字符，字符集utf8时一个中文为一个字符。mysql的utf8编码最大只能存放3个字节；utf8mb4中mb4指most bytes 4，因此最大可以存放4个字节。中文有可能占用2、3、4个字节</li></ul></li><li><strong><code>between...and</code> 左右边界都包含。</strong>当处理时间时(类型为datetime)，语句<code>between &#39;2018-10-01&#39; and &#39;2018-11-01&#39;</code>，实际执行<code>between 2018-10-01 00:00:00 and 2018-11-01 00:00:00</code>，从而少算了11-1的数据。解决办法<ul><li>写全时分秒，2018-10-01 00:00:00至2018-10-01 23:59:59</li><li>如果create_time类型为date(日期类型，而不是日期时间)，则使用between…and没什么问题</li><li><code>date_format(a.create_time,&#39;%Y-%m-%d&#39;) between &#39;2018-10-01&#39; and &#39;2018-11-01&#39;</code> 转成字符串进行比较</li><li><code>between &#39;2018-10-01&#39; and date_add(&#39;2018-11-01&#39;, interval 1 day)</code> 多算了2018-11-02 00:00:00这一秒中的数据</li></ul></li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="concat-concat-ws-group-concat"><a href="#concat-concat-ws-group-concat" class="headerlink" title="concat/concat_ws/group_concat"></a>concat/concat_ws/group_concat</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将多个字符串连接成一个字符串。任何一个值为null则整体为null</span></span><br><span class="line">concat(str1, str2,...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将多个字符串连接成一个字符串，但是可以一次性指定分隔符concat_ws就是concat with separator）</span></span><br><span class="line">concat_ws(separator, str1, str2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将group by产生的同一个分组中的值连接起来，返回一个字符串结果。类似oracle的wm_concat</span></span><br><span class="line"><span class="comment">-- 语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator '分隔符(默认为,)'] )</span></span><br><span class="line"><span class="keyword">select</span> userId, <span class="keyword">group_concat</span>(orderId <span class="keyword">order</span> <span class="keyword">by</span> orderId <span class="keyword">desc</span> separator <span class="string">';'</span>) <span class="keyword">as</span> orderList <span class="keyword">from</span> t_orders <span class="keyword">group</span> <span class="keyword">by</span> userId;</span><br></pre></td></tr></table></figure><h4 id="instr-find-in-set"><a href="#instr-find-in-set" class="headerlink" title="instr/find_in_set"></a>instr/find_in_set</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- instr</span></span><br><span class="line">    <span class="comment">-- linux/unix下的行结尾符号是`\n`，windows中的行结尾符号是`\r\n`，Mac系统下的行结尾符号是`\r`</span></span><br><span class="line">    <span class="comment">-- 回车符：\r=0x0d (13) (carriage return)</span></span><br><span class="line">    <span class="comment">-- 换行符：\n=0x0a (10) (newline)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_test <span class="keyword">where</span> <span class="keyword">instr</span>(username, <span class="built_in">char</span>(<span class="number">13</span>)) &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">instr</span>(username, <span class="built_in">char</span>(<span class="number">10</span>)) &gt; <span class="number">0</span>; <span class="comment">-- 查找表中某字段含有`\r\n`的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- find_in_set</span></span><br><span class="line">    <span class="comment">-- type字段表示：1头条、2推荐、3热点。现在有一篇文章即是头条又是热点，即type=1,2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> find_in_set(<span class="string">'2'</span>, <span class="keyword">type</span>); <span class="comment">-- 找出所有热点的文章</span></span><br></pre></td></tr></table></figure><h4 id="日期-1"><a href="#日期-1" class="headerlink" title="日期"></a>日期</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sysdate</span></span><br><span class="line"><span class="keyword">update</span> t_test t <span class="keyword">set</span> t.update_tm = <span class="keyword">sysdate</span>() <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">-- 其中`sysdate()`可获取当前时间</span></span><br></pre></td></tr></table></figure><h4 id="with-as"><a href="#with-as" class="headerlink" title="with as"></a>with as</h4><ul><li>参考下文<a href="#with%20as%20用法">with as 用法</a></li></ul><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><ul><li>自定义变量的限制<ul><li>无法使用查询缓存</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句</li><li>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</li><li>不能显式地声明自定义变量地类型</li><li>mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行</li><li>赋值符号：=的优先级非常低，所以在使用赋值表达式的时候应该明确的使用括号</li><li>使用未定义变量不会产生任何语法错误</li><li>用户自定义变量只在session有效，退出后数据丢失</li></ul></li><li><p>自定义变量的使用案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自定义变量的使用(@@为系统自定义变量)</span></span><br><span class="line"><span class="keyword">set</span> @one :=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> @one;</span><br><span class="line"><span class="keyword">set</span> @min_actor :=(<span class="keyword">select</span> <span class="keyword">min</span>(actor_id) <span class="keyword">from</span> actor);</span><br><span class="line"><span class="keyword">set</span> @last_week :=(<span class="keyword">current_date</span>-<span class="built_in">interval</span> <span class="number">1</span> <span class="keyword">week</span>);</span><br><span class="line"><span class="comment">-- 在给一个变量赋值的同时使用这个变量</span></span><br><span class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span>:=@<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">rownum</span> <span class="keyword">from</span> actor <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 避免重新查询刚刚更新的数据。eg:当需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么</span></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> lastUpdated=<span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> lastUpdated <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 优化后：避免重新查询刚刚更新的数据</span></span><br><span class="line"><span class="keyword">update</span> t1 <span class="keyword">set</span> lastupdated = <span class="keyword">now</span>() <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> @<span class="keyword">now</span>:=<span class="keyword">now</span>();</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">now</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意where和select在查询的不同阶段执行</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span>:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span>:=@<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> @<span class="keyword">rownum</span>&lt;=<span class="number">1</span>; <span class="comment">-- 有问题的</span></span><br><span class="line"><span class="keyword">select</span> actor_id,@<span class="keyword">rownum</span> <span class="keyword">as</span> cnt <span class="keyword">from</span> actor <span class="keyword">where</span> (@<span class="keyword">rownum</span>:=@<span class="keyword">rownum</span>+<span class="number">1</span>)&lt;=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="JSON数据类型"><a href="#JSON数据类型" class="headerlink" title="JSON数据类型"></a>JSON数据类型</h3><ul><li>参考官网：<a href="https://dev.mysql.com/doc/refman/5.7/en/json.html、https://dev.mysql.com/doc/refman/5.7/en/json-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/json.html、https://dev.mysql.com/doc/refman/5.7/en/json-functions.html</a></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据类型为json的字段val（如果字段类型为字符串也是可以使用相关函数的，只不过存在隐式转换；且如果类型是json，则在插入数据时会进行格式校验）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (val <span class="keyword">json</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(val) <span class="keyword">values</span>(<span class="string">'&#123;"name": "smalle", "hello": "Hi, \\"AEZO\\"", "hobby": [&#123;"item": &#123;"name": "book", "weight": 5&#125;&#125;, "game"], "attr": &#123;"t1": "v1", "t2": [1, true, false]&#125;&#125;'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "attr": &#123;</span></span><br><span class="line"><span class="comment">    "t1": "v1",</span></span><br><span class="line"><span class="comment">    "t2": [</span></span><br><span class="line"><span class="comment">      1,</span></span><br><span class="line"><span class="comment">      true,</span></span><br><span class="line"><span class="comment">      false</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  "name": "smalle",</span></span><br><span class="line"><span class="comment">  "hello": "Hi, \"AEZO\"",</span></span><br><span class="line"><span class="comment">  "hobby": [</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      "item": &#123;</span></span><br><span class="line"><span class="comment">        "name": "book",</span></span><br><span class="line"><span class="comment">        "weight": 5</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    "game"</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> val <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- &#123;"attr": &#123;"t1": "v1", "t2": [1, true, false]&#125;, "name": "smalle", "hello": "Hi, \"aezo\"", "hobby": [&#123;"item": &#123;"name": "book", "weight": 5&#125;&#125;, "game"]&#125;</span></span><br><span class="line"><span class="comment">-- 可以使用column-path运算符 -&gt;</span></span><br><span class="line"><span class="keyword">select</span> val-&gt;<span class="string">"$.hello"</span> <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- "hi, \"aezo\""</span></span><br><span class="line"><span class="comment">-- 或内联路径运算符 -&gt;&gt; (去掉了引号和转义符)。可能由于服务器no_backslash_escapes的配置导致无法使用 -&gt;&gt;，可如下使用json_unquote()</span></span><br><span class="line"><span class="keyword">select</span> val-&gt;&gt;<span class="string">"$.hello"</span> <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- hi, "aezo"</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(val-&gt;<span class="string">"$.hello"</span>) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- hi, "aezo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val, <span class="string">'$.*'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 将所有一级key对应的值放入到数组中：[&#123;"t1": "v1", "t2": [1, true, false]&#125;, "smalle", "Hi, \"AEZO\"", [&#123;"item": &#123;"name": "book", "weight": 5&#125;&#125;, "game"]]</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val, <span class="string">'$.name'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- smalle</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val, <span class="string">'$.hobby[0].item'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- &#123;"name": "book", "weight": 5&#125;</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val, <span class="string">'$**.name'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 返回所有最底相应key值：["smalle", "book"]</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val, <span class="string">'$.hobby[*].item.*'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- ["book", 5]</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(val-&gt;<span class="string">'$.hobby'</span>, <span class="string">'$[0].item.name'</span>)) <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- book</span></span><br><span class="line"><span class="keyword">select</span> json_unquote(json_extract(<span class="string">'[1, 2, 3]'</span>, <span class="string">'$[0]'</span>)); <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果存放json的字段类型为字符串，取出数据时可进行转换编码</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">convert</span>(json_unquote(json_extract(<span class="string">'["张三", "李四"]'</span>, <span class="string">'$[0]'</span>)) <span class="keyword">using</span> utf8mb4); <span class="comment">-- 张三</span></span><br></pre></td></tr></table></figure><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="decode和case-when"><a href="#decode和case-when" class="headerlink" title="decode和case when"></a>decode和case when</h4><ul><li><code>decode(被判断表达式, 值1, 转换成值01, 值2, 转换成值02, ..., 转换成默认值)</code> 只能判断=，不能判断like(like可考虑case when)<ul><li><code>select decode(length(ys.ycross_x), 1, &#39;0&#39; || ys.ycross_x, ys.ycross_x) from ycross_storage ys</code> 如果ys.ycross_x的长度为1那就在前面加0，否则取本身</li><li><code>select sum(decode(shipcomp.company_num, &#39;CMA&#39;, 1, 0)) cma, sum(decode(shipcomp.company_num, &#39;MSK&#39;, 1, 0)) msk from ycross_in_out_regist yior ...(省略和shipcomp的关联)</code> 统计进出场记录中cma和msk的数量</li><li><code>order by decode(col, &#39;b&#39;, 1, &#39;c&#39;, 2, &#39;a&#39;, 3, col)</code> 按值排序</li></ul></li><li><code>case when then [when then ...] else end</code> 比decode强大<ul><li><code>case when t.name = &#39;admin&#39; then &#39;admin&#39; when t.name like &#39;admin%&#39; then &#39;admin_user&#39; else decode(t.role, &#39;admin&#39;, &#39;admin&#39;, &#39;admin_user&#39;) end</code></li><li><code>sum(case when yior.plan_classification_code = &#39;Empty_Temporary_Fall_Into_Play&#39; and yardparty.company_num = &#39;DW1&#39; then 1 end) as count_dw1</code> sum写在case里面则需要对相关字段(plan_classification_code)进行group by，而sum写外面则不需要对此字段group by. <strong>主要用于分组之后根据条件分列显示</strong></li></ul></li></ul><h4 id="grouping-rollup"><a href="#grouping-rollup" class="headerlink" title="grouping rollup"></a>grouping rollup</h4><ul><li><a href="http://blog.csdn.net/damenggege123/article/details/38794351" target="_blank" rel="noopener">http://blog.csdn.net/damenggege123/article/details/38794351</a></li></ul><h4 id="trunc时间处理"><a href="#trunc时间处理" class="headerlink" title="trunc时间处理"></a>trunc时间处理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span><span class="number">-1</span>, <span class="string">'dd'</span>), trunc(<span class="keyword">sysdate</span>, <span class="string">'dd'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 返回昨天和今天（2018-01-01, 2018-01-02）</span></span><br></pre></td></tr></table></figure><h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语法 select trim(leading | trailing | both string1 from string2) from dual;</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="string">' a b '</span>) <span class="keyword">from</span> dual; <span class="comment">-- "a b"</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(<span class="keyword">leading</span> <span class="string">'a'</span> <span class="keyword">from</span> <span class="string">'aa ab '</span>) <span class="keyword">from</span> dual; <span class="comment">-- " ab "</span></span><br><span class="line"><span class="comment">-- 同理ltrim去除左侧空格；ltrim/rtrim 还支持第二个参数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rtrim</span>(<span class="string">' a b '</span>) <span class="keyword">from</span> dual; <span class="comment">-- " a b"</span></span><br></pre></td></tr></table></figure><h4 id="with-as-用法"><a href="#with-as-用法" class="headerlink" title="with as 用法"></a>with as 用法</h4><ul><li>特点<ul><li>特别是从多张表中取数据时，而且每张表的数据量又很大时，使用with写法可以先筛选出来一张数据量较少的表，避免全表join</li><li>可认为在真正进行查询之前预先构造了一个临时表，之后便可多次使用它做进一步的分析和处理。一次分析，多次使用</li></ul></li><li>mysql版本在8.0之前不能使用with的写法；8.0之后写法同oracle</li><li>语法(oracle/mysql均支持)<ul><li>前面的with子句定义的查询在后面的with子句中可以使用，但是一个with子句内部不能嵌套with子句</li><li>from后面必须直接紧跟使用with as出来的表，否则需要使用join将with as出来的表关联进来；在子查询中也是这样</li><li>with必须开头，不能出现<code>select 1 from dual union all with ...</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 针对多个别名，e,d为“别名表”</span></span><br><span class="line">with</span><br><span class="line">     e as (<span class="keyword">select</span> * <span class="keyword">from</span> scott.emp),</span><br><span class="line">     d <span class="keyword">as</span> (<span class="keyword">select</span> * <span class="keyword">from</span> scott.dept)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> e, d <span class="keyword">where</span> e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- from后面必须直接紧跟使用with as出来的表，否则需要使用join将with as出来的表关联进来</span></span><br><span class="line">with temp as (<span class="keyword">select</span> t.create_tm <span class="keyword">from</span> <span class="keyword">user</span> t <span class="keyword">where</span> t.id = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">select</span> temp.*</span><br><span class="line"><span class="keyword">from</span> dual <span class="comment">-- from其他表时，必需要使用join将with as出来的表关联进来</span></span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> temp <span class="keyword">on</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> temp.create_tm &gt; <span class="keyword">sysdate</span><span class="number">-7</span>;</span><br><span class="line"></span><br><span class="line">WITH</span><br><span class="line">ASSIGN(ID, ASSIGN_AMT) AS (</span><br><span class="line">                <span class="keyword">SELECT</span> <span class="number">1</span>, <span class="number">25150</span> <span class="keyword">FROM</span> DUAL </span><br><span class="line">    <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> <span class="number">2</span>, <span class="number">19800</span> <span class="keyword">FROM</span> DUAL</span><br><span class="line">    <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> <span class="number">3</span>, <span class="number">27511</span> <span class="keyword">FROM</span> DUAL</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ASSIGN;</span><br></pre></td></tr></table></figure><h4 id="聚合函数-aggregate-function"><a href="#聚合函数-aggregate-function" class="headerlink" title="聚合函数(aggregate_function)"></a>聚合函数(aggregate_function)</h4><ul><li><code>min</code>、 <code>max</code>、<code>sum</code>、<code>avg</code>、<code>count</code>、<code>variance</code>、<code>stddev</code></li><li><code>count(*)</code>、<code>count(1)</code>、<code>count(id)</code>、<code>count(name)</code> <strong>统计行数，不能统计值的个数</strong>。count(name)，如果有3行，但是name有值的只有2行时结果仍然为3</li></ul><h5 id="wm-concat行转列"><a href="#wm-concat行转列" class="headerlink" title="wm_concat行转列"></a>wm_concat行转列</h5><ul><li>行转列，会把多行转成1行(默认用<code>,</code>分割，select的其他字段需要是group by字段)</li><li>自从oracle <strong><code>11.2.0.3</code></strong> 开始<code>wm_concat</code>返回的是clob字段，需要通过to_char转换成varchar类型 <a href="https://www.smwenku.com/a/5b8dd9d82b71771883410ce1/" target="_blank" rel="noopener">^8</a><ul><li>如果长度超过4000个字符，使用to_char会报错缓冲区不足，可以使用 <code>xmlagg</code> 函数代替。参考：<a href="https://www.cxybb.com/article/qq_28356739/88626952" target="_blank" rel="noopener">https://www.cxybb.com/article/qq_28356739/88626952</a><ul><li>druid使用内置SQL解析工具类时，无法解析此函数，参考：<a href="https://github.com/alibaba/druid/issues/4259" target="_blank" rel="noopener">https://github.com/alibaba/druid/issues/4259</a></li></ul></li><li>clob直接返回到前台会报错<ul><li>可通过<code>clob.getSubString(1, (int) clob.length())</code>解决</li><li>或者使用jackson转换器，参考：<a href="https://oomake.com/question/13622930、https://segmentfault.com/a/1190000040484998" target="_blank" rel="noopener">https://oomake.com/question/13622930、https://segmentfault.com/a/1190000040484998</a></li></ul></li></ul></li><li><code>select replace(to_char(wm_concat(name)), &#39;,&#39;, &#39;|&#39;) from test;</code>替换分割符</li></ul><h5 id="xmlagg行转列"><a href="#xmlagg行转列" class="headerlink" title="xmlagg行转列"></a>xmlagg行转列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">xmlagg</span>(xmlparse(<span class="keyword">content</span> 合并字段 || <span class="string">','</span> <span class="keyword">wellformed</span>) <span class="keyword">order</span> <span class="keyword">by</span> 排序字段).getclobval() <span class="string">"my_col"</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h5 id="listagg-within-group行转列"><a href="#listagg-within-group行转列" class="headerlink" title="listagg within group行转列"></a>listagg within group行转列</h5><ul><li>mysql可使用group_concat</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询部门为20的员工列表</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	t.deptno,</span><br><span class="line">    <span class="comment">-- listagg 可理解为wm_concat；而 within group 表示对每一组的元素进行操作，此时是基于 t.ename 进行排序(即排序后再调用listagg)</span></span><br><span class="line">	<span class="keyword">listagg</span>(t.ename, <span class="string">','</span>) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span> <span class="keyword">by</span> t.ename) <span class="keyword">names</span> <span class="comment">-- 返回 ADAMS,FORD,JONES 即将多行显示在一列中</span></span><br><span class="line"><span class="keyword">from</span> scott.emp t</span><br><span class="line"><span class="keyword">where</span> t.deptno = <span class="string">'20'</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t.deptno</span><br></pre></td></tr></table></figure><h4 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h4><h5 id="常见分析函数-3"><a href="#常见分析函数-3" class="headerlink" title="常见分析函数 ^3"></a>常见分析函数 <a href="http://www.cnblogs.com/linjiqin/archive/2012/04/06/2434806.html" title="分析函数3" target="_blank" rel="noopener">^3</a></h5><ul><li><code>min</code>、 <code>max</code>、<code>sum</code>、<code>avg</code> <strong>一般和over/keep函数联合使用</strong></li><li><code>first_value(字段名)</code>、<code>last_value(字段名)</code> <strong>和over函数联合使用</strong></li><li><code>row_number()</code>、<code>dense_rank()</code>、<code>rank()</code>：为每条记录产生一个从1开始至n的自然数，n的值可能小于等于记录的总数(基于相应order by字段的值来判断)。这3个函数的唯一区别在于当碰到相同数据时的排名策略。<strong>和over函数联合使用</strong><ul><li><code>row_number</code> 当碰到相同数据时，排名按照记录集中记录的顺序依次递增(如：1-2-3-4-5-6)</li><li><code>dense_rank</code> 当碰到相同数据时，此时所有相同数据的排名都是一样的(如：1-2-3-3-3-4. <strong>如果被排序字段的值相等则认为排名相同</strong>)</li><li><code>rank</code> 当碰到相同的数据时，此时所有相同数据的排名是一样的，同时会在最后一条相同记录和下一条不同记录的排名之间空出排名(如：1-2-3-3-3-6)</li></ul></li><li><code>lag()</code>、<code>lead()</code> 求之前或之后的第N行。lag和lead函数可以在一次查询中取出同一字段的前n行的数据和后n行的值。这种操作可以使用对相同表的表连接来实现，不过使用lag和lead有更高的效率。<strong>和over函数联合使用</strong><ul><li>lag(列名, 偏移的offset, 超出记录窗口时的默认值)</li></ul></li><li><code>rollup()</code>、<code>cube()</code> 排列组合分组。<strong>和group by联合使用</strong><ul><li><code>group by rollup(a, b, c)</code>：首先会对(a、b、c)进行group by，然后再对(a、b)进行group by，其后再对(a)进行group by，最后对全表进行汇总操作</li><li><code>group by cube(a, b, c)</code>： 首先会对(a、b、c)进行group by，然后依次是(a、b)，(a、c)，(a)，(b、c)，(b)，(c)，最后对全表进行汇总操作</li></ul></li></ul><h5 id="connect-by-递归关联"><a href="#connect-by-递归关联" class="headerlink" title="connect by 递归关联"></a>connect by 递归关联</h5><ul><li><code>start with connect by prior</code> 递归查询(如树形结构)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> my_table t </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> t.pid = <span class="number">1</span> <span class="comment">-- 基于此条件进行向下查询(省略则表示基于全表为根节点向下查询，可能会有重复数据)</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">nocycle</span> <span class="comment">-- 递归条件(递归查询不支持环形。此处nocycle表示忽略环，如果确认结构中无环形则可省略。有环形则必须加，否则报错)</span></span><br><span class="line"><span class="keyword">prior</span> t.id = t.pid <span class="comment">-- 增加递归条件，或者 add prior。也可自递归，如 t.id = t.id</span></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">prior</span> <span class="keyword">level</span> &lt;= regexp_count(t.names, <span class="string">'[^,]+'</span>) <span class="comment">-- level为当前递归层级(顶层为1)，此条件无实际意义，仅为了展示其语法功能</span></span><br><span class="line"><span class="keyword">where</span> t.valid_status = <span class="number">1</span>; <span class="comment">-- 将递归获取到的数据再次过滤</span></span><br></pre></td></tr></table></figure><h5 id="over"><a href="#over" class="headerlink" title="over"></a>over</h5><ul><li>分析函数和聚合函数的不同之处是什么：普通的聚合函数用<strong>group by分组，每个分组返回一个统计值</strong>，而分析函数采用<strong>partition by分组，并且每组每行都可以返回一个统计值</strong> <a href="http://www.cnblogs.com/linjiqin/archive/2012/04/04/2431975.html" title="分析函数1" target="_blank" rel="noopener">^1</a></li><li><p>开窗函数<code>over()</code>，跟在分析函数之后，包含三个分析子句。形式如：<code>over(partition by xxx order by yyy rows between aaa and bbb)</code> <a href="http://www.cnblogs.com/linjiqin/archive/2012/04/05/2433633.html" title="分析函数2" target="_blank" rel="noopener">^2</a></p><ul><li>子句类型<ul><li>分组(partition by)</li><li>排序(order by)</li><li>窗口(rows)：窗口子句包含rows、range和滑动窗口<ul><li>窗口子句不能单独出现，必须有<code>order by</code>子句时才能出现</li><li>取值说明<ul><li><code>unbounded preceding</code> 第一行</li><li><code>current row</code> 当前行</li><li><code>unbounded following</code> 最后一行</li></ul></li></ul></li></ul></li><li>省略分组字句：则把全部记录当成一个组<ul><li>如果此时存在<code>order by</code>，则窗口默认(省略窗口时)为当前组的第一行到当前行(unbounded preceding and current row)</li><li>如果此时不存在<code>order by</code>，则窗口默认为整个组(unbounded preceding and unbounded following)</li></ul></li><li><p>省略窗口字句</p><ul><li>出现<code>order by</code>子句的时候，不一定要有窗口子句(窗口子句不能单独出现，必须有<code>order by</code>子句时才能出现)</li><li>如果此时存在<code>order by</code>，则窗口默认是当前组的第一行到当前行</li><li>如果此时不存在<code>order by</code>，则窗口默认是整个组</li><li><p>示例（示例和图片来源：<a href="http://www.cnblogs.com/linjiqin/archive/2012/04/05/2433633.html）" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/archive/2012/04/05/2433633.html）</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 见图oracle-over-1：窗口默认为整个组</span></span><br><span class="line"><span class="keyword">select</span> deptno, empno, ename, sal, <span class="keyword">last_value</span>(sal) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 见图oracle-over-2：窗口默认为第一行到当前行</span></span><br><span class="line"><span class="keyword">select</span> deptno, empno, ename, sal, <span class="keyword">last_value</span>(sal) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><ul><li><p>oracle-over-1</p><p><img src="/data/images/db/oracle-over-1.png" alt="oracle-over-1"></p></li><li><p>oracle-over-2</p><p><img src="/data/images/db/oracle-over-2.png" alt="oracle-over-2"></p></li></ul></li></ul></li><li><p>两个<code>order by</code>的执行时机</p><ul><li>两者一致：如果sql语句中的order by满足分析函数分析时要求的排序，那么sql语句中的排序将先执行，分析函数在分析时就不必再排序</li><li>两者不一致：如果sql语句中的order by不满足分析函数分析时要求的排序，那么sql语句中的排序将最后在分析函数分析结束后执行排序</li></ul></li></ul></li><li>使用示例</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询有移动任务的场存，并获取每个场存需要移动的次数和最早一次移动计划的id</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> ys.id</span><br><span class="line">        ,<span class="keyword">count</span>(yvmp.venue_move_plan_id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ys.id) <span class="keyword">as</span> total</span><br><span class="line">        ,<span class="keyword">first_value</span>(yvmp.venue_move_plan_id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> yvmp.storage_id <span class="keyword">order</span> <span class="keyword">by</span> yvmp.input_tm <span class="keyword">ASC</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) <span class="keyword">as</span> first_id</span><br><span class="line">    <span class="keyword">from</span> ycross_storage ys <span class="comment">-- 场存表</span></span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> yyard_venue_move_plan yvmp <span class="comment">-- 移动表</span></span><br><span class="line">        <span class="keyword">on</span> yvmp.storage_id = ys.id <span class="keyword">and</span> yvmp.yes_status = <span class="number">0</span></span><br><span class="line">  ) t</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> t.id, t.total, t.first_id</span><br></pre></td></tr></table></figure><h6 id="over使用误区"><a href="#over使用误区" class="headerlink" title="over使用误区"></a>over使用误区</h6><ul><li><p>主表行数并不会减少(普通的聚合函数用group by分组，<strong>每个分组返回一个统计值</strong>，而分析函数采用partition by分组，并且<strong>每组每行都可以返回一个统计值</strong></p><ul><li><p>查询每个客户每种拜访类型最近的一次拜访</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ========= 原始数据</span></span><br><span class="line"><span class="comment">-- 原始拜访表数据(部分)</span></span><br><span class="line"><span class="keyword">select</span> v.id, v.visit_type, v.customer_id, v.comments, v.visit_tm</span><br><span class="line"><span class="keyword">from</span> t_visit v </span><br><span class="line"><span class="keyword">where</span> v.result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">and</span> v.valid_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">and</span> v.customer_id = <span class="number">358330</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> v.visit_type, v.id <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">#   </span><br><span class="line">1	93179	BS	358330	BS-3	2018/9/20</span><br><span class="line">2	93165	BS	358330	BS-2	2018/9/21</span><br><span class="line">3	93164	BS	358330	BS-1	2018/9/21</span><br><span class="line">4	93252	IS	358330	IS-2	2018/10/8</span><br><span class="line">5	27094	IS	358330	IS-1	2017/11/9</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ========= 统计语句</span></span><br><span class="line"><span class="comment">-- *********错误sql一*********。(和group by混淆)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> rn</span><br><span class="line"><span class="comment">-- *********错误sql一*********</span></span><br><span class="line">,<span class="keyword">first_value</span>(v.id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="keyword">id</span> <span class="comment">-- 只取一个ID也是重复的</span></span><br><span class="line">,<span class="keyword">first_value</span>(v.customer_id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> customer_id</span><br><span class="line">,<span class="keyword">first_value</span>(v.visit_type) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> visit_type</span><br><span class="line">,<span class="keyword">first_value</span>(v.comments) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> comments</span><br><span class="line">,<span class="keyword">first_value</span>(v.visit_tm) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> visit_tm</span><br><span class="line"><span class="keyword">from</span> t_visit v</span><br><span class="line"><span class="keyword">where</span> v.valid_status = <span class="number">1</span> <span class="keyword">and</span> v.result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> </span><br><span class="line"><span class="keyword">and</span> v.customer_id = <span class="number">358330</span>;</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">#   </span><br><span class="line">1	1	93179	358330	BS	BS-3	2018/9/20</span><br><span class="line">2	2	93179	358330	BS	BS-3	2018/9/20</span><br><span class="line">3	3	93179	358330	BS	BS-3	2018/9/20</span><br><span class="line">4	1	93252	358330	IS	IS-2	2018/10/8</span><br><span class="line">5	2	93252	358330	IS	IS-2	2018/10/8</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *********错误sql二*********。此时报max(v.id)中的id不是group by字句（使用keep的话也会有这个错）</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">max</span>(v.id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id, v.visit_type <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="keyword">id</span> <span class="comment">-- max(v.id)：ORA-00979 not a group by expression</span></span><br><span class="line"><span class="comment">-- *********错误sql一*********</span></span><br><span class="line"><span class="keyword">from</span> t_visit v</span><br><span class="line"><span class="keyword">where</span> v.valid_status = <span class="number">1</span> <span class="keyword">and</span> v.result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> </span><br><span class="line"><span class="keyword">and</span> v.customer_id = <span class="number">358330</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> v.customer_id, v.visit_type</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可再次group by；或者使用row_number()再加子查询rn=1获取最大最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- =============== 使用 Keep ===============</span></span><br><span class="line"><span class="comment">-- Keep测试一(基于主表group by)。参考下文[keep](#keep)</span></span><br><span class="line"><span class="comment">-- Keep测试二(基于over的partition by)。参考下文[keep](#keep)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="keep-6"><a href="#keep-6" class="headerlink" title="keep ^6"></a>keep <a href="https://lanjingling.github.io/2015/10/09/oracle-fenxihanshu-3/" target="_blank" rel="noopener">^6</a></h5><ul><li>keep的用法不同于通过over关键字指定的分析函数，可以用于这样一种场合下：<strong>取同一个分组下以某个字段排序后，对指定字段取最小或最大的那个值。</strong>从这个前提出发，我们可以看到其实这个目标通过一般的row_number分析函数也可以实现，即指定rn=1。但是，该函数无法实现同时获取最大和最小值。或者说用first_value和last_value，结合row_number实现，但是该种方式需要多次使用分析函数，而且还需要套一层SQL。于是出现了keep</li><li><p>语法 <a href="https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions065.htm#SQLRF00641" title="oracle doc: keep" target="_blank" rel="noopener">^5</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aggregate_function <span class="comment">-- 聚合函数</span></span><br><span class="line">KEEP (</span><br><span class="line">    DENSE_RANK &#123; FIRST | LAST &#125; </span><br><span class="line">    ORDER BY expr [ DESC | ASC ] [ NULLS &#123; FIRST | LAST &#125; ] [, expr [ DESC | ASC ] [ NULLS &#123; FIRST | LAST &#125; ]]...</span><br><span class="line">) </span><br><span class="line">[ OVER ( [query_partition_clause] ) ]</span><br></pre></td></tr></table></figure><ul><li>最前是聚合函数，可以是min、max、avg、sum</li><li><code>dense_rank first</code>，<code>dense_rank last</code>为keep函数的保留属性<ul><li>dense_rank first 表示取分组-排序结果集中第一个(dense_rank值排第一的。可能有几行数据排序值一样，此时再可配合min/max等聚合函数取值)</li><li>dense_rank last 同理，为最后一个</li></ul></li></ul></li><li><strong>Keep测试一(基于主表group by，如取最大最小值)</strong>，场景参考上文<a href="#over使用误区">over使用误区</a></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- *****Keep测试一(基于主表group by)*****：如查分组中最新的数据(非分组字段通过keep获取，如果同最近的ID再次管理表则效率低一些)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">v.customer_id, v.visit_type</span><br><span class="line"><span class="comment">-- 在每一组中按照v.visit_tm排序计数(BS那一组排序值为 1-1-2. 因为存在两个拜访时间2018/9/21一样，因此排序值都为1，当遇到不同排序值+1)，并取第一排序集(1-1的两条记录)中v.id最大的</span></span><br><span class="line">,<span class="keyword">max</span>(v.id) <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> v.visit_tm <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="keyword">id</span></span><br><span class="line">,<span class="keyword">max</span>(v.visit_tm) <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> v.visit_tm <span class="keyword">desc</span>) <span class="keyword">as</span> visit_tm</span><br><span class="line">,<span class="keyword">max</span>(v.comments) <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> v.visit_tm <span class="keyword">desc</span>) <span class="keyword">as</span> comments</span><br><span class="line"><span class="comment">-- 排序值为 1-2-3</span></span><br><span class="line">,<span class="keyword">max</span>(v.visit_tm) <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> v.id <span class="keyword">desc</span>) <span class="keyword">as</span> visit_tm_id</span><br><span class="line"><span class="keyword">from</span> t_visit v</span><br><span class="line"><span class="keyword">where</span> v.valid_status = <span class="number">1</span> <span class="keyword">and</span> v.result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> </span><br><span class="line"><span class="keyword">and</span> v.customer_id = <span class="number">358330</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> v.customer_id, v.visit_type; <span class="comment">-- 先分成了两组(最终只有两组的统计值，两行数据)</span></span><br><span class="line"><span class="comment">-- 结果(注意第一行数据)</span></span><br><span class="line">#</span><br><span class="line">1	358330	BS	93165	2018/9/21	BS-2	2018/9/20</span><br><span class="line">2	358330	IS	93252	2018/10/8	IS-2	2018/10/8</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：查询每个提单CN1101的发送情况：可在max和keep语句中使用case when进行分组后数据过滤</span></span><br><span class="line"><span class="keyword">select</span> sb.bill_no</span><br><span class="line">    <span class="comment">-- max中不能省略case when过滤：否则可能其他提单也会显示成了最大的一个eh.id对应的值，因为每一组bill_no都对应了所有的子表数据，此时加case when可进行过滤</span></span><br><span class="line">    ,<span class="keyword">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> eh.edi_code = <span class="string">'CN1101'</span> <span class="keyword">and</span> ell.bill_nbr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> eh.send_method <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">end</span>)</span><br><span class="line">    <span class="comment">-- keep中不能省略case when过滤：否则取到的第一组永远是最大的一个eh.id，可能是其他提单发送的</span></span><br><span class="line">    <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">case</span> <span class="keyword">when</span> eh.edi_code = <span class="string">'CN1101'</span> <span class="keyword">and</span> ell.bill_nbr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> eh.id <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">end</span> <span class="keyword">desc</span>) <span class="keyword">as</span> edi_send_method</span><br><span class="line"><span class="keyword">FROM</span> ship_bill sb</span><br><span class="line">    <span class="comment">-- 一个提单可能存在CN1101、IFCTST两种EDI，且此时是基于船号进行关联，从而可能会关联到其他提单的发送记录</span></span><br><span class="line">    <span class="comment">-- 此处不能使用join，否则业务上可能漏掉了提单</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s_edi_head eh <span class="keyword">ON</span> eh.business_no = sb.ship_no <span class="keyword">and</span> eh.valid_status = <span class="number">1</span> <span class="keyword">and</span> eh.edi_code <span class="keyword">in</span> (<span class="string">'CN1101'</span>, <span class="string">'IFCTST'</span>)</span><br><span class="line">    <span class="comment">-- 一个报文中包含的提单</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> edi_log_bill ell <span class="keyword">ON</span> ell.edi_id = eh.id <span class="keyword">and</span> sb.bill_nbr = ell.bill_nbr</span><br><span class="line"><span class="keyword">WHERE</span> sb.ship_no = <span class="number">55265</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sb.bill_no</span><br></pre></td></tr></table></figure><ul><li><p>Keep测试二(基于over的partition by)，场景参考上文<a href="#over使用误区">over使用误区</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个客户的默认地址：t_customer数据条数 28.9w, t_customer_address数据条数 36.8w。(注：此测试实际场景为两张表除了主键，无其他外键和索引)</span></span><br><span class="line"><span class="keyword">select</span> tmp_page.*, <span class="keyword">rownum</span> row_id <span class="keyword">from</span> ( <span class="comment">-- 分页</span></span><br><span class="line">  <span class="keyword">select</span> t.* <span class="keyword">from</span> ( <span class="comment">-- 写法 2(推荐)</span></span><br><span class="line">    <span class="keyword">select</span> c.customer_name_cn</span><br><span class="line">      <span class="comment">--,ca.address -- 写法 1</span></span><br><span class="line">      ,<span class="keyword">max</span>(ca.address) <span class="keyword">keep</span>(<span class="keyword">dense_rank</span> <span class="keyword">first</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">decode</span>(ca.address_type, <span class="string">'Default'</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> c.id) <span class="keyword">as</span> address <span class="comment">-- 写法 2</span></span><br><span class="line">    <span class="keyword">from</span> t_customer c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> t_customer_address ca <span class="keyword">on</span> ca.valid_status = <span class="number">1</span> <span class="keyword">and</span> c.id = ca.customer_id <span class="comment">-- 写法 2</span></span><br><span class="line">    <span class="comment">/*  -- 写法 1</span></span><br><span class="line"><span class="comment">    -- 也曾尝试把子查询视图管理再主查询where之后（将主查询包裹一层再和此子查询关联），没有任何改观</span></span><br><span class="line"><span class="comment">    left join (select ca.customer_id,</span></span><br><span class="line"><span class="comment">                -- 需要根据客户地址类型排序，是导致子查询效率低的重要原因</span></span><br><span class="line"><span class="comment">                max(ca.address) keep(dense_rank first order by decode(ca.address_type, 'Default', 1, 2)) as address</span></span><br><span class="line"><span class="comment">              from t_customer_address ca</span></span><br><span class="line"><span class="comment">              -- 写法1优化：通过查询主表(条件过滤之后会很少)在子查询内部过滤，主查询条件如果很多则所有的条件都需要写两遍，烦杂</span></span><br><span class="line"><span class="comment">              --join t_customer c on c.id = ca.customer_id and c.valid_status = 1</span></span><br><span class="line"><span class="comment">              where ca.valid_status = 1</span></span><br><span class="line"><span class="comment">              group by ca.customer_id) ca </span></span><br><span class="line"><span class="comment">        on ca.customer_id = c.id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">where</span> c.valid_status = <span class="number">1</span> <span class="comment">-- and c.customer_name_cn = 'XXX有限公司' -- 只有一条此数据。加上次条件后写法1的分页需要 10s，写法2的分页只需 0.09s </span></span><br><span class="line">  ) t <span class="keyword">group</span> <span class="keyword">by</span> t.customer_name_cn, t.address <span class="comment">-- 写法 2（去重。此处必须套一层select去重。在里面加group by，语法层面ca.address、ca.address_type、ca.id都需要在group by字句中，则起不到去重效果）</span></span><br><span class="line">) tmp_page <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">20</span> <span class="comment">-- 分页</span></span><br></pre></td></tr></table></figure><ul><li><p>写法 1</p><ul><li><p>不使用分页执行计划。耗时 <strong>3.5s</strong> (PL/SQL自动分页显示20行)</p><p><img src="/data/images/db/oracle-keep-1.png" alt="oracle-keep-1"></p></li><li><p>使用分页执行计划。耗时 <strong>4.2s</strong> (为什么分页导致效率变低？？？)</p><p><img src="/data/images/db/oracle-keep-2.png" alt="oracle-keep-2"></p></li></ul></li><li><p>写法 2</p><ul><li><p>不使用分页执行计划。耗时 <strong>0.8s</strong> (PL/SQL自动分页显示20行)</p><p><img src="/data/images/db/oracle-keep-3.png" alt="oracle-keep-3"></p></li><li><p>使用分页执行计划。耗时 <strong>0.7s</strong></p><p><img src="/data/images/db/oracle-keep-4.png" alt="oracle-keep-4"></p></li></ul></li><li>扩展测试<ul><li>测试1：如上述sql注释，在主查询的where处加<code>and c.customer_name_cn = &#39;XXX有限公司&#39;</code>，这样查询理论上只有一条此数据。加上次条件后写法1的分页需要 10s，写法2的分页只需 0.09s</li><li>测试2：此时查询主表(t_customer)数据条数28.9w,，曾测试查询主表只有2条数据(额外关联了几张较小的字段表)。写法1分页查询耗时 20s，写法2耗时 0.1s</li></ul></li><li>关于子查询 <a href="https://www.cnblogs.com/seven7seven/p/3662451.html" target="_blank" rel="noopener">^7</a><ul><li>标准子查询：子查询先于主查询独立执行，返回明确结果供主查询使用。一般常见于where字句，且子查询返回一行/多上固定值(子查询中未使用主查询字段)</li><li>相关子查询：子查询不能提前运行以得到明确结果。一般常见于select字句、where字句(子查询中使用了主查询字段，如常用的exists)</li><li>此案例写法1使用子查询，不管子查询写在何处都需要子查询先返回一个视图，再供主查询调用。从而在获取子查询时必须全表扫描并排序</li></ul></li><li><strong>keep和over联用，即可以查询子表最值，关联子表导致数据重复仍需group by去重</strong></li></ul></li></ul><h5 id="rollup、cube、grouping-小计、合计"><a href="#rollup、cube、grouping-小计、合计" class="headerlink" title="rollup、cube、grouping 小计、合计"></a>rollup、cube、grouping 小计、合计</h5><ul><li>结合group by获取小计、合计值<br><a href="https://www.cnblogs.com/mumulin99/p/9837522.html" target="_blank" rel="noopener">https://www.cnblogs.com/mumulin99/p/9837522.html</a></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul><li>参考：<a href="https://www.cnblogs.com/qmfsun/p/4467904.html" target="_blank" rel="noopener">https://www.cnblogs.com/qmfsun/p/4467904.html</a></li><li>正则函数<ul><li><code>regexp_like</code> (匹配)比较一个字符串是否与正则表达式匹配<ul><li><code>(srcstr, pattern [, match_option])</code></li></ul></li><li><code>regexp_instr</code> (包含)在字符串中查找正则表达式，并且返回匹配的位置<ul><li><code>(srcstr, pattern [, position [, occurrence [, return_option [, match_option]]]])</code></li></ul></li><li><code>regexp_substr</code> (提取) 返回与正则表达式匹配的子字符串<ul><li><code>(srcstr, pattern [, position [, occurrence [, match_option]]])</code></li></ul></li><li><code>regexp_replace</code> (替换)搜索并且替换匹配的正则表达式<ul><li><code>(srcstr, pattern [, replacestr [, position [, occurrence [, match_option]]]])</code><ul><li>srcstr: 被查找的字符数据</li><li>pattern: 正则表达式</li><li>position: 搜索在字符串中的开始位置。如果省略，则默认为1，这是字符串中的第一个位置</li><li>occurrence: 它是模式字符串中的第n个匹配位置。如果省略，默认为1</li><li>return_option: 默认值为0，返回该模式的起始位置；值为1则返回符合匹配条件的下一个字符的起始位置</li><li>replacestr: 用来替换匹配模式的字符串</li><li>match_option: 匹配方式选项。缺省为c<ul><li>c：case sensitive</li><li>I：case insensitive</li><li>n：(.)匹配任何字符(包括newline)</li><li>m：字符串存在换行的时候被作为多行处理</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分割函数：基于,分割，返回3行数据</span></span><br><span class="line"><span class="keyword">select</span> regexp_substr(<span class="string">'17,20,23'</span>, <span class="string">'[^,]+'</span>, <span class="number">1</span>, <span class="keyword">level</span>, <span class="string">'i'</span>) <span class="keyword">as</span> <span class="keyword">str</span> <span class="keyword">from</span> dual</span><br><span class="line">  <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;= <span class="keyword">length</span>(<span class="string">'17,20,23'</span>) - <span class="keyword">length</span>(regexp_replace(<span class="string">'17,20,23'</span>, <span class="string">','</span>, <span class="string">''</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正则替换中文、\、`为空格，并取256位长度</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(regexp_replace(<span class="string">'中文A\B`C'</span>, <span class="string">'['</span> || unistr(<span class="string">'\4e00'</span>) || <span class="string">'-'</span> || unistr(<span class="string">'\9fa5'</span>) || <span class="string">'\\`]'</span>, <span class="string">' '</span>), <span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line"><span class="keyword">as</span> rx_replace <span class="keyword">from</span> dual</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配纯数字</span></span><br><span class="line"><span class="keyword">regexp_like</span>(income,<span class="string">'^(\d*)$'</span>)</span><br><span class="line"><span class="comment">-- 匹配金额</span></span><br><span class="line"><span class="keyword">regexp_like</span>(income,<span class="string">'^-?([[:digit:]]*.[[:digit:]]*)$'</span>)</span><br><span class="line"><span class="keyword">regexp_like</span>(income,<span class="string">'^-?(\d*.\d*)$'</span>)</span><br><span class="line"><span class="keyword">regexp_like</span>(income,<span class="string">'^-?([0-9]*.[0-9]*)$'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分别返回17 20 23</span></span><br><span class="line"><span class="comment">-- select regexp_instr('17,20,23', ',') from dual; -- 返回3</span></span><br><span class="line"><span class="comment">-- select regexp_instr('17,20,23', ',', 1, 2) from dual; -- 返回6</span></span><br><span class="line"><span class="comment">-- select regexp_instr('17,20,23', ',', 1, 3) from dual; -- 返回0</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'17,20,23'</span>, <span class="number">1</span>, regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>) - <span class="number">1</span>) <span class="keyword">from</span> dual; <span class="comment">-- 返回17</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'17,20,23'</span>, regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>) + <span class="number">1</span>, regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>, <span class="number">1</span>, <span class="number">2</span>) - regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>) - <span class="number">1</span>) <span class="keyword">from</span> dual; <span class="comment">-- 返回20</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'17,20,23'</span>, regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>, <span class="number">1</span>, <span class="number">2</span>) + <span class="number">1</span>, <span class="keyword">length</span>(<span class="string">'17,20,23'</span>) - regexp_instr(<span class="string">'17,20,23'</span>, <span class="string">','</span>)) <span class="keyword">from</span> dual; <span class="comment">-- 返回23</span></span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="查找中文"><a href="#查找中文" class="headerlink" title="查找中文"></a>查找中文</h5><ul><li><code>select * from t_customer t where asciistr(t.customer_name) like &#39;%\%&#39; and instr(t.customer_name, &#39;\&#39;) &lt;= 0;</code></li></ul><h5 id="一个字段存多个ID进行联表查询"><a href="#一个字段存多个ID进行联表查询" class="headerlink" title="一个字段存多个ID进行联表查询"></a>一个字段存多个ID进行联表查询</h5><ul><li>参考<a href="#connect%20by%20递归关联">connect by 递归关联</a> <a href="https://blog.csdn.net/qq_42440234/article/details/84101412" target="_blank" rel="noopener">^9</a></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 也可将,进行分割后使用in进行联表查询，但是效率比此方法低很多</span></span><br><span class="line">WITH user_info_temp as (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">    ui.id,</span><br><span class="line">	ui.username,</span><br><span class="line">    ui.hobby_id</span><br><span class="line">	<span class="keyword">LEVEL</span> C_LEVEL,</span><br><span class="line">	REGEXP_SUBSTR(ui.hobby_id, <span class="string">'[^,]+'</span>, <span class="number">1</span>, <span class="keyword">LEVEL</span>) hobby_id_item</span><br><span class="line">	<span class="keyword">FROM</span> user_info ui <span class="comment">-- 用户表存放的爱好字段hobby_id使用逗号分割存放hobby表id</span></span><br><span class="line">	<span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">LEVEL</span> &lt;= REGEXP_COUNT(ui.hobby_id, <span class="string">'[^,]+'</span>) <span class="comment">-- 递归关联条件：当前递归层级 &lt;= hobby.id 的个数</span></span><br><span class="line">	<span class="keyword">AND</span> <span class="keyword">PRIOR</span> ui.id = ui.id <span class="comment">-- 递归关联条件：进行自关联</span></span><br><span class="line">	<span class="keyword">AND</span> <span class="keyword">PRIOR</span> DBMS_RANDOM.VALUE <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">-- DBMS_RANDOM是Oracle提供的一个PL/SQL包，用于生成随机数据和字符</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    uit.id,</span><br><span class="line">	uit.username,</span><br><span class="line">    uit.hobby_id,</span><br><span class="line">	<span class="keyword">LISTAGG</span>(TO_CHAR(h.hobby_name), <span class="string">','</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> uit.C_LEVEL) hobby_name <span class="comment">-- 参考[listagg within group行转列](#listagg%20within%20group行转列)</span></span><br><span class="line"><span class="keyword">FROM</span> user_info_temp uit</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> hobby h <span class="keyword">ON</span> uit.hobby_id_item = h.id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    uit.id,</span><br><span class="line">	uit.username,</span><br><span class="line">    uit.hobby_id;</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="解析json"><a href="#解析json" class="headerlink" title="解析json"></a>解析json</h4><ul><li>参考：<a href="https://blog.csdn.net/cyzshenzhen/article/details/17074543" target="_blank" rel="noopener">https://blog.csdn.net/cyzshenzhen/article/details/17074543</a><ul><li><code>select pkg_common.FUNC_PARSEJSON_BYKEY(&#39;{&quot;name&quot;: &quot;smalle&quot;, &quot;age&quot;: &quot;18&quot;}&#39;, &#39;name&#39;) from dual;</code> 取不到age?</li></ul></li></ul><h4 id="字符串分割函数"><a href="#字符串分割函数" class="headerlink" title="字符串分割函数"></a>字符串分割函数</h4><ul><li>使用正则函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于,分割，返回3行数据</span></span><br><span class="line"><span class="keyword">select</span> regexp_substr(<span class="string">'17,20,23'</span>, <span class="string">'[^,]+'</span>, <span class="number">1</span>, <span class="keyword">level</span>, <span class="string">'i'</span>) <span class="keyword">as</span> <span class="keyword">str</span> <span class="keyword">from</span> dual</span><br><span class="line">  <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;= <span class="keyword">length</span>(<span class="string">'17,20,23'</span>) - <span class="keyword">length</span>(regexp_replace(<span class="string">'17,20,23'</span>, <span class="string">','</span>, <span class="string">''</span>)) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>(1)创建字符串数组类型：<code>create or replace type sq_type_arr_str is table of varchar2 (60);</code> (一个数组，每个元素是varchar2 (60))</li><li><p>(2)创建自定义函数<code>sq_split</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">function</span> sq_split(p_str       <span class="keyword">in</span> varchar2,</span><br><span class="line">                                p_delimiter <span class="keyword">in</span> varchar2)</span><br><span class="line">  <span class="keyword">return</span> sq_type_arr_str</span><br><span class="line">  <span class="keyword">pipelined</span> <span class="keyword">is</span></span><br><span class="line">  j    <span class="built_in">int</span> := <span class="number">0</span>;</span><br><span class="line">  i    int := 1;</span><br><span class="line">  len  int := 0;</span><br><span class="line">  len1 int := 0;</span><br><span class="line">  str  varchar2(4000);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">len</span>  := <span class="keyword">length</span>(p_str);</span><br><span class="line">  len1 := length(p_delimiter);</span><br><span class="line"></span><br><span class="line">  while j &lt; len loop</span><br><span class="line">    j := instr(p_str, p_delimiter, i);</span><br><span class="line"></span><br><span class="line">    if j = 0 then</span><br><span class="line">      j   := len;</span><br><span class="line">      str := substr(p_str, i);</span><br><span class="line">      pipe row(str);</span><br><span class="line">      if i &gt;= len then</span><br><span class="line">        exit;</span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    else</span><br><span class="line">      str := substr(p_str, i, j - i);</span><br><span class="line">      i   := j + len1;</span><br><span class="line">      pipe row(str);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line"><span class="keyword">end</span> sq_split;</span><br></pre></td></tr></table></figure></li><li><p>查询示例：<code>select * from table (cast (sq_split (&#39;aa,,bb,cc,,&#39;, &#39;,&#39;) as sq_type_arr_str));</code> (一定要加<code>as sq_type_arr_str</code>) 结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	COLUMN_VALUE</span><br><span class="line">1	aa</span><br><span class="line">2</span><br><span class="line">3	bb</span><br><span class="line">4	cc</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li><p>示例二</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.*</span><br><span class="line">  <span class="keyword">from</span> test_table t</span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">          <span class="keyword">from</span> <span class="keyword">table</span>(<span class="keyword">cast</span>(sq_split(t.name, <span class="string">','</span>) <span class="keyword">as</span> sq_type_arr_str)) arr</span><br><span class="line">          <span class="keyword">where</span> <span class="keyword">trim</span>(arr.column_value) = <span class="string">'aa'</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="关联表进行数据更新"><a href="#关联表进行数据更新" class="headerlink" title="关联表进行数据更新"></a>关联表进行数据更新</h3><ul><li><p><strong><code>update set from where</code></strong> 将一张表的数据同步到另外一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Oracle：如果a表和b表的字段相同，最好给两张表加别名. **注意where条件**</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> a <span class="keyword">set</span> (a.a1, a.a2, a.a3) = (<span class="keyword">select</span> b.b1, b.b2, b.b3 <span class="keyword">from</span> test2 b <span class="keyword">where</span> a.id = b.id) </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test2 b <span class="keyword">where</span> a.id = b.id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mysql：update的表不能加别名，oracle可以加别名。当字段相同时直接使用表名做前缀</span></span><br><span class="line"><span class="keyword">update</span> a, b <span class="keyword">set</span> a1 = b1, a2 = b2, a3 = b3 <span class="keyword">where</span> a.id = b.id;</span><br><span class="line"><span class="keyword">update</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a0 = b0 <span class="keyword">set</span> a1 = b1, a2 = b2, a3 = b3 <span class="keyword">where</span> a.valid_status = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p>实例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (1)</span></span><br><span class="line"><span class="keyword">update</span> ycross_storage ys</span><br><span class="line"><span class="keyword">set</span> (ys.location_id, ys.ycross_x, ys.ycross_y, ys.box_type_id) =</span><br><span class="line">    (<span class="keyword">select</span> yls.location_id,</span><br><span class="line">            sc.ycrossx,</span><br><span class="line">            sc.ycrossy,</span><br><span class="line">            (<span class="keyword">select</span> ybts.id <span class="keyword">from</span> yyard_box_type_set ybts <span class="keyword">where</span> ybts.box_type = sc.relclcd) boxtypeid <span class="comment">--也可以不取别名</span></span><br><span class="line">        <span class="keyword">from</span> yyard_location_set yls, sql_ctninfo sc <span class="comment">-- sql_ctninfo为临时表</span></span><br><span class="line">        <span class="keyword">where</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">and</span> yls.region_num = sc.regionnum</span><br><span class="line">        <span class="keyword">and</span> yls.set_num = sc.setnum</span><br><span class="line">        <span class="keyword">and</span> (<span class="keyword">select</span> ypc.company_num</span><br><span class="line">                <span class="keyword">from</span> ybase_party_company ypc</span><br><span class="line">                <span class="keyword">where</span> ypc.party_id = yls.yard_party_id) = (<span class="string">'dw'</span> || <span class="keyword">trim</span>(sc.yardin))</span><br><span class="line">        <span class="keyword">and</span> yls.yes_status = <span class="number">1</span></span><br><span class="line">        <span class="keyword">and</span> sc.isinvalid = <span class="number">1</span></span><br><span class="line">        <span class="keyword">and</span> ys.box_number = sc.ctnno</span><br><span class="line">        <span class="keyword">and</span> ys.yes_storage = <span class="number">1</span>) <span class="comment">-- 可以拿到update的表ycross_storage(再套一层子查询则无法拿到)，且不能关联进去，否则容易出现一对多错误</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">-- where只能拿到update的表(不能拿到form的)</span></span><br><span class="line"><span class="comment">-- 除了set(里面)限制了需要更新的范围，where(外面)也需要限制</span></span><br><span class="line"><span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> sql_ctninfo sc <span class="keyword">where</span> ys.box_number = sc.ctnno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (2)将重庆的数据重新设置其绑定IS为最新的一条拜访的IS</span></span><br><span class="line"><span class="keyword">update</span> t_customer t</span><br><span class="line">  <span class="keyword">set</span> t.update_user_id = <span class="number">3</span>,</span><br><span class="line">      t.update_tm = <span class="keyword">sysdate</span>,</span><br><span class="line">      t.lock_status = <span class="number">1</span>,</span><br><span class="line">      (t.bind_is_user_id) =</span><br><span class="line">      <span class="comment">-- 通过子查询获取时 (select a.visit_user_id from (select v.visit_user_id from t_visit v where t.id = v.customer_id and v.valid_status = 1 order by v.visit_tm) a where rownum = 1) 拿不到t_customer的字段</span></span><br><span class="line">      (<span class="keyword">select</span> a.first_id</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> c.id,</span><br><span class="line">                      <span class="keyword">first_value</span>(v.visit_user_id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> v.customer_id <span class="keyword">order</span> <span class="keyword">by</span> v.visit_tm <span class="keyword">desc</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) <span class="keyword">as</span> first_id</span><br><span class="line">                  <span class="keyword">from</span> t_customer c</span><br><span class="line">                  <span class="keyword">left</span> <span class="keyword">join</span> t_visit v</span><br><span class="line">                    <span class="keyword">on</span> c.id = v.customer_id</span><br><span class="line">                  <span class="keyword">and</span> v.valid_status = <span class="number">1</span>) a</span><br><span class="line">        <span class="keyword">where</span> a.id = t.id</span><br><span class="line">          <span class="keyword">and</span> <span class="keyword">rownum</span> = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">where</span> t.customer_region = <span class="string">'500000'</span></span><br><span class="line">  <span class="keyword">and</span> t.valid_status = <span class="number">1</span></span><br><span class="line">  <span class="keyword">and</span> t.info_sure_status = <span class="number">1</span></span><br><span class="line">  <span class="comment">-- 此处加exists ?</span></span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">          <span class="keyword">from</span> t_visit v</span><br><span class="line">        <span class="keyword">where</span> v.customer_id = t.id</span><br><span class="line">          <span class="keyword">and</span> v.valid_status = <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Oracle中DBlink实现跨实例查询"><a href="#Oracle中DBlink实现跨实例查询" class="headerlink" title="Oracle中DBlink实现跨实例查询"></a>Oracle中DBlink实现跨实例查询</h3><ul><li>同示例，跨用户可使用别名进行访问</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建DBLINK</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">public</span> <span class="keyword">database</span> <span class="keyword">link</span> my_dblink</span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">to</span> smalle <span class="keyword">identified</span> <span class="keyword">by</span> smalle <span class="comment">-- 需要连接的数据库信息</span></span><br><span class="line">    <span class="keyword">using</span> <span class="string">'(DESCRIPTION =</span></span><br><span class="line"><span class="string">        (ADDRESS_LIST =</span></span><br><span class="line"><span class="string">            (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.1)(PORT = 1521))</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        (CONNECT_DATA =</span></span><br><span class="line"><span class="string">            (SERVICE_NAME = orcl)</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    )'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line">dblink <span class="keyword">drop</span> <span class="keyword">public</span> <span class="keyword">database</span> <span class="keyword">link</span> my_dblink;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询。并且mybatis是支持oracle的@dblink，相关sql语句表名后增加dblink名即可</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_ost_notebook@my_dblink;</span><br></pre></td></tr></table></figure><h3 id="Oracle定时任务Job"><a href="#Oracle定时任务Job" class="headerlink" title="Oracle定时任务Job"></a>Oracle定时任务Job</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_jobs; <span class="comment">-- 还有all_jobs/user_jobs</span></span><br><span class="line"><span class="comment">-- 真正运行的job</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_jobs_running;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 操作job(创建、手动执行、删除)</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    job_id <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- （1）创建job</span></span><br><span class="line">    <span class="comment">-- sys用户下dbms_job包中的submit过程(方法)，sys可以省略</span></span><br><span class="line">    <span class="comment">-- 在dbms_job这个package中还有其他的过程：broken、change、interval、isubmit、next_date、remove(移除一个job)、run(立即运行一个job)、submit、user_export、what；</span></span><br><span class="line">    sys.dbms_job.submit(</span><br><span class="line">        job =&gt; :job_id, <span class="comment">-- OUT，返回job_id（不能省略）</span></span><br><span class="line">        what =&gt; <span class="string">'my_proc_name;'</span>, <span class="comment">-- 执行的存储过程名称，后面要带分号</span></span><br><span class="line">        next_date =&gt; <span class="keyword">to_date</span>(<span class="string">'2018-06-15 10:00:00'</span>, <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>), <span class="comment">-- job的开始时间. 如果写成sysdate则提交后便会执行一次</span></span><br><span class="line">        <span class="built_in">interval</span> =&gt; <span class="string">'sysdate+1/86400'</span> <span class="comment">-- job的运行频率。每天86400秒钟，即一秒钟运行my_proc_name过程一次</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 带参数执行job(每日凌晨零点执行)</span></span><br><span class="line">    dbms_job.submit(job_id, '<span class="keyword">declare</span> username varchar2(<span class="number">200</span>); <span class="keyword">begin</span> my_proc_name(username, <span class="string">''''</span>); <span class="keyword">end</span>;', sysdate, 'trunc(sysdate)+1'); </span><br><span class="line"></span><br><span class="line">    <span class="comment">-- （2）比如某个job返回的id为888</span></span><br><span class="line">    dbms_job.run(888); <span class="comment">-- 立即运行一次888这个job（如果job中next_date=4000-1-1，可能由于存储过程执行出错，修正后重新运行一次即可）</span></span><br><span class="line">    dbms_job.remove(888); <span class="comment">-- 移除888这个job</span></span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- （3）修改</span></span><br><span class="line">	dbms_job.what('my_proc_name;'); <span class="comment">-- 修改要执行的存储过程名</span></span><br><span class="line">	dbms_job.next_date(888, to_date('2018-06-15 10:00:00', 'yyyy-mm-dd hh24:mi:ss')); <span class="comment">-- 修改 job 的间隔时间</span></span><br><span class="line">	dbms_job.interval(888, 'trunc(sysdate)+1'); <span class="comment">-- 修改 job 的间隔时间</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>执行频率举例<ul><li>每天午夜12点 <code>interval =&gt; trunc(sysdate + 1)</code></li><li>每天早上8点30分 <code>interval =&gt; trunc(sysdate + 1) + (8*60+30)/(24*60)</code></li><li>每星期二中午12点 <code>interval =&gt; next_day(trunc(sysdate), &#39;tuesday&#39;) + 12/24</code></li><li>每个月第一天的午夜12点 <code>interval =&gt; trunc(last_day(sysdate) + 1)</code></li><li>每个季度最后一天的晚上11点 <code>interval =&gt; trunc(add_months(sysdate + 2/24, 3), &#39;q&#39;) -1/24</code></li><li>每星期六和日早上6点10分 <code>interval =&gt; trunc(least(next_day(sysdate, &#39;saturday&#39;), next_day(sysdate, &#39;sunday&#39;))) + (6×60+10)/(24×60)</code></li><li>每30秒执行次 <code>interval =&gt; sysdate + 30/(24 * 60 * 60)</code></li><li>每10分钟执行 <code>interval =&gt; trunc(sysdate, &#39;mi&#39;) + 10/(24*60)</code></li><li>每天的凌晨1点执行 <code>interval =&gt; trunc(sysdate) + 1 + 1/(24)</code></li><li>每周一凌晨1点执行 <code>interval =&gt; trunc(next_day(sysdate, &#39;星期一&#39;))+1/24</code></li><li>每月1日凌晨1点执行 <code>interval =&gt; trunc(last_day(sysdate))+1+1/24</code></li><li>每季度的第一天凌晨1点执行 <code>interval =&gt; trunc(add_months(sysdate, 3), &#39;q&#39;) + 1/24</code></li><li>每半年定时执行(7.1和1.1) <code>interval =&gt; add_months(trunc(sysdate, &#39;yyyy&#39;),6)+1/24</code></li><li>每年定时执行 <code>interval =&gt; add_months(trunc(sysdate, &#39;yyyy&#39;), 12)+1/24</code></li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 去除换行chr(10), 去掉回车chr(13), 去掉空格。idea从excel复制数据新增时可能会出现换行</span></span><br><span class="line"><span class="keyword">update</span> t_test t <span class="keyword">set</span> t.name=<span class="keyword">trim</span>(<span class="keyword">replace</span>(<span class="keyword">replace</span>(t.name,<span class="keyword">chr</span>(<span class="number">10</span>),<span class="string">''</span>),<span class="keyword">chr</span>(<span class="number">13</span>),<span class="string">''</span>));</span><br><span class="line"><span class="comment">--四舍五入</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">0.44775454545454544</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--直接保留两位小数</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">4.757545489</span>, <span class="number">2</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><p>-CET和表变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Customer <span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">in</span> (<span class="keyword">select</span> EntityId <span class="keyword">from</span> GenericAttribute <span class="keyword">where</span> [<span class="keyword">Key</span>] = <span class="string">'FirstName'</span> <span class="keyword">and</span> [<span class="keyword">Value</span>] = <span class="string">'John'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二：使用表变量，维护性增高(子句不能有分号)；表变量实际上使用了临时表，从而增加了额外的I/O开销，不太适合数据量大且频繁查询的情况</span></span><br><span class="line"><span class="keyword">declare</span> @t <span class="keyword">table</span>(EntityId <span class="keyword">nvarchar</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> @t(EntityId) (<span class="keyword">select</span> EntityId <span class="keyword">from</span> GenericAttribute <span class="keyword">where</span> [<span class="keyword">Key</span>] = <span class="string">'FirstName'</span> <span class="keyword">and</span> [<span class="keyword">Value</span>] = <span class="string">'John'</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Customer <span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> @t);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式三：使用CTE公用表表达式，性能高于表变量；其中ca是一个自定义的公用表表达式</span></span><br><span class="line">with</span><br><span class="line">ca as</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> EntityId <span class="keyword">from</span> GenericAttribute <span class="keyword">where</span> [<span class="keyword">Key</span>] = <span class="string">'FirstName'</span> <span class="keyword">and</span> [<span class="keyword">Value</span>] = <span class="string">'John'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Customer <span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> ca);</span><br></pre></td></tr></table></figure><h2 id="语法树解析"><a href="#语法树解析" class="headerlink" title="语法树解析"></a>语法树解析</h2><ul><li><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">Druid</a><ul><li>其组件<a href="https://github.com/alibaba/druid/wiki/SQL-Parser" target="_blank" rel="noopener">SQL-Parser</a>可进行SQL解析</li></ul></li><li><a href="https://github.com/apache/calcite" target="_blank" rel="noopener">Apache Calcite</a><ul><li>只支持通用的文法树，无法对不同数据库提供本地化支持</li></ul></li><li><a href="https://github.com/antlr/antlr4" target="_blank" rel="noopener">antlr</a><ul><li>Antlr4是一个Java实现的开源项目，用户需要编写g4后缀的语法文件(有通用文件提供)，Antlr4可以自动生成词法解析器和语法解析器，提供给开发者的接口是已经解析好的抽象语法树以及易于访问的Listener和Visitor基类。支持结构性语法，SQL解析只是其中一个应用场景</li></ul></li><li>参考文章<ul><li><a href="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html</a></li></ul></li></ul><hr><p>参考文章</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> smalle</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.aezo.cn/2017/09/30/db/sql-ext/" title="sql进阶">http://blog.aezo.cn/2017/09/30/db/sql-ext/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/mysql/" rel="tag"># mysql</a> <a href="/tags/oracle/" rel="tag"># oracle</a> <a href="/tags/sql/" rel="tag"># sql</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/09/13/extend/chrome/" rel="next" title="Chrome"><i class="fa fa-chevron-left"></i> Chrome</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2017/09/30/db/sql-base/" rel="prev" title="sql基础">sql基础<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400" alt="smalle"><p class="site-author-name" itemprop="name">smalle</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">159</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">141</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原则"><span class="nav-number">1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同数据库差异"><span class="nav-number">2.</span> <span class="nav-text">不同数据库差异</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型转换"><span class="nav-number">2.1.</span> <span class="nav-text">数据类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期"><span class="nav-number">2.2.</span> <span class="nav-text">日期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询"><span class="nav-number">2.3.</span> <span class="nav-text">查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">2.4.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值比较"><span class="nav-number">2.5.</span> <span class="nav-text">数值比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂查询"><span class="nav-number">3.</span> <span class="nav-text">复杂查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于用户属性表统计每个公司不同用户属性的用户数"><span class="nav-number">3.1.</span> <span class="nav-text">基于用户属性表统计每个公司不同用户属性的用户数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于关系表统计多个关系同时存在的主表记录"><span class="nav-number">3.2.</span> <span class="nav-text">基于关系表统计多个关系同时存在的主表记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行转列-列转行"><span class="nav-number">3.3.</span> <span class="nav-text">行转列/列转行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#oracle"><span class="nav-number">3.3.1.</span> <span class="nav-text">oracle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql"><span class="nav-number">3.3.2.</span> <span class="nav-text">mysql</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sqlserver"><span class="nav-number">3.3.3.</span> <span class="nav-text">sqlserver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拆分以逗号分隔的字符串为多行"><span class="nav-number">3.3.4.</span> <span class="nav-text">拆分以逗号分隔的字符串为多行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql"><span class="nav-number">4.</span> <span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见问题"><span class="nav-number">4.1.</span> <span class="nav-text">常见问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字"><span class="nav-number">4.2.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用函数"><span class="nav-number">4.3.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concat-concat-ws-group-concat"><span class="nav-number">4.3.1.</span> <span class="nav-text">concat/concat_ws/group_concat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instr-find-in-set"><span class="nav-number">4.3.2.</span> <span class="nav-text">instr/find_in_set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#with-as"><span class="nav-number">4.3.4.</span> <span class="nav-text">with as</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义变量"><span class="nav-number">4.4.</span> <span class="nav-text">自定义变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON数据类型"><span class="nav-number">4.5.</span> <span class="nav-text">JSON数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Oracle"><span class="nav-number">5.</span> <span class="nav-text">Oracle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用函数-1"><span class="nav-number">5.1.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#decode和case-when"><span class="nav-number">5.1.1.</span> <span class="nav-text">decode和case when</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grouping-rollup"><span class="nav-number">5.1.2.</span> <span class="nav-text">grouping rollup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trunc时间处理"><span class="nav-number">5.1.3.</span> <span class="nav-text">trunc时间处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim"><span class="nav-number">5.1.4.</span> <span class="nav-text">trim</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#with-as-用法"><span class="nav-number">5.1.5.</span> <span class="nav-text">with as 用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合函数-aggregate-function"><span class="nav-number">5.1.6.</span> <span class="nav-text">聚合函数(aggregate_function)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wm-concat行转列"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">wm_concat行转列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#xmlagg行转列"><span class="nav-number">5.1.6.2.</span> <span class="nav-text">xmlagg行转列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#listagg-within-group行转列"><span class="nav-number">5.1.6.3.</span> <span class="nav-text">listagg within group行转列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析函数"><span class="nav-number">5.1.7.</span> <span class="nav-text">分析函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常见分析函数-3"><span class="nav-number">5.1.7.1.</span> <span class="nav-text">常见分析函数 ^3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#connect-by-递归关联"><span class="nav-number">5.1.7.2.</span> <span class="nav-text">connect by 递归关联</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#over"><span class="nav-number">5.1.7.3.</span> <span class="nav-text">over</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#over使用误区"><span class="nav-number">5.1.7.3.1.</span> <span class="nav-text">over使用误区</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#keep-6"><span class="nav-number">5.1.7.4.</span> <span class="nav-text">keep ^6</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rollup、cube、grouping-小计、合计"><span class="nav-number">5.1.7.5.</span> <span class="nav-text">rollup、cube、grouping 小计、合计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正则表达式"><span class="nav-number">5.1.8.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">5.1.9.</span> <span class="nav-text">案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查找中文"><span class="nav-number">5.1.9.1.</span> <span class="nav-text">查找中文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个字段存多个ID进行联表查询"><span class="nav-number">5.1.9.2.</span> <span class="nav-text">一个字段存多个ID进行联表查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义函数"><span class="nav-number">5.2.</span> <span class="nav-text">自定义函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解析json"><span class="nav-number">5.2.1.</span> <span class="nav-text">解析json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串分割函数"><span class="nav-number">5.2.2.</span> <span class="nav-text">字符串分割函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联表进行数据更新"><span class="nav-number">5.3.</span> <span class="nav-text">关联表进行数据更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle中DBlink实现跨实例查询"><span class="nav-number">5.4.</span> <span class="nav-text">Oracle中DBlink实现跨实例查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle定时任务Job"><span class="nav-number">5.5.</span> <span class="nav-text">Oracle定时任务Job</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">5.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SqlServer"><span class="nav-number">6.</span> <span class="nav-text">SqlServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语法树解析"><span class="nav-number">7.</span> <span class="nav-text">语法树解析</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">smalle</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class="powered-by"> 由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="powered-by"> 主题 - <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="theme-info cnzz" style="margin:0 0 -5px 10px"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1276691827'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s23.cnzz.com/z_stat.php%3Fid%3D1276691827%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div></div><div class="ad"> <span style="font-weight:700">AD&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=oby5nolb">阿里云大礼包</a></div></div><div class="aezocn"> <span style="font-weight:700">@AEZO.CN&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="http://shop.aezo.cn/">杂货铺</a></div></div><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script></body></html>