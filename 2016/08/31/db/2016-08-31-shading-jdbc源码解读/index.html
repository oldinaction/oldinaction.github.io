<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="shading,shading-jdbc," />





  <link rel="alternate" href="/atom.xml" title="SmalleBlog | AEZOCN" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="文档来源：胡翔宇。此处仅作存档学习！   ShardingDataSource 类图  类解析（由父类向下） WrapperAdapter：Wrapper适配类主要作用是额外记录jdbc方法调用以及回放。     /**      * 记录方法调用.      *      * @param targetClass 目标类         * @param methodName 方法名称">
<meta name="keywords" content="shading,shading-jdbc">
<meta property="og:type" content="article">
<meta property="og:title" content="sharding-jdbc 源码学习">
<meta property="og:url" content="http://blog.aezo.cn/2016/08/31/db/2016-08-31-shading-jdbc源码解读/index.html">
<meta property="og:site_name" content="SmalleBlog | AEZOCN">
<meta property="og:description" content="文档来源：胡翔宇。此处仅作存档学习！   ShardingDataSource 类图  类解析（由父类向下） WrapperAdapter：Wrapper适配类主要作用是额外记录jdbc方法调用以及回放。     /**      * 记录方法调用.      *      * @param targetClass 目标类         * @param methodName 方法名称">
<meta property="og:image" content="http://i.imgur.com/3bajMxv.png">
<meta property="og:image" content="http://i.imgur.com/KFTd9ZT.png">
<meta property="og:image" content="http://i.imgur.com/Gd6DBKS.png">
<meta property="og:image" content="http://i.imgur.com/xeGFWga.png">
<meta property="og:image" content="http://i.imgur.com/b1XLRum.png">
<meta property="og:image" content="http://i.imgur.com/czM6sto.png">
<meta property="og:updated_time" content="2017-07-03T08:59:18.687Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sharding-jdbc 源码学习">
<meta name="twitter:description" content="文档来源：胡翔宇。此处仅作存档学习！   ShardingDataSource 类图  类解析（由父类向下） WrapperAdapter：Wrapper适配类主要作用是额外记录jdbc方法调用以及回放。     /**      * 记录方法调用.      *      * @param targetClass 目标类         * @param methodName 方法名称">
<meta name="twitter:image" content="http://i.imgur.com/3bajMxv.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.aezo.cn/2016/08/31/db/2016-08-31-shading-jdbc源码解读/"/>





  <title>sharding-jdbc 源码学习 | SmalleBlog | AEZOCN</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SmalleBlog | AEZOCN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Better Code,Better Life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2016/08/31/db/2016-08-31-shading-jdbc源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Smalle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SmalleBlog | AEZOCN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">sharding-jdbc 源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-31T20:13:00+08:00">
                2016-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/db/" itemprop="url" rel="index">
                    <span itemprop="name">db</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>文档来源：胡翔宇。此处仅作存档学习！</p>
</blockquote>
<ol>
<li><p>ShardingDataSource<br> 类图<br> <img src="http://i.imgur.com/3bajMxv.png" alt=""><br> 类解析（由父类向下）</p>
<pre><code>WrapperAdapter：Wrapper适配类主要作用是额外记录jdbc方法调用以及回放。
    /**
     * 记录方法调用.
     *
     * @param targetClass 目标类
        * @param methodName 方法名称
     * @param argumentTypes 参数类型
     * @param arguments 参数
     */
    protected final void recordMethodInvocation(final Class&lt;?&gt; targetClass, final String methodName, final Class&lt;?&gt;[] argumentTypes, final Object[] arguments) {
        try {
            jdbcMethodInvocations.add(new JdbcMethodInvocation(targetClass.getMethod(methodName, argumentTypes), arguments));
        } catch (final NoSuchMethodException ex) {
            throw new ShardingJdbcException(ex);
        }
    }

    /**
     * 回放记录的方法调用.
     *
     * @param target 目标对象
     */
    protected final void replayMethodsInvocation(final Object target) {
        for (JdbcMethodInvocation each : jdbcMethodInvocations) {
            each.invoke(target);
        }
    }

AbstractUnsupportedOperationDataSource ： 声明不支持操作的数据源对象。
AbstractDataSourceAdapter ： 适配基类没有实际的业务操作，拓展使用（如图后加入的读写分离就是最好的例子）。
</code></pre><p> ShardingDataSource ： 支持分片的数据源。</p>
<pre><code>重点内容  
ShardingProperties 变量 ： 主要是jdbc的配置
shardingContext :  数据源运行期上下文。   此处要注意的是上下文是分库分表规则的持有者，也是路由引擎，执行引擎的持有者
方法  
getDatabaseProductName ： 根据分库分表规则获取数据库类型（有主从的时候，与其他区分处理）。
getConnection()： 获取数据库连接 返回 ShardingConnection 连接。
</code></pre><p> 使用方法</p>
<pre><code> DataSourceRule dataSourceRule = new DataSourceRule(createDataSourceMap());
//order 分表
TableRule orderTableRule = TableRule.builder(&quot;t_order&quot;).actualTables(Arrays.asList(&quot;t_order_0&quot;, &quot;t_order_1&quot;)).dataSourceRule(dataSourceRule).build();
// order_iterm 分表
TableRule orderItemTableRule = TableRule.builder(&quot;t_order_item&quot;).actualTables(Arrays.asList(&quot;t_order_item_0&quot;, &quot;t_order_item_1&quot;)).dataSourceRule(dataSourceRule).build();
ShardingRule shardingRule = ShardingRule.builder().dataSourceRule(dataSourceRule).tableRules(Arrays.asList(orderTableRule, orderItemTableRule))
        .bindingTableRules(Collections.singletonList(new BindingTableRule(Arrays.asList(orderTableRule, orderItemTableRule))))
        .databaseShardingStrategy(new DatabaseShardingStrategy(&quot;user_id&quot;, new ModuloDatabaseShardingAlgorithm()))
        .tableShardingStrategy(new TableShardingStrategy(&quot;order_id&quot;, new ModuloTableShardingAlgorithm())).build();
//同时会new 一个 ShardingProperties初始化
return new ShardingDataSource(shardingRule);

//设置分库 ds_0,ds_1
 private static Map&lt;String, DataSource&gt; createDataSourceMap() {
    Map&lt;String, DataSource&gt; result = new HashMap&lt;&gt;(2);
    result.put(&quot;ds_0&quot;, createDataSource(&quot;ds_0&quot;));
    result.put(&quot;ds_1&quot;, createDataSource(&quot;ds_1&quot;));
    return result;
}
</code></pre></li>
<li><p>ShardingConnection<br>类图<br><img src="http://i.imgur.com/KFTd9ZT.png" alt=""><br>类解析（由父类向下）</p>
<pre><code> AbstractUnsupportedOperationConnection： 声明不支持操作的数据库连接对象.主要就是自定义不支持异常抛出
AbstractConnectionAdapter :  数据库连接适配器，公共方法（可拓展）。
    setAutoCommit（） ： 设置分库分表自动提交。
    commit（）： 提交操作
    rollback（） ： 回滚

ShardingConnection ： 分库分表connection
    connectionMap 变量 connection的持有者（一个库对应一个connection）
    shardingContext : 略
    getConnectionInternal（）：getConnection（）实际调用该方法。
         private Connection getConnectionInternal(final String dataSourceName, final SQLStatementType sqlStatementType) throws SQLException {
            //已经生成的connection直接返回
            if (connectionMap.containsKey(dataSourceName)) {
                return connectionMap.get(dataSourceName);
            }
            //用到 guava [http://ifeve.com/google-guava/](http://ifeve.com/google-guava/ &quot;guava&quot;),计时
            Context metricsContext = MetricsContext.start(Joiner.on(&quot;-&quot;).join(&quot;ShardingConnection-getConnection&quot;, dataSourceName));
            DataSource dataSource = shardingContext.getShardingRule().getDataSourceRule().getDataSource(dataSourceName);
            if (dataSource instanceof MasterSlaveDataSource) {
                dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlStatementType);
            }
            Connection result = dataSource.getConnection();
            MetricsContext.stop(metricsContext);
            connectionMap.put(dataSourceName, result);
            return result;
        }

    close（）： 连接关闭
         @Override
        public void close() throws SQLException {
            super.close();
            //清理线索分片管理器的本地线程持有者.（此处是一个问题，接下来要仔细分析一下）
            HintManagerHolder.clear();
            //此处是个问题
            MasterSlaveDataSource.resetDMLFlag();
        }
</code></pre><p>使用</p>
<pre><code>Connection conn = dataSource.getConnection();
</code></pre></li>
<li><p>ShardingStatement ： 支持分片的静态语句对象（不支持存储过程）.<br> 类图<br> <img src="http://i.imgur.com/Gd6DBKS.png" alt=""><br>  类解析（由父类向下）</p>
<pre><code>AbstractStatementAdapter：静态语句对象适配类.
    closed : 关闭标识
    poolable ： 暂未看
    fetchSize ： 条数
    //获取更新条数
     @Override
    public final int getUpdateCount() throws SQLException {
        int result = 0;
        for (Statement each : getRoutedStatements()) {
            result += each.getUpdateCount();
        }
        return result;
    }
    其他方法略

    ShardingStatement ： 支持分片的静态语句对象.
        shardingConnection：
        resultSetType：
        resultSetConcurrency ：
        resultSetHoldability：
        cachedRoutedStatements ： statemnets持有者
        mergeContext ： 结果归并上下文.
         currentResultSet ：
        //执行查询
         @Override
        public ResultSet executeQuery(final String sql) throws SQLException {
            if (null != currentResultSet &amp;&amp; !currentResultSet.isClosed()) {
                currentResultSet.close();
            }
            //先生成执行器，然后执行查询（归并mergeContext页作为参数传过去以便最后归并），整个过程下面会详细说
            currentResultSet = ResultSetFactory.getResultSet(generateExecutor(sql).executeQuery(), mergeContext);
            return currentResultSet;
        }

        private StatementExecutor generateExecutor(final String sql) throws SQLException {
            StatementExecutor result = new StatementExecutor(shardingConnection.getShardingContext().getExecutorEngine());
            //路由sql 下面详细讲解
            SQLRouteResult sqlRouteResult = shardingConnection.getShardingContext().getSqlRouteEngine().route(sql);
            mergeContext = sqlRouteResult.getMergeContext();
            //将路由结果放置到执行器中，以便后面执行（
            for (SQLExecutionUnit each : sqlRouteResult.getExecutionUnits()) {
                Statement statement = getStatement(shardingConnection.getConnection(each.getDataSource(), sqlRouteResult.getSqlStatementType()), each.getSql());
                replayMethodsInvocation(statement);
                //StatementExecutorWrapper 执行单位，和 statement组合放入执行器中
                result.addStatement(new StatementExecutorWrapper(statement, each));
            }
            return result;
        }
</code></pre></li>
</ol>
<ol>
<li>ShardingPreparedStatement ：  支持分片的预编译语句对象.</li>
<li>解析</li>
<li><p>路由<br> 类图<br> <img src="http://i.imgur.com/xeGFWga.png" alt=""></p>
<pre><code> /**
 * SQL路由.非预编译
 *
 * @param logicSql 逻辑SQL
 * @return 路由结果
 * @throws SQLParserException SQL解析失败异常
 */
public SQLRouteResult route(final String logicSql) throws SQLParserException {
    return route(logicSql, Collections.emptyList());
}
/**
 * SQL路由.
 *
 * @param logicSql 逻辑SQL
 * @param parameters 参数列表
 * @return 路由结果
 * @throws SQLParserException SQL解析失败异常
 */
public SQLRouteResult route(final String logicSql, final List&lt;Object&gt; parameters) throws SQLParserException {
    //先执行一遍，解析（接下载解析模块说明），解析的时候会设置SqlStatementType
    return routeSQL(parseSQL(logicSql, parameters), parameters);
}
 SQLRouteResult routeSQL(final SQLParsedResult parsedResult, final List&lt;Object&gt; parameters) {
    //计时
    Context context = MetricsContext.start(&quot;Route SQL&quot;);
    SQLRouteResult result = new SQLRouteResult(parsedResult.getRouteContext().getSqlStatementType(), parsedResult.getMergeContext());
    //遍历解析结果
    for (ConditionContext each : parsedResult.getConditionContexts()) {
        //将实际路由的   执行单元加入路由结果中
        result.getExecutionUnits().addAll(routeSQL(each, Sets.newLinkedHashSet(Collections2.transform(parsedResult.getRouteContext().getTables(), new Function&lt;Table, String&gt;() {

            @Override
            public String apply(final Table input) {
                return input.getName();
            }
        })), parsedResult.getRouteContext().getSqlBuilder(), parsedResult.getRouteContext().getSqlStatementType()));
    }
    //判断是否有限定结果集计算.
    processLimit(result.getExecutionUnits(), parsedResult, parameters);
    //计时
    MetricsContext.stop(context);
    log.debug(&quot;final route result:{}&quot;, result.getExecutionUnits());
    log.debug(&quot;merge context:{}&quot;, result.getMergeContext());
    return result;
}

SQLParsedResult parseSQL(final String logicSql, final List&lt;Object&gt; parameters) {
        Context context = MetricsContext.start(&quot;Parse SQL&quot;);
        SQLParsedResult result = SQLParserFactory.create(databaseType, logicSql, parameters, shardingRule.getAllShardingColumns()).parse();
        MetricsContext.stop(context);
        return result;
    }

private Collection&lt;SQLExecutionUnit&gt; routeSQL(final ConditionContext conditionContext, final Set&lt;String&gt;     logicTables, final SQLBuilder sqlBuilder, final SQLStatementType type) {
    RoutingResult result;
    //判断逻辑表数量，就是看看是否是单表操作
    if (1 == logicTables.size()) {
        result = new SingleTableRouter(shardingRule, logicTables.iterator().next(), conditionContext, type).route();
    }
    //判断逻辑表名称集合是否全部属于Binding表.(绑定表代表一组表，这组表的逻辑表与实际表之间的映射关系是相同的。比如t_order与t_order_item就是这样一组绑定表关系,它们的分库与分表策略是完全相同的,那么可以使用它们的表规则将它们配置成绑定表)
    else if (shardingRule.isAllBindingTables(logicTables)) {
        result = new BindingTablesRouter(shardingRule, logicTables, conditionContext, type).route();
    } else {
        // TODO 可配置是否执行笛卡尔积
        result = new MixedTablesRouter(shardingRule, logicTables, conditionContext, type).route();
    }
    if (null == result) {
        throw new ShardingJdbcException(&quot;Sharding-JDBC: cannot route any result, please check your sharding rule.&quot;);
    }
    return result.getSQLExecutionUnits(sqlBuilder);
}

单表路由
/**
 * 路由.
 *
 * @return 路由结果
 */
public SingleRoutingResult route() {
    //多库则返回多个库名称
    Collection&lt;String&gt; routedDataSources = routeDataSources();
    Collection&lt;String&gt; routedTables = routeTables(routedDataSources);
    return generateRoutingResult(routedDataSources, routedTables);
}

//路由数据库
private Collection&lt;String&gt; routeDataSources() {
    DatabaseShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);
    List&lt;ShardingValue&lt;?&gt;&gt; shardingValues;
    if (HintManagerHolder.isUseShardingHint()) {
        shardingValues = getDatabaseShardingValuesFromHint(strategy.getShardingColumns());
    } else {
        //[ShardingValue(logicTableName=t_order, columnName=user_id, value=10, values=[], valueRange=null)]
        //* @param logicTable 逻辑表名称 * @param shardingColumn 分片键  * @param value 分片值
        shardingValues = getShardingValues(strategy.getShardingColumns());
    }
    logBeforeRoute(&quot;database&quot;, logicTable, tableRule.getActualDatasourceNames(), strategy.getShardingColumns(), shardingValues);
    Collection&lt;String&gt; result = new HashSet&lt;&gt;(strategy.doStaticSharding(sqlStatementType, tableRule.getActualDatasourceNames(), shardingValues));
    logAfterRoute(&quot;database&quot;, logicTable, result);
    Preconditions.checkState(!result.isEmpty(), &quot;no database route info&quot;);
    return result;
}
 /**
 * 计算静态分片.
 *
 * @param sqlStatementType SQL语句的类型
 * @param availableTargetNames 所有的可用分片资源集合
 * @param shardingValues 分片值集合
 * @return 分库后指向的数据源名称集合
 */
public Collection&lt;String&gt; doStaticSharding(final SQLStatementType sqlStatementType, final Collection&lt;String&gt; availableTargetNames, final Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues) {
    if (shardingValues.isEmpty()) {
        Preconditions.checkState(!isInsertMultiple(sqlStatementType, availableTargetNames), &quot;INSERT statement should contain sharding value.&quot;);
        return availableTargetNames;
    }
    //分片算法是这边调用的，返回路由结果（实际表，实际数据库）
    return doSharding(shardingValues, availableTargetNames);
}
//路由实际表
 private Collection&lt;String&gt; routeTables(final Collection&lt;String&gt; routedDataSources) {
    TableShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);
    List&lt;ShardingValue&lt;?&gt;&gt; shardingValues;
    if (HintManagerHolder.isUseShardingHint()) {
        shardingValues = getTableShardingValuesFromHint(strategy.getShardingColumns());
    } else {
        shardingValues = getShardingValues(strategy.getShardingColumns());
    }
    logBeforeRoute(&quot;table&quot;, logicTable, tableRule.getActualTables(), strategy.getShardingColumns(), shardingValues);
    Collection&lt;String&gt; result;
    if (tableRule.isDynamic()) {
        result = new HashSet&lt;&gt;(strategy.doDynamicSharding(shardingValues));
    } else {
        result = new HashSet&lt;&gt;(strategy.doStaticSharding(sqlStatementType, tableRule.getActualTableNames(routedDataSources), shardingValues));    
    }
    logAfterRoute(&quot;table&quot;, logicTable, result);
    Preconditions.checkState(!result.isEmpty(), &quot;no table route info&quot;);
    return result;
}

private SingleRoutingResult generateRoutingResult(final Collection&lt;String&gt; routedDataSources, final             Collection&lt;String&gt; routedTables) {
    SingleRoutingResult result = new SingleRoutingResult();
    //[DataNode(dataSourceName=ds_0, tableName=t_order_1), DataNode(dataSourceName=ds_1, tableName=t_order_1), DataNode(dataSourceName=ds_0, tableName=t_order_0), DataNode(dataSourceName=ds_1, tableName=t_order_0)]（第一次生成4个）
    //该方法会调用多次
    for (DataNode each : tableRule.getActualDataNodes(routedDataSources, routedTables)) {
        result.put(each.getDataSourceName(), new SingleRoutingTableFactor(logicTable, each.getTableName()));
    }
    return result;
}
</code></pre></li>
<li><p>执行<br> 类图<br> <img src="http://i.imgur.com/b1XLRum.png" alt=""></p>
<pre><code>首先executeQuery 由 ShardingStatement（ShardingPreparedStatement）调用
 @Override
public ResultSet executeQuery(final String sql) throws SQLException {
    if (null != currentResultSet &amp;&amp; !currentResultSet.isClosed()) {
        currentResultSet.close();
    }
    currentResultSet = ResultSetFactory.getResultSet(generateExecutor(sql).executeQuery(), mergeContext);
    return currentResultSet;
}

private StatementExecutor generateExecutor(final String sql) throws SQLException {
    StatementExecutor result = new StatementExecutor(shardingConnection.getShardingContext().getExecutorEngine());
    //路由sql
    SQLRouteResult sqlRouteResult = shardingConnection.getShardingContext().getSqlRouteEngine().route(sql);
    mergeContext = sqlRouteResult.getMergeContext();
    for (SQLExecutionUnit each : sqlRouteResult.getExecutionUnits()) {
        Statement statement = getStatement(shardingConnection.getConnection(each.getDataSource(), sqlRouteResult.getSqlStatementType()), each.getSql());
        replayMethodsInvocation(statement);
        //SQLExecutionUnit，statement 组装成发给StatementExecutorWrapper 给执行器执行
        result.addStatement(new StatementExecutorWrapper(statement, each));
    }
    return result;
}

可以看出 generateExecutor 方法生成 StatementExecutor 执行器 接着调用 executeQuery
 /**
 * 执行SQL查询.
 *
 * @return 结果集列表
 */
public List&lt;ResultSet&gt; executeQuery() {
    //计时
    Context context = MetricsContext.start(&quot;ShardingStatement-executeQuery&quot;);
    postExecutionEvents();//（此处是一个问题，接下来要仔细分析一下）
    final boolean isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();
    final Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();
    List&lt;ResultSet&gt; result;
    try {
        if (1 == statementExecutorWrappers.size()) {
            return Collections.singletonList(executeQueryInternal(statementExecutorWrappers.iterator().next(), isExceptionThrown, dataMap));
        }
        result = executorEngine.execute(statementExecutorWrappers, new ExecuteUnit&lt;StatementExecutorWrapper, ResultSet&gt;() {

            @Override
            public ResultSet execute(final StatementExecutorWrapper input) throws Exception {
                return executeQueryInternal(input, isExceptionThrown, dataMap);
            }
        });
    } finally {
        MetricsContext.stop(context);
    }
    return result;
}

/**
 * 多线程执行任务.（运用谷歌com.google.common.util.concurrent）
 *
 * @param inputs 输入参数
 * @param executeUnit 执行单元
 * @param &lt;I&gt; 入参类型
 * @param &lt;O&gt; 出参类型
 * @return 执行结果
 */
public &lt;I, O&gt; List&lt;O&gt; execute(final Collection&lt;I&gt; inputs, final ExecuteUnit&lt;I, O&gt; executeUnit) {
    ListenableFuture&lt;List&lt;O&gt;&gt; futures = submitFutures(inputs, executeUnit);
    addCallback(futures);
    return getFutureResults(futures);
}

private ResultSet executeQueryInternal(final StatementExecutorWrapper statementExecutorWrapper, final boolean isExceptionThrown, final Map&lt;String, Object&gt; dataMap) {
    ResultSet result;
    ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);
    ExecutorDataMap.setDataMap(dataMap);
    try {
        //statementExecutorWrapper.getSqlExecutionUnit().getSql() 要参考 SqlExecutionUnit 里面的 sql参数生成过程
        result = statementExecutorWrapper.getStatement().executeQuery(statementExecutorWrapper.getSqlExecutionUnit().getSql());
    } catch (final SQLException ex) {
        postExecutionEventsAfterExecution(statementExecutorWrapper, EventExecutionType.EXECUTE_FAILURE, Optional.of(ex));
        ExecutorExceptionHandler.handleException(ex);
        return null;
    }
    postExecutionEventsAfterExecution(statementExecutorWrapper);
    return result;
}
</code></pre></li>
<li><p>归并<br> 类图<br> <img src="http://i.imgur.com/czM6sto.png" alt=""></p>
<pre><code>ResultSetFactory ： 分片结果集归并工厂.
 /**
 * 获取结果集.
 *
 * @param resultSets 结果集列表
 * @param mergeContext 结果归并上下文
 * @return 结果集包装
 */
public static ResultSet getResultSet(final List&lt;ResultSet&gt; resultSets, final MergeContext mergeContext) throws SQLException {
    ShardingResultSets shardingResultSets = new ShardingResultSets(resultSets);
    log.trace(&quot;Sharding-JDBC: Sharding result sets type is &apos;{}&apos;&quot;, shardingResultSets.getType().toString());
    switch (shardingResultSets.getType()) {
        case EMPTY:
            return buildEmpty(resultSets);
        case SINGLE:
            return buildSingle(shardingResultSets, mergeContext);
        case MULTIPLE:
            return buildMultiple(shardingResultSets, mergeContext);
        default:
            throw new UnsupportedOperationException(shardingResultSets.getType().toString());
    }
}
//直接看buildMultiple 上面比较简单直接返回即可
private static ResultSet buildMultiple(final ShardingResultSets shardingResultSets, final MergeContext mergeContext) throws SQLException {
    //实例化 ResultSetMergeContext
    ResultSetMergeContext resultSetMergeContext = new ResultSetMergeContext(shardingResultSets, mergeContext);
    return buildCoupling(buildReducer(resultSetMergeContext), resultSetMergeContext);
  }
public ResultSetMergeContext(final ShardingResultSets shardingResultSets, final MergeContext mergeContext) throws SQLException {
    this.shardingResultSets = shardingResultSets;
    this.mergeContext = mergeContext;
    currentOrderByKeys = new LinkedList&lt;&gt;();
    init();
}

private void init() throws SQLException {
    //初始化 AbstractResultSetAdapter 一个实例  看下 AbstractResultSetAdapter 初始化干了什么
    setColumnIndex(((AbstractResultSetAdapter) shardingResultSets.getResultSets().get(0)).getColumnLabelIndexMap());
    currentOrderByKeys.addAll(mergeContext.getOrderByColumns());
}

private void setColumnIndex(final Map&lt;String, Integer&gt; columnLabelIndexMap) {
    for (IndexColumn each : getAllFocusedColumns()) {
        if (each.getColumnIndex() &gt; 0) {
            continue;
        }
        Preconditions.checkState(
                columnLabelIndexMap.containsKey(each.getColumnLabel().orNull()) || columnLabelIndexMap.containsKey(each.getColumnName().orNull()), String.format(&quot;%s has not index&quot;, each));
        if (each.getColumnLabel().isPresent() &amp;&amp; columnLabelIndexMap.containsKey(each.getColumnLabel().get())) {
            each.setColumnIndex(columnLabelIndexMap.get(each.getColumnLabel().get()));
        } else if (each.getColumnName().isPresent() &amp;&amp; columnLabelIndexMap.containsKey(each.getColumnName().get())) {
            each.setColumnIndex(columnLabelIndexMap.get(each.getColumnName().get()));
        }
    }
}
</code></pre></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/shading/" rel="tag"># shading</a>
          
            <a href="/tags/shading-jdbc/" rel="tag"># shading-jdbc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/31/db/2016-08-31-shading-jdbc/" rel="next" title="shading-jdbc">
                <i class="fa fa-chevron-left"></i> shading-jdbc
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/01/java/others/2016-09-01-javaconception/" rel="prev" title="java web相关概念(名词)汇总">
                java web相关概念(名词)汇总 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"
               alt="Smalle" />
          <p class="site-author-name" itemprop="name">Smalle</p>
           
              <p class="site-description motion-element" itemprop="description">代码，让生活更美化</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Smalle</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
