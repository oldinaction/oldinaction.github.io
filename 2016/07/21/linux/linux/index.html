<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="linux,shell,"><link rel="alternate" href="/atom.xml" title="Smalle's Blog | AEZOCN" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="基础知识 Linux 和 BSD 都是类 UNIX 操作系统 二者均开源 Linux 使用 GNU 通用公共许可证，即 GPL。修改Linux核心源码后必须开源 BSD(Berkeley Software Distribution，伯克利软件套件) 使用 BSD 许可证。修改源码后不需开源   BSD分支 FreeBSD：是最受欢迎的 BSD。支持英特尔和 AMD 的32位和64位处理器 NetB"><meta name="keywords" content="linux,shell"><meta property="og:type" content="article"><meta property="og:title" content="linux系统"><meta property="og:url" content="http://blog.aezo.cn/2016/07/21/linux/linux/index.html"><meta property="og:site_name" content="Smalle&#39;s Blog | AEZOCN"><meta property="og:description" content="基础知识 Linux 和 BSD 都是类 UNIX 操作系统 二者均开源 Linux 使用 GNU 通用公共许可证，即 GPL。修改Linux核心源码后必须开源 BSD(Berkeley Software Distribution，伯克利软件套件) 使用 BSD 许可证。修改源码后不需开源   BSD分支 FreeBSD：是最受欢迎的 BSD。支持英特尔和 AMD 的32位和64位处理器 NetB"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.aezo.cn/data/images/2017/02/文件详细.jpg"><meta property="og:image" content="http://blog.aezo.cn/data/images/2017/02/类型与权限.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/lang/lvm.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/top-view.jpg"><meta property="og:updated_time" content="2023-03-27T15:52:02.038Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="linux系统"><meta name="twitter:description" content="基础知识 Linux 和 BSD 都是类 UNIX 操作系统 二者均开源 Linux 使用 GNU 通用公共许可证，即 GPL。修改Linux核心源码后必须开源 BSD(Berkeley Software Distribution，伯克利软件套件) 使用 BSD 许可证。修改源码后不需开源   BSD分支 FreeBSD：是最受欢迎的 BSD。支持英特尔和 AMD 的32位和64位处理器 NetB"><meta name="twitter:image" content="http://blog.aezo.cn/data/images/2017/02/文件详细.jpg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"BWD6R9FA4K",apiKey:"3330f3cbaa099dfc30395de5f5b20151",indexName:"blog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}}}</script><link rel="canonical" href="http://blog.aezo.cn/2016/07/21/linux/linux/"><title>linux系统 | Smalle's Blog | AEZOCN</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?085f9cd91ef2ad985f791c677472f0d1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=cnzz_stat_icon_1276691827&web_id=cnzz_stat_icon_1276691827" language="JavaScript"></script></div></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Smalle's Blog | AEZOCN</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Better Code, Better Life</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2016/07/21/linux/linux/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="smalle"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Smalle's Blog | AEZOCN"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">linux系统</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-21T19:19:00+08:00">2016-07-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><div></div><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><code>Linux</code> 和 <code>BSD</code> 都是类 <code>UNIX</code> 操作系统<ul><li>二者均开源<ul><li>Linux 使用 GNU 通用公共许可证，即 GPL。修改Linux核心源码后必须开源</li><li>BSD(Berkeley Software Distribution，伯克利软件套件) 使用 BSD 许可证。修改源码后不需开源</li></ul></li><li>BSD分支<ul><li><code>FreeBSD</code>：是最受欢迎的 BSD。支持英特尔和 AMD 的32位和64位处理器</li><li><code>NetBSD</code>：被设计运行在几乎任何架构上，支持更多的体系结构</li><li><code>OpenBSD</code>：为最大化的安全性设计的</li><li><code>DragonFly BSD</code>：设计目标是提供一个运行在多线程环境中的操作系统。如计算机集群</li><li><code>Darwin / Mac OS X</code>：Mac OS X 实际上基于 Darwin 操作系统，而 Darwin 系统基于 BSD</li></ul></li></ul></li><li>Linux发行版：一类是商业公司维护的发行版本，另一类是社区组织维护的发行版本。前者以著名的Redhat(RHEL)为代表，后者以Debian为代表<ul><li><code>Redhat系列</code> Redhat是<code>yum</code>包管理方式<ul><li><code>RHEL</code> (Redhat Enterprise Linux)</li><li><code>Fedora Core</code> (由原来的Redhat桌面版本发展而来，免费版本)</li><li><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a> (RHEL的社区克隆版本，免费)</li></ul></li><li><code>Debian系列</code> 使用<code>apt-get / dpkg</code>包管理方式<ul><li><a href="https://www.debian.org/" target="_blank" rel="noopener">Debian</a>、<a href="https://manpages.debian.org/" target="_blank" rel="noopener">Man Docs</a></li><li><a href="https://cn.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a></li></ul></li><li><code>SUSE Linux</code><ul><li><a href="https://www.opensuse.org/" target="_blank" rel="noopener">openSUSE</a> 开源</li></ul></li><li><a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch Linux</a> 开源</li><li><code>Alibaba Cloud Linux 3</code> 是阿里云官方Linux操作系统的第三代发行版，选择Linux kernel 5.10 LTS作为内核，选择阿里云提供的GCC 10.2、binutils 2.35、glibc 2.32的编译器，完全兼容CentOS 8、RHEL 8软件生态</li></ul></li></ul><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>强制关闭重启<ul><li><code>shutdown -r now</code> root登录可立刻重启</li><li><code>reboot</code> 重启</li><li>关闭某个PID进程 <code>kill PID</code><ul><li><code>netstat -lnp</code> 查看所有进场信息(端口、PID)</li><li>强制杀进程 <code>kill -s 9 PID</code></li><li><code>yum install psmisc</code> centos7精简版无<code>killall</code>命令，需要安装此包<ul><li><code>killall -s 9 java</code> 杀死所有java进程</li></ul></li></ul></li></ul></li><li>程序安装：参考<a href="/_posts/linux/CentOS服务器使用说明.md#常用软件安装">《http://blog.aezo.cn/2017/01/10/linux/CentOS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/》</a></li><li><p>程序运行</p><ul><li>运行sh文件：进入到该文件目录，运行<code>./xxx.sh</code></li><li>脱机后台运行sh文件：<strong><code>nohup bash startofbiz.sh &gt; /dev/null 2&gt;&amp;1 &amp;</code></strong><ul><li>打印日志后台运行<code>nohup java -jar /xxx/xxx.jar &gt; my.log 2&gt;&amp;1 &amp;</code></li><li>运行二进制文件：<code>nohup ./mybash &gt; my.log 2&gt;&amp;1 &amp;</code> 其中mybash为可执行的二进制文件</li><li><strong>sudo形式运行</strong>：<code>nohup sudo -b ./mybash &gt; my.log 2&gt;&amp;1 &amp;</code>（<code>nohup sudo ./mongod &gt; /dev/null 2&gt;&amp;1 &amp;</code>）</li><li>可解决利用客户端连接服务器，执行的程序当客户端退出后，服务器的程序也停止了</li><li><code>nohup</code>这个表示脱机执行，默认在当前目录生成一个<code>nohup.out</code>的日志文件</li><li><code>&amp;</code> 最后面的&amp;表示放在后台执行 <a href="https://my.oschina.net/sallency/blog/827737" title="nohup 命令实现守护进程" target="_blank" rel="noopener">^8</a><ul><li><code>exit</code> 或 <code>logout</code> 正常登出并不会终止 &amp; 的后台任务，此时的 SIGHUP 信号只会发给前台任务</li><li>关闭窗口或断网，前后台任务都会收到 SIGHUP 信号，但如果我们试用了 nohup 则可以屏蔽此信号，让任务仍不被中断。(遇到一次使用nohup也无法解决关闭窗口程序停止，最终只能后台运行并通过exit退出)</li><li>进程收到 SIGHUP 信号时默认的操作是退出执行。但我们可以在代码里使用信号捕捉的方法，捕捉或忽略 SIGHUP 信号的处理，这样进程就不会退出了</li></ul></li><li><code>startofbiz.sh &gt; my.log</code> 表示startofbiz.sh的输出重定向到my.log(如果存在交互场景则会一致卡死，且无法交互，需使用tee)</li><li><code>2&gt;&amp;1</code> 表示将错误输出重定向到标准输出<ul><li><code>0</code>：标准输入；<code>1</code>：标准输出；<code>2</code>：错误输出</li></ul></li><li><code>./myscript.sh 2&gt;&amp;1 | tee mylog.log</code> <strong>tee实时重定向日志(同时也会在控制台打印，并且可进行交互)</strong></li></ul></li><li><code>Ctrl+c</code> 关闭程序，回到终端</li><li><code>Ctrl+z</code> 后台运行程序，回到终端</li><li><p>也可使用<code>screen/tmux</code>等命令实现脱机运行</p><ul><li><p>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完，一个典型的例子就是，SSH 登录远程计算机。screen/tmux可使会话与窗口”解绑”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install screen</span><br><span class="line">screen <span class="comment"># 进入screen终端</span></span><br><span class="line">./<span class="built_in">test</span> <span class="comment"># 执行程序。此时关闭SSH，此程序不会终止</span></span><br><span class="line">screen -ls <span class="comment"># 查看所有screen终端: 4680.pts-2.dev2-1 (Attached|Detached)。Attached表示有人看守状态，Detached表示无人看守</span></span><br><span class="line">screen -r 4680 <span class="comment"># 重新连接 screen_id 为 4680 的 screen终端(此时4680必须为Detached)</span></span><br><span class="line">Ctrl+A+D <span class="comment"># 保持会话并退出</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 完全退出</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>设置环境变量</p><ul><li><code>/etc/profile</code> 记录系统环境变量，在此文件末尾加入<code>export JAVA_HOME=/usr/java/jdk1.8</code> 将<code>JAVA_HOME</code>设置成所有用户可访问</li><li><code>/home/smalle/.bash_profile</code> 每个用户登录的环境变量(/home/smalle为用户家目录)<ul><li><code>.bash_profile</code> 登录后的环境变量</li><li><code>.bashrc</code> 登录后自动运行(类似rc.local)</li></ul></li><li><code>echo $JAVA_HOME</code> 查看其值</li><li>设置临时环境变量：在命令行运行<code>export JAVA_HOME=/usr/java/jdk1.8</code>(重新打开命令行则失效)</li></ul></li></ul><h3 id="服务相关命令"><a href="#服务相关命令" class="headerlink" title="服务相关命令"></a>服务相关命令</h3><ul><li><code>journalctl</code> 查看所有日志，默认显示本次启动的所有(服务)日志<ul><li><code>-f</code> 持续监控日志输出</li><li><code>-u</code> 基于服务筛选(<code>journalctl -f -u kubelet</code> 持续监控kubelet日志)</li><li><code>-n</code> 显示最近n行日志 <code>journalctl -n20</code></li><li><code>-k</code> 查看内容日志</li><li><code>--since</code>/<code>--until</code> 查询某段时间的日志</li></ul></li><li><strong>自定义服务参考<a href="/_posts/arch/nginx.md#基于编译安装tengine">http://blog.aezo.cn/2017/01/16/arch/nginx/</a></strong></li><li><code>systemctl</code>：主要负责控制systemd系统和服务管理器，是<code>chkconfig</code>和<code>service</code>的合并(systemctl管理的脚本文件目录为<code>/usr/lib/systemd/system</code> 或 <code>/etc/systemd/system</code>)<ul><li><code>systemctl start|status|restart|stop nginx.service</code> 启动|状态|重启|停止服务，此处<code>.service</code>可省略，status状态说明<ul><li><code>Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</code>中<code>docker.service</code>为daemon配置文件，第一个<code>disabled</code> 表示服务不是开机启动</li><li><code>Active: active (running)</code> 表示正在运行；<code>Active: inactive (dead)</code> 表示尚未运行；<code>Active: active (exited)</code> 表示服务有效中，但是程序已执行完成(NFS服务正常情况下就是此状态)</li></ul></li><li><code>systemctl list-units --type=service</code> 查看所有服务<ul><li><code>systemctl list-unit-files</code> 查看所有可用单元</li></ul></li><li><code>systemctl enable nginx</code> 设置开机启动</li><li><code>systemctl disable nginx</code> 停止开机启动</li><li><code>systemctl cat sshd</code> 查看服务的配置文件</li><li><strong><code>tail -f /var/log/messages</code></strong> 查看服务启动日志</li></ul></li><li><p><code>chkconfig</code>：提供了一个维护<code>/etc/rc[0~6]d/init.d</code>文件夹的命令行工具</p><ul><li><code>chkconfig --list [nginx]</code> 查看(nginx)服务列表</li><li><code>chkconfig --add nginx</code> 将nginx加入到服务列表(需要 <strong><code>/etc/rc.d/init.d/</code></strong> 软路径<code>/etc/init.d</code> 下有相关文件<code>nginx.service</code>或<code>nginx</code>脚本)<ul><li>用户文件保存在<code>/etc/rc.d/init.d/</code>(用户工作空间)；当执行<code>--add</code>命令后，该目录下的相应脚本会按照运行级别复制到对应级别目录，如<code>/etc/rc.d/rc3.d</code></li></ul></li><li><code>chkconfig --del nginx</code> 关闭指定的服务程序</li><li><code>chkconfig nginx on</code> 设置nginx服务开机自启动（对于 on 和 off 开关，系统默认只对运行级345有效，但是 reset 可以对所有运行级有效）</li><li><p>设置开机自启动</p><ul><li><p>在<code>/etc/init.d</code>目录创建脚本文件，并设置成可执行<code>chmod +x my_script</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自启动脚本的注释中必须有chkconfig、description两行注释(chkconfig会查看所有注释行)</span></span><br><span class="line"><span class="comment"># chkconfig参数一表示在运行级别2345时默认代开(一般服务器的运行级别为3多用户启动)，使用`-`表示默认关闭(不自动启动)；参数2表示启动顺序(越小越优先)；参数3表示停止顺序(停止并不会重新执行脚本，而是停止此进程)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 50 50</span></span><br><span class="line"><span class="comment"># description: 通用自动启动脚本</span></span><br><span class="line"><span class="comment"># processname: common-init</span></span><br><span class="line"><span class="comment"># config: 如果需要的话，可以配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo日志会记录到 /var/log/messages 中(系统本身会记录此服务的启动开始和结束状态)</span></span><br><span class="line"><span class="built_in">echo</span> iptables-init start...</span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables</span><br><span class="line"><span class="built_in">echo</span> iptables-init end...</span><br></pre></td></tr></table></figure></li><li><p><strong>将启动脚本添加到chkconfig列表</strong>：<code>chkconfig --add my_script</code></p></li><li>之后可在<code>/var/log/messages</code>中查看启动日志信息；也可通过<code>systemctl status my_script</code>查看服务状态，如<code>active (exited)</code>表示服务有效中，但是程序已执行完成</li></ul></li></ul></li><li><code>service</code>：<code>service nginx start|stop|reload</code> 服务启动等命令</li></ul><h3 id="开机启动设置"><a href="#开机启动设置" class="headerlink" title="开机启动设置"></a>开机启动设置</h3><ul><li>参考<a href="/_posts/linux/centos.md#启动原理及设置">centos.md#启动原理及设置</a></li></ul><h3 id="bash使用"><a href="#bash使用" class="headerlink" title="bash使用"></a>bash使用</h3><ul><li><code>Tab</code> 自动补全</li><li><code>ctrl-w</code> 删除键入的最后一个单词</li><li><code>ctrl-u</code>/<code>ctrl-k</code> 删除行内光标所在位置之前/之后的所有内容</li><li><code>ctrl-a</code>/<code>ctrl-e</code> 可以将光标移至行首/行尾</li><li><code>alt-b</code>/<code>alt-f</code> 以单词为单位移动光标</li><li><code>ctrl-r</code> 搜索命令行历史记录(重复按下 ctrl-r 会向后查找匹配项)</li><li><code>ctrl-l</code> 可以清屏</li></ul><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><p>参考 <a href="/_posts/linux/shell.md">《Shell编程》http://blog.aezo.cn/2017/01/10/linux/shell/</a></p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><ul><li>文本处理命令：<code>cut</code>、<code>sort</code>、<code>join</code>、<code>sed</code>、<code>awk</code> 参考下文</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul><li><code>df -h</code> 查看磁盘使用情况、分区、挂载点(<strong>只会显示成功挂载的分区，新磁盘需要进行分区和挂载</strong>)<ul><li><code>df -h /home/smalle</code> 查询目录使用情况、分区、挂载点（一般/dev/vda1为系统挂载点，重装系统数据无法保留；/dev/vab或/dev/mapper/centos-root等用来存储数据）</li><li><code>df -Th</code> 查询文件系统格式</li></ul></li><li><code>du -ahm --max-depth=1 | sort -nr | head -10</code> <strong>查看当前目录以及一级子目录磁盘使用情况。二级子目录可改成2，并按从大倒小排列</strong>(查看大目录)<ul><li><code>du</code> 它的数据是基于文件获取，可以跨多个分区操作。<code>df</code>它的数据基于分区元数据，只能针对整个分区</li><li>参数说明<ul><li><code>-a</code> 所有文件，包括目录和普通文件，默认只统计目录</li><li><code>-h</code> 显示人类可读的文件大小</li><li><code>-m</code> 已MB大小为单位</li></ul></li><li><code>du -hsx * | sort -rh | head -10</code> 查看最大的10个文件</li><li><code>du -sh /home/smalle | sort -h</code> 查看某个目录</li><li><code>find . -type f -size +500M -print0 | xargs -0 du -hm | sort -nr</code> 查看大于500M的前10个文件(查看大文件)</li></ul></li><li><code>lsblk</code> <strong>树形显示磁盘即分区</strong><ul><li><code>fdisk -l</code> 查看磁盘设备</li><li><code>ll /dev | grep disk</code>查看磁盘设备</li></ul></li><li><code>findmnt</code> 查看所有挂载的目录</li><li><code>dmesg -T | grep CD</code> 显示光盘信息，<code>-T</code>时间格式化。<strong>其中dmesg为显示硬件信息，可用于硬件故障诊断</strong></li><li><code>alias ll=&#39;ls -latr&#39;</code> 定义一个命令别名(仅当前会话生效)，也可将别名保存在<code>~/.bashrc</code>(所有会话)</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li><code>touch &lt;fileName&gt;</code> 新建文件(linux下文件后缀名无实际意义)</li><li><code>vi &lt;fileName&gt;</code> 编辑文件<ul><li><code>vim &lt;fileName&gt;</code> 编辑文件，有的可能默认没有安装vim</li></ul></li><li><code>&gt; &lt;file&gt;</code> 清空文件内容</li><li><code>rm &lt;file&gt;</code> 删除文件<ul><li><code>rm -rf</code> 强制删除某个文件或文件夹(recursion递归、force强制)</li><li>提示 <code>rm: remove regular file &#39;test&#39;?</code> 时，在后面输入 <code>yes或y</code> 回车</li><li><code>rm -f *2019-04*</code> 正则删除，可删除如access-2019-04-01.log、error-2019-04-02.log</li></ul></li><li><code>cp xxx.txt /usr/local/xxx</code> 复制文件(将xxx.txt移动到/usr/local/xxx)<ul><li><code>cp -r /dir1 /dir2</code> 将dir1的数据复制到dir2中（<code>-r</code>递归复制，如果dir1下还有目录则需要）</li><li><code>/bin/cp -f /dir1/test /dir2</code> <strong>强制覆盖文件</strong><ul><li>此处使用<code>cp -f</code>可能失效，由于cp命令被系统默认设置了别名<code>alias cp=cp -i</code>(-i, –interactive表示需要交互进行确认，同样的如mv)</li><li><code>alias</code> 查看被重写的命令，<code>unalias cp</code>取消cp的别名(不建议取消)</li></ul></li></ul></li><li><code>scp</code> 跨机器文件传输<ul><li>scp免密登录需要将客户端的公钥放到服务器</li><li><code>-r</code> 递归复制整个目录</li><li>复制文件/文件夹(需加-r属性)到远程服务器<ul><li><code>scp -r /home/test root@192.168.1.1:/home/dir</code> 将本地linux系统的/home/test文件或目录(及其子目录)复制到远程的home目录下(本地和远程目录要么都以/结尾，要么都不要/)。<strong>需要提前创建目标目录的父目录</strong></li></ul></li><li>从远程服务器传输文件到本地<ul><li><code>scp -r root@192.168.1.1:/opt/soft/test /opt/soft/</code> 下载远程 /opt/soft/test 文件或目录(及其子目录)到本地的 /opt/soft/ 目录来</li><li><code>scp -r root@192.168.1.1:/home/test/2018* .</code> 将远程目录的2018开头的文件夹及其子文件复制到本地当前目录(备份)</li><li>“scp jdk-8u202-linux-x64.rpm root@node02:<code>pwd</code>“(pwd用锐音符包裹) 将文件复制到另一台机器的相同目录</li></ul></li></ul></li><li><code>mv a.txt /home</code> 移动a.txt到/home目录<ul><li><code>mv a.txt b.txt</code> 将a.txt重命名为b.txt</li><li><code>mv a.txt /home/b.txt</code> 移动并重名名</li></ul></li><li><code>ln my.txt my_link</code> 创建硬链接(在当前目录为my.txt创建一个my_link的文件并将这两个文件关联起来)<ul><li><code>ln -s /home/dir /home/my_link_soft</code> 对某一目录所有文件创建软链接(相当于快捷方式)，无需提前创建目录<code>/home/my_link_soft</code>(如果/home/dir存则则软连接显示绿色，如果不存在，软连接显示红色)<ul><li><code>rm -f /home/my_link_soft</code> <strong>删除软链接</strong>(源目录的文件不会被删除)</li><li><code>rm -f /home/my_link_soft/</code> <strong>删除软链接下的文件</strong>(源目录的文件全部被删除；软链接仍然存在)</li></ul></li><li>修改原文件，硬链接对应的文件也会改变；删除原文件，硬链接对应的文件不会删除，软连接对应的文件会被删除</li><li>目录无法创建硬链接，可以创建软链接</li></ul></li><li><code>cat/more/less/head/tail/tac/nl</code> 输出文件内容<ul><li><code>more</code> 分页显示文件内容(按空格分页)<ul><li>向后翻一屏：<code>SPACE</code>；向前翻一屏：<code>b</code>；向后翻一行：<code>ENTER</code>；向前翻一行：<code>k</code></li></ul></li><li><code>less</code> 查看文件前几行(一行行的显示)，类似more但功能更多</li><li><code>tac</code> 从文末开始显示文件内容(cat反正写)</li><li><code>head -3</code> 显示文件头部的3行</li><li><code>tail -3</code> 显示文件末尾的3行<ul><li><code>tail -f /var/log/messages</code></li><li><code>-f</code> 表示它将会以一定的时间实时追踪该档的所有更新（查看服务启动日志）</li><li><code>-F</code> 等同于 –follow=name –retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪</li></ul></li><li><code>cat -n &lt;fileName&gt;</code> <strong>输出文件内容，并显示行号</strong></li><li><code>cat &gt; fileName</code> 创建文件并书写内容，此时会进入书写模式，Ctrl+C保存书写内容</li><li><code>nl &lt;fileName&gt;</code> 显示文件行号(类似cat -n)</li></ul></li><li><code>whereis &lt;binName&gt;</code> 查询可执行文件位置<ul><li><code>which &lt;exeName&gt;</code> 查询可执行文件位置 (在PATH路径中寻找)</li><li><code>echo $PATH</code> 打印环境变量</li></ul></li><li><code>stat &lt;file&gt;</code> <strong>查看文件的详细信息</strong></li><li><code>file &lt;fileName&gt;</code> 查看文件属性</li><li><code>basename &lt;file&gt;</code> 返回一个字符串参数的基本文件名称。如：<code>basename /home/smalle/test.txt</code>返回test.txt</li><li><code>wc &lt;file&gt;</code> 统计指定文本文件的行数、字数、字节数<ul><li><code>wc -l &lt;file&gt;</code> 查看行数</li></ul></li><li><p><a href="https://www.netadmintools.com/html/lsof.man.html" target="_blank" rel="noopener">lsof</a> 列出打开文件(lists openfiles), linux一切皆文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lsof -h</span><br><span class="line">    <span class="comment"># -a: 结果进行“与”运算（而不是“或”）</span></span><br><span class="line">    <span class="comment"># -t: 仅获取进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示与指定目录或文件交互的所有一切</span></span><br><span class="line">lsof /var/<span class="built_in">log</span>/messages/</span><br><span class="line">lsof /var/<span class="built_in">log</span>/messages/my.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定用户打开的文件</span></span><br><span class="line">lsof -u root</span><br><span class="line"><span class="comment"># 杀死指定用户开启的所有进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 `lsof -t -u apache`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列举删除的文件仍然占用空间的文件(从而导致du/df统计的值不一致)</span></span><br><span class="line">lsof | grep deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前进程的文件描述符</span></span><br><span class="line">lsof -op $$</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</span></span><br><span class="line"><span class="comment"># 显示所有IPv4连接</span></span><br><span class="line">lsof -i</span><br><span class="line">lsof -i :22</span><br></pre></td></tr></table></figure></li><li><p><code>ls</code> 列举文件 <a href="http://www.cnblogs.com/kzloser/articles/2673790.html" title="Linux文件属性" target="_blank" rel="noopener">^3</a></p><ul><li><code>ll</code> 列举文件详细<ul><li><strong><code>ll test*</code></strong>/<code>ls *.txt</code> 模糊查询文件</li><li><strong><code>ll -rt *.txt</code></strong> 按时间排序 (<code>-r</code>表示逆序、<code>-t</code>按时间排序)</li><li><strong><code>ll -Sh</code></strong> 按文件大小排序 (<code>-S</code>按文件大小排序、<code>-h</code>将文件大小按1024进行转换显示M/G等)</li></ul></li><li><code>ls -al</code> 列举所有文件详细(<code>-a</code>全部、<code>-l</code>纵向显示. linux中<code>.</code>开头的文件默认为隐藏文件)<blockquote><p>文件详细如下图</p><p><img src="/data/images/2017/02/文件详细.jpg" alt="文件详细"></p><p>类型与权限如下图</p><p><img src="/data/images/2017/02/类型与权限.png" alt="类型与权限"></p><ul><li>第一个字符代表这个文件的类型(如目录、文件或链接文件等等)：<ul><li>[ d ]则是目录、[ - ]则是文件、[ l ]则表示为链接档(link file)、[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)、[ c ]则表示为装置文件里面的串行端口设备,例如键盘、鼠标(一次性读取装置)</li></ul></li><li>接下来的字符中,以三个为一组,且均为『rwx』 的三个参数的组合&lt; [ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute) 要注意的是,这三个权限的位置不会改变,如果没有权限,就会出现减号[ - ]而已&gt;<ul><li>第一组为『文件拥有者的权限』、第二组为『同群组的权限』、第三组为『其他非本群组的权限』</li><li>当 s 标志出现在文件拥有者的 x 权限上时即为特殊权限。特殊权限如 SUID, SGID, SBIT</li></ul></li></ul></blockquote></li></ul></li><li><code>find</code><ul><li><code>sudo find / -name nginx.conf</code> 全局查询文件位置(查看<code>nginx.conf</code>文件所在位置)</li><li><code>find ./ -mtime +30 -name &quot;*.gz&quot; | xargs ls -lh</code> 查询当前目录或子目录(./可省略)中30天之前的gz压缩包文件</li><li><code>find ./ -mtime +30 -name &quot;*.gz&quot; | [sudo] xargs rm -rf</code> 删除30天之前的gz压缩文件</li></ul></li><li>lrzsz上传下载文件，小型文件可通过此工具完成。需要安装<code>yum install lrzsz</code><ul><li><code>rz</code> 跳出窗口进行上传</li><li><code>sz 文件名</code> 下载文件</li></ul></li></ul><h3 id="文件夹-目录"><a href="#文件夹-目录" class="headerlink" title="文件夹/目录"></a>文件夹/目录</h3><ul><li><code>mkdir &lt;dirName&gt;</code> 新建文件夹(或者用绝对路径 <code>mkdir /usr/local/DirName</code>)<ul><li><code>mkdir -p &lt;dirName&gt;</code> 会创建此目录需要的父目录</li></ul></li><li><code>rmdir &lt;dirName&gt;</code> 删除文件夹 (如果文件夹不为空则无法删除)<ul><li><code>rm -rf &lt;dirName&gt;</code> 强制删除文件夹和其子文件夹<ul><li><code>-r</code> 就是向下递归，不管有多少级目录，一并删除</li><li><code>-f</code> 就是直接强行删除，不作任何提示的意思</li></ul></li></ul></li><li><code>cd &lt;dirName&gt;</code> 进入到某目录<ul><li><code>cd ..</code> 返回上一级目录</li><li><code>cd /usr/local/xxx</code> 返回某一级目录</li><li><code>cd ~</code>或<code>cd回车</code> 返回家目录</li></ul></li><li><code>pwd</code> 查看当前目录完整路径<ul><li><code>pwdx $$</code> 查看当前进程启动文件所在目录，返回如<code>36240: /root</code>；<code>pwdx 10000</code>查看某个进程</li><li><code>echo ${PWD}</code> 查看当前目录绝对路径，如<code>/root/test</code></li><li><code>echo ${PWD##*/}</code> 查看当前目录名，如<code>test</code></li></ul></li><li><code>tree mydir</code> 树形展示目录</li></ul><h3 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h3><ul><li>参考《阿里云服务器 ECS &gt; 块存储 &gt; 云盘 &gt; 分区格式化数据盘 &gt; Linux 格式化数据盘》 <a href="https://help.aliyun.com/document_detail/108501.html" title="云服务器 ECS &gt; 块存储 &gt; 云盘 &gt; 分区格式化数据盘 &gt; Linux 格式化数据盘" target="_blank" rel="noopener">^10</a></li><li>一般阿里云服务器买的磁盘未进行格式化文件系统和挂载，<code>df -h</code>无法查询到磁盘设备，只能通过<code>fdisk -l</code>查看磁盘设备</li><li>阿里云<code>/dev/vda</code>表示系统盘，<code>/dev/vdb-z</code>表示数据盘，<code>dev/xvd?</code>表示非I/O优化实例。<code>/dev/vda1</code>/<code>/dev/vdb1</code>表示对应磁盘上的分区</li><li>无法卸载，提示<code>umount.nfs: /data: device is busy</code>时，可使用<code>fuser</code>(<code>yum install -y psmisc</code>安装)查看占用资源用户和进程信息(<code>fuser -m -v /data/</code>)，并退出相关进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **最好使用root用户进行操作，`fdisk -l`一般用户查询不到**</span></span><br><span class="line"><span class="comment"># 查看磁盘设备。包括系统盘和数据盘，如：Disk：/dev/vda ... Disk：/dev/vdb表示有两块磁盘</span></span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/dev/vdb磁盘设备的分区情况(/dev/vdb1表示此磁盘的第一个分区)</span></span><br><span class="line">fdisk -l /dev/vdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.进行磁盘分区</span></span><br><span class="line">fdisk /dev/vdb</span><br><span class="line"><span class="comment"># 输入`p`：查看数据盘的分区情况(输入m获取帮助)</span></span><br><span class="line"><span class="comment"># 再次输入`n`：创建一个新分区</span></span><br><span class="line"><span class="comment"># 分区类型选择（p主分区, e扩展分区），新磁盘第一次分区可选择主分区，输入p; 分区号码从1-4，可以输入最小可用分区号</span></span><br><span class="line"><span class="comment"># 第一个扇区一般都使用默认的，直接回车即可；最后一个扇区大小根据你自己需要指定，但是一定要在给定范围内，这里是2048-20971519(10G的磁盘，=1024*1024*2*10G，此处需要多乘以2)，如果整个磁盘就分一个分区则继续回车(默认即为最大)，如根需要此分区设置大小为200M，则输入`+200M`（单位可为K/M/G/T/P）</span></span><br><span class="line"><span class="comment"># 再次输入`p`查看将要到达的分区情况</span></span><br><span class="line"><span class="comment"># 确认后输入`w`写入分区表，并在写入后退出；输入`q`放弃分区并退出</span></span><br><span class="line"><span class="comment"># 到这里分区就完成了，但是新的分区还是不能使用的，要对新分区进行格式化，然后将它挂载到某个可访问目录下才能进行操作</span></span><br><span class="line">    <span class="comment"># 如果w后提示 WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line">    <span class="comment"># 为了不reboot就能生效，强制内核重新读取分区表，执行命令`partprobe`后继续后续命令</span></span><br><span class="line">    <span class="comment"># partprobe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分区(未挂载的分区也会显示)</span></span><br><span class="line">cat /proc/partitions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.为此分区创建一个ext4文件系统，此时会格式化磁盘. 如果需要在 Linux、Windows 和 Mac 系统之间共享文件，可以使用 mkfs.vfat 创建 VFAT 文件系统</span></span><br><span class="line">mkfs.ext4 /dev/vdb1 <span class="comment"># centos7默认xfs文件格式，此时可使用 mkfs.xfs /dev/vdb1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用LVM功能，则需先执行LVM相关命令创建LV分区后再挂载</span></span><br><span class="line"><span class="comment"># 3.挂载分区到/home目录(需要确保此目录存在，并不会影响父目录的挂载。如此时只会改变 /home，不会影响 /)，**如果/home目录之前有数据会被清除，建议先备份**</span></span><br><span class="line">mount /dev/vdb1 /home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.备份 /etc/fstab（建议）</span></span><br><span class="line">cp /etc/fstab /etc/fstab.bak</span><br><span class="line"><span class="comment"># 向 /etc/fstab 写入新分区信息(注意目录和上面对应)，防止下次开机挂载丢失（不执行此步骤只是临时挂载到相应目录，下次开机则会丢失挂载）</span></span><br><span class="line"><span class="built_in">echo</span> /dev/vdb1 /home ext4 defaults 0 0 &gt;&gt; /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前磁盘空间和使用情(只会显示成功挂载的分区)</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新挂载了磁盘需要重启</span></span><br><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure><h3 id="LVM使用"><a href="#LVM使用" class="headerlink" title="LVM使用"></a>LVM使用</h3><ul><li>centos安装时如果使用分区类型为LVM则会出现时/dev/mapper/centos-root等</li><li><p>LVM使用参考 <a href="https://blog.51cto.com/13438667/2084924" target="_blank" rel="noopener">https://blog.51cto.com/13438667/2084924</a></p><p> <img src="/data/images/lang/lvm.png" alt="lvm"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **先 fdisk 创建分区 /dev/vdb1 和 /dev/vdb2，无需格式化(略)**</span></span><br><span class="line"><span class="comment"># pvcreate命令在新建的分区上创建PV</span></span><br><span class="line">pvcreate /dev/vdb1 /dev/vdb2</span><br><span class="line"><span class="comment"># 查看pv详细信息</span></span><br><span class="line">pvs/pvdisplay</span><br><span class="line"><span class="comment"># vgcreate命令创建一个VG组，并将创建的两个PV加入VG组</span></span><br><span class="line">vgcreate vg1 /dev/vdb1 /dev/vdb2 <span class="comment"># 组名vg1</span></span><br><span class="line"><span class="comment"># 查看卷组信息</span></span><br><span class="line">vgs/vgdisplay</span><br><span class="line"><span class="comment"># 在vg1卷组下创建一个逻辑卷lv1，对应路径为/dev/vg1/lv1</span></span><br><span class="line"><span class="comment"># 此时lv1可能会同时使用/dev/vdb1 /dev/vdb2这两个PV，这也是LVM一个PV损毁会导致整个卷组数据损毁</span></span><br><span class="line"><span class="comment"># **可通过VG来分区(如取home、data两个卷组分别挂载到/home、/data；初始化时可初始化名为/dev/home/main的LV)，之后对该分区扩容只需往相应VG中加PV即可**</span></span><br><span class="line">lvcreate -L 199G -n lv1 vg1 <span class="comment"># 如果200G的卷组，此时无法正好创建出一个200G的LV，需稍微少一点。最终显示成 /dev/vg1/lv1</span></span><br><span class="line"><span class="comment"># 查看逻辑卷详细</span></span><br><span class="line">lvs/lvsdisplay</span><br><span class="line"><span class="comment"># 格式化卷组</span></span><br><span class="line">mkfs.xfs /dev/vg1/lv1</span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">mount /dev/vg1/lv1 /home/data <span class="comment"># df -h显示/dev/mapper/vg1-lv1</span></span><br><span class="line"><span class="comment"># 写入fstab</span></span><br><span class="line"><span class="built_in">echo</span> /dev/vg1/lv1 /home/data xfs defaults 0 0 &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>调整同VG下不同LV的大小，如调整home和root容量大小如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果centos卷组有额外的空间，如加入了物理卷，则无需减少home分区容量</span></span><br><span class="line">cp -r /home/ homebak/ <span class="comment"># 备份/home(建议打成tar)</span></span><br><span class="line">umount /home <span class="comment"># 卸载​ /home</span></span><br><span class="line"><span class="comment"># 删除某LVM分区(需要先备份数据，并取消挂载)</span></span><br><span class="line">lvremove /dev/mapper/centos-home</span><br><span class="line"></span><br><span class="line"><span class="comment">### =========扩展分区</span></span><br><span class="line"><span class="comment"># 只要/dev/mapper/centos-root(LV)对应的卷组(VG)有额外的空间即可扩展</span></span><br><span class="line">lvextend -L +20G /dev/mapper/centos-root <span class="comment"># 扩展/root所在的lv</span></span><br><span class="line"><span class="comment"># resize2fs 针对的是ext2、ext3、ext4文件系统；xfs_growfs 针对的是xfs文件系统</span></span><br><span class="line">xfs_growfs /dev/mapper/centos-root <span class="comment"># 激活修改的配置</span></span><br><span class="line"><span class="comment">### =========扩展分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复原来的home分区</span></span><br><span class="line">vgdisplay <span class="comment"># 其中的Free PE表示LVM分区剩余的可用磁盘</span></span><br><span class="line">lvcreate -L 100G -n home centos <span class="comment"># 重新创建home lv 分区的大小</span></span><br><span class="line">mkfs.xfs /dev/centos/home <span class="comment"># 创建文件系统</span></span><br><span class="line">mount /dev/centos/home /home <span class="comment"># 挂载 home</span></span><br><span class="line"><span class="comment"># 使永久有效，写入 etc/fstab 见上文</span></span><br></pre></td></tr></table></figure></li><li><p>调整磁盘大小(慎用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### vg</span></span><br><span class="line"><span class="comment">## 扩展vg</span></span><br><span class="line">pvcreate /dev/sdc1 <span class="comment"># 将新的磁盘分区创建为pv</span></span><br><span class="line">vgextend centos /dev/sdc1 <span class="comment"># 将pv添加大vg组</span></span><br><span class="line"><span class="comment">## 缩小vg</span></span><br><span class="line">vgreduce centos /dev/sdc1 <span class="comment"># 将一个PV从指定卷组中移除</span></span><br><span class="line">pvremove /dev/sdc1 <span class="comment"># 移除对应pv</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### pv</span></span><br><span class="line"><span class="comment">## 重设物理分区为120g。调整PV大小(进而缩小了VG的大小)</span></span><br><span class="line">pvresize --setphysicalvolumesize 120g /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment">### lv (xfs分区是不支持减小操作的)</span></span><br><span class="line"><span class="comment">## 直接调整大小</span></span><br><span class="line">lvresize -L 500M -r /dev/mapper/centos-home <span class="comment"># -r 相当于 resize2fs</span></span><br><span class="line"><span class="comment">## 缩小lv大小到10g</span></span><br><span class="line">umount /dev/mapper/centos-home</span><br><span class="line"><span class="comment"># e2fsck -f /dev/mapper/centos-home</span></span><br><span class="line">resize2fs /dev/mapper/centos-home 10G <span class="comment"># 缩小文件系统</span></span><br><span class="line">lvreduce -L -10G /dev/mapper/centos-home <span class="comment"># 缩小lv</span></span><br><span class="line"><span class="comment">## 扩展lv</span></span><br><span class="line">lvextend -L +2G /dev/mapper/centos-home</span><br><span class="line"><span class="comment"># resize2fs /dev/mapper/centos-home # 更新文件系统。resize2fs 针对的是ext2、ext3、ext4文件系统；xfs_growfs 针对的是xfs文件系统</span></span><br><span class="line">xfs_growfs /dev/mapper/centos-home</span><br></pre></td></tr></table></figure></li><li><p>重命名VG、LV(无需umount和备份，数据也不会丢失)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看并记录基本信息。需要将/dev/hdd/hdd1改成/dev/vdisk/main</span></span><br><span class="line">vgs/lvs</span><br><span class="line">vgrename hdd vdisk</span><br><span class="line">lvrename /dev/vdisk/hdd1 main <span class="comment"># 修改lv，注意此时vg为新的</span></span><br><span class="line">vi /etc/fstab <span class="comment"># 修改之前的挂载信息</span></span><br></pre></td></tr></table></figure></li><li><p>删除lvm磁盘挂载，直接删除/etc/fstab中对应条目，lvm相关配置会自动去掉</p></li></ul><h3 id="压缩包-推荐tar-1"><a href="#压缩包-推荐tar-1" class="headerlink" title="压缩包(推荐tar) ^1"></a>压缩包(推荐tar) <a href="http://www.jb51.net/LINUXjishu/43356.html" title="文件压缩与解压" target="_blank" rel="noopener">^1</a></h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><ul><li>解压：<strong><code>tar -zxvf archive.tar.gz -C /tmp</code></strong> 解压tar包，将gzip压缩包释放到/tmp目录下(tar不存在乱码问题)<ul><li><code>tar -xvf archive.tar</code> 表示解压到当前目录</li></ul></li><li>压缩：<strong><code>tar -zcvf aezocn.tar.gz file1 file2 *.jpg dir1</code></strong> 将此目录所有jpg文件和dir1目录打包成aezocn.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为aezocn.tar.gz(体积会小很多：1/10). windows可使用7-zip</li><li>参数说明<ul><li>独立命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个<ul><li><strong><code>-x</code></strong>：解压</li><li><strong><code>-c</code></strong>: 建立压缩档案</li><li><code>-t</code>：查看 tarfile 里面的文件</li><li><code>-r</code>：向压缩归档文件末尾追加文件</li><li><code>-u</code>：更新原压缩包中的文件</li></ul></li><li>必须<ul><li><strong><code>-f</code></strong>：使用档案名字，<strong>切记这个参数一般放在后面，后面只能接档案名</strong></li></ul></li><li>解/压缩类型(可选)<ul><li><code>-z</code>：有gzip属性的(archive.tar.gz)，<strong>文件必须是以.gz/.gzip结尾</strong></li><li><code>-J</code>：有xz属性的(archive.tar.xz)</li><li><code>-j</code>：有bz2属性的(archive.tar.bz2)</li><li><code>-Z</code>：有compress属性的(archive.tar.Z)</li></ul></li><li>其他可选<ul><li><strong><code>-v</code></strong>：显示所有过程</li><li><strong><code>-C</code></strong> 解压到指定目录(默认是当前目录)</li><li><strong><code>-P</code></strong> 可以使用绝对路径来压缩。*nix系统中，使用tar对文件打包时，一般不建议使用绝对路径<ul><li><code>tar -zcvPf /home/test/demo.tar.gz /home/test/demo</code> 生成的压缩包包含绝对路径</li><li><code>tar -zxcPf /home/test/demo.tar.gz</code> 解压也要带上<code>-P</code>，从而解压出文件/home/test/demo，否则解压出文件<code>~/home/test/demo</code>(在当前目录再创建原根目录)</li></ul></li><li><code>-p</code> 使用原文件的原来属性（属性不会依据使用者而变）</li><li><code>-O</code>：将文件解开到标准输出</li></ul></li></ul></li></ul><h4 id="gz"><a href="#gz" class="headerlink" title="gz"></a>gz</h4><ul><li><code>zcat test.sql.gz &gt; test.sql</code> 解压。如果不输出到文件，则直接打印</li></ul><h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h4><ul><li><code>unzip file.zip</code> 解压zip</li><li><code>zip aezocn.zip *.jpg</code> zip格式的压缩，需要先下载<code>zip for linux</code></li><li><p>unzip乱码</p><ul><li><p>使用python解决(只能解决部分问题)</p><ul><li><code>vi pyzip</code> 新建文件pyzip</li><li><p>加入代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># pyzip.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Processing File "</span> + sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">file=zipfile.ZipFile(sys.argv[<span class="number">1</span>],<span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> file.namelist():</span><br><span class="line">    utf8name=name.decode(<span class="string">'gbk'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Extracting "</span> + utf8name</span><br><span class="line">    pathname = os.path.dirname(utf8name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(pathname) <span class="keyword">and</span> pathname!= <span class="string">""</span>:</span><br><span class="line">        os.makedirs(pathname)</span><br><span class="line">    data = file.read(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(utf8name):</span><br><span class="line">        fo = open(utf8name, <span class="string">"w"</span>)</span><br><span class="line">        fo.write(data)</span><br><span class="line">        fo.close</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li><li><p><code>chmod +x pyzip</code> 将pyzip设置成可执行文件</p></li><li><code>./uzip /home/xxxx.zip</code></li></ul></li></ul></li></ul><h4 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装</span></span><br><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-5.9.1.tar.gz</span><br><span class="line">tar -xzvf rarlinux-x64-5.9.1.tar.gz -C /usr/<span class="built_in">local</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/rar/rar /usr/<span class="built_in">local</span>/bin/rar</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/rar/unrar /usr/<span class="built_in">local</span>/bin/unrar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压rar。e: 解压文件到当前目录</span></span><br><span class="line">unrar e archive.rar</span><br><span class="line"><span class="comment"># 压缩成rar格式</span></span><br><span class="line">rar a aezocn.rar *.jpg</span><br></pre></td></tr></table></figure><h3 id="文件误删恢复"><a href="#文件误删恢复" class="headerlink" title="文件误删恢复"></a>文件误删恢复</h3><ul><li><code>debugfs</code> <a href="https://www.cnblogs.com/lidm/p/5833273.html" target="_blank" rel="noopener">https://www.cnblogs.com/lidm/p/5833273.html</a> (不支持xfs文件格式的恢复)</li></ul><h2 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h2><ul><li><p>设置：vi/vim对应启动脚本<code>vi ~/.vimrc</code>或<code>vi ~/.exrc</code>(<code>sudo vi xxx</code>，需要设置root家目录的此配置文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=4 <span class="comment"># 设置tab键为4个空格</span></span><br><span class="line"><span class="built_in">set</span> nu <span class="comment"># 显示行号(复制时容易复制到行号)</span></span><br><span class="line"><span class="built_in">set</span> nonu <span class="comment"># 不显示行号</span></span><br></pre></td></tr></table></figure><ul><li>vim粘贴带注释的数据格式混乱，使用vi无此问题</li></ul></li><li><code>vi/vim my.txt</code> 打开编辑界面(总共两种模式，默认是命令模式；无此文件最终保存后会自动新建此文件)<ul><li><code>insert</code> 进入编辑模式</li><li><code>esc</code> 退出编辑模式(进入命令模式)</li><li><code>shift+:</code> 命令模式下开启命令输入</li></ul></li><li>打开文件<ul><li><code>vi +5 &lt;file&gt;</code> 打开文件，并定位于第5行</li><li><code>vi + &lt;file&gt;</code> 打开文件，定位至最后一行</li><li><code>vi +/&lt;pattern&gt; &lt;file&gt;</code> 打开文件，定位至第一次被pattern匹配到的行的行，按字母<code>n</code>查找下一个</li></ul></li></ul><h3 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h3><ul><li>关闭文件<ul><li><code>:wq</code>/<code>:x</code> 保存并退出</li><li><code>:q!</code> <strong>不保存退出（可用于readonly文件的关闭）</strong>，<code>:q</code> 普通退出</li><li><code>:x!</code> <strong>强制保存退出</strong></li><li><code>:w !sudo tee %</code> <strong>对一个没有权限的文件强制修改保存的命令</strong></li><li>编辑模式下输入大写<code>ZZ</code>保存退出</li></ul></li><li>光标移动<ul><li><code>j</code> 下</li><li><code>k</code> 上</li><li><code>h</code> 左</li><li><code>l</code> 右</li><li><code>w</code> 移至下一个单词的词</li></ul></li><li>行内跳转<ul><li><code>:0</code> 绝对行首(<code>:10</code> 跳转至第10行)</li><li><code>:$</code> 绝对行尾</li><li><code>shift+g/G</code> 最后一行</li></ul></li><li>翻屏<ul><li><code>Ctrl+f</code> 向下翻一屏</li><li><code>Ctrl+b</code> 向上翻一屏</li></ul></li><li>删除命令 <code>d</code><ul><li><code>dd</code> <strong>删除光标所在行</strong></li><li><code>ndd</code> <strong>删除光标以下#行(含光标行)</strong>，如<code>2dd</code>删除2行(光标行和光标下一行)</li><li><code>dw</code> 删除一个单词</li><li><code>:.,$-1d</code> <strong>删除从之前关标所在行到倒数第二行</strong>(<code>.</code> 表示当前行；<code>$</code> 最后一行；<code>+n</code> 向下的n行；<code>-n</code> 向上的n行)<ul><li><code>dG</code> 删除当前行到下面所有行</li><li><code>:.,$y</code> 复制当前行到最后一行</li><li><code>:.,$s/#//</code> 将当期行到最后一行的#替换为空</li></ul></li><li><code>x</code> 删除光标所在处的单个字符</li><li><code>nx</code> 删除光标所在处及向后的共n个字符</li></ul></li><li><strong>新加一行</strong> <code>o</code></li><li>复制命令 <code>y</code>命令，用法同<code>d</code>命令。<strong>和粘贴命令<code>p</code>组合使用</strong><ul><li><code>yy</code> 复制一行：把光标移动到要复制的行上 - yy - 把光标移动到要复制的位置 - p</li><li><code>nyy</code> 复制n行</li></ul></li><li>粘贴命令 <code>p</code>/<code>P</code><ul><li><code>p</code>：粘贴到下、后。如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；</li><li><code>P</code>：粘贴到上、前。</li></ul></li><li>查找<ul><li><code>/&lt;pattern&gt;</code> 查找pattern匹配表达式</li><li><code>n</code> 基于以上表达式向下查询</li><li><code>N</code> 向上查询</li></ul></li><li>查找替换 <code>s</code><ul><li><code>&lt;row1&gt;,&lt;row2&gt;s@&lt;pattern&gt;@&lt;string&gt;@gi</code> 从第row1行到第row2行根据pattern匹配到后全局(g)忽略大小写(i)并替换成string</li><li><code>$</code>标识末行，<code>%</code>全文(<code>&lt;row1&gt;,&lt;row2&gt;</code>用<code>%</code>代替)</li></ul></li><li>撤销<ul><li><code>u</code> <strong>撤销上一步操作</strong></li><li><code>Ctrl+r</code> <strong>恢复上一步被撤销的操作</strong></li><li><code>Ctrl+v</code> 进入列编辑模式</li></ul></li><li>行号<ul><li><code>set number</code>/<code>set nu</code> 显示行号(命令模式执行该命令)</li><li><code>set nonu</code> 不显示行号</li><li>永久显示行号：在<code>/etc/virc</code>或<code>/etc/vimrc</code>中加入一行<code>set nu</code></li></ul></li><li>批量注释<ul><li><code>Ctrl+v</code> 进入列编辑模式，在需要注释处移动光标选中需要注释的行</li><li><code>Shift+i</code></li><li>再插入注释符，比如按<code>#</code>或者<code>//</code></li><li>按<code>Esc</code>即可全部注释</li></ul></li><li>批量删除注释：<code>ctrl+v</code>进入列编辑模式，横向选中列的个数(如”//“注释符号需要选中两列)，然后按<code>d</code>就会删除注释符号</li><li><strong>跟shell交互</strong>：<code>:! COMMAND</code> 在命令模式下执行外部命令，如mkdir</li></ul><h2 id="权限系统"><a href="#权限系统" class="headerlink" title="权限系统"></a>权限系统</h2><h3 id="用户管理-6"><a href="#用户管理-6" class="headerlink" title="用户管理 ^6"></a>用户管理 <a href="http://www.cnblogs.com/zutbaz/p/4248845.html" title="用户配置" target="_blank" rel="noopener">^6</a></h3><ul><li><p><code>useradd test</code> 新建test用户(默认在/home目录新建test对应的家目录test)</p><ul><li><code>useradd -d /home/aezo -m aezo</code> 添加用户(和设置宿主目录)</li><li><code>usermod -d /home/home_dir -U aezo</code> 修改用户宿主目录</li><li><code>useradd -r -g mysql mysql</code> <strong>添加用户mysql，并加入到mysql用户组</strong><ul><li><code>-r</code> 表示mysql用户是一个系统用户，不能登录</li></ul></li><li><p>修改用户名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将old修改为new</span></span><br><span class="line">sudo pkill -9 -u old <span class="comment"># 关闭旧用户session</span></span><br><span class="line">sudo usermod -l new old</span><br><span class="line">sudo usermod -d /home/new -m new <span class="comment"># 修改用户目录(之前目录数据不会丢失)</span></span><br><span class="line">sudo groupmod -n new old <span class="comment"># 修改用户组</span></span><br><span class="line"><span class="comment"># 其他配置文件中保存的用户名和用户目录并不会被修改</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>passwd aezo</code> 修改密码</p><ul><li>centos7忘记root用户密码找回可在启动时设置进入<code>sysroot/bin/sh</code>进行修改，参考：<a href="https://blog.51cto.com/scorpions/2059912" target="_blank" rel="noopener">https://blog.51cto.com/scorpions/2059912</a></li></ul></li><li><p>添加用户sudo权限</p><ul><li><p>使用sudo执行的命令都是基于root启动，创建的文件也是所属root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加写权限</span></span><br><span class="line">chmod u+w /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br><span class="line"></span><br><span class="line"><span class="comment"># (位置说明)文件内容修改</span></span><br><span class="line">root	ALL=(ALL) 	ALL</span><br><span class="line"><span class="comment"># 新加的sudo用户</span></span><br><span class="line"><span class="comment"># smalle  ALL=(ALL)   ALL</span></span><br><span class="line"><span class="comment"># (加这一行)设置执行sudo不需要输入密码(否则sudo输入密码，有效期只有5分钟)。</span></span><br><span class="line">smalle  ALL=(ALL)   NOPASSWD: ALL</span><br><span class="line"><span class="comment"># (需要去掉此行的注释)只要是wheel组不需要密码</span></span><br><span class="line">%wheel  ALL=(ALL)       NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复文件只读</span></span><br><span class="line">chmod u-w /etc/sudoers</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>su test</code> 切换到test用户，但是当前目录和shell环境不会改变</p><ul><li><strong><code>su - test</code></strong> 变更帐号为test，并改变工作目录至test的家目录，且shell环境也变成test用户的</li><li><code>su - smalle -c &#39;ls&#39;</code> 切换到smalle用户环境，且执行ls命令(就算当前登录的是smalle，此时也需要输入密码)</li><li><p>设置su命令不需要密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将smalle加入到组wheel(一个用户可以属于多个组)</span></span><br><span class="line">usermod -G wheel smalle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">vi /etc/pam.d/su</span><br><span class="line"><span class="comment"># 取消下面两行的注释</span></span><br><span class="line">auth       required   pam_wheel.so group=wheel </span><br><span class="line">auth       sufficient pam_wheel.so trust use_uid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">su - smalle -c <span class="string">'ls'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>userdel -rf aezo</code> 删除用户(会删除对应的家目录)</p></li><li>用户组(一个用户可以属于多个组，但是只能有一个默认组)<ul><li><code>cat /etc/group</code> 查看组</li><li><code>groupadd aezocn</code> <strong>新建组</strong></li><li><code>groupdel aezocn</code> 删除组</li><li><code>groups</code> 查看当前登录用户所属组<ul><li><code>groups smalle</code> 查看smalle用户所属组，如返回<code>smalle : test root</code>表示smalle属于test和root组，默认组为test</li></ul></li><li><code>usermod -g test smalle</code> 修改用户smalle的默认组为test</li><li><code>usermod -G wheel smalle</code> 将用户smalle加入到组wheel，并去除之前的非默认组</li><li><code>usermod -a -G wheel smalle</code> <strong>保留之前的非默认组</strong></li><li><code>gpasswd -d smalle test</code> 将smalle从test组移除</li></ul></li><li>查看用户<ul><li><code>cat /etc/passwd</code> 查看用户<ul><li>如<code>smalle(账号名称):x(密码):1000(账号UID):1000(账号GID):aezocn(用户说明):/home/smalle(家目录):/bin/bash(shell环境)</code></li></ul></li><li><code>id smalle</code> 查看smalle用户信息。<ul><li>如<code>uid=1000(smalle) gid=1000(smalle) groups=1000(smalle),10(wheel)</code> gid表示用户默认组，groups表示用户属于smalle、wheel两个组</li></ul></li><li><code>who</code> 显示当前登录用户</li><li><code>w</code> 查看当前登录用户操作信息</li><li><code>whoami</code> 查看当前登录用户名</li><li><code>last</code>/<code>last smalle</code> 查看用户登录历史</li></ul></li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>文件属性<code>chgrp</code>、<code>chown</code>、<code>chmod</code>、<code>umask</code> <a href="http://www.cnblogs.com/kzloser/articles/2673790.html" title="Linux文件属性" target="_blank" rel="noopener">^3</a></li><li><code>chgrp</code> 改变文件所属群组。<code>chgrp [-R] 组名 文件或目录</code><ul><li><code>-R</code> 递归设置子目录下所有文件和目录</li></ul></li><li><code>chown</code> 改变文件/目录拥有者<ul><li><code>chown [-R] aezo /home/aezo</code></li><li><code>chown -R mysql:mysql /home/data/mysql</code> 改变此目录及其子目录的所属组为mysql和所属用户为mysql</li><li>用户可以操作(查看/修改)自己的文件/文件夹，无需上层目录有权限。如<code>/home/data/mysql</code>目录属于mysql，但是<code>/home/data</code>是属于root用户，此时mysql用户也可以操作<code>/home/data/mysql</code>目录</li></ul></li><li><code>chmod</code> 改变文件的权限(文件权限说明参考上述<code>ls -al</code>)<ul><li>数字类型改变文件权限 <strong><code>chmod [-R] xyzw 文件或目录</code></strong> 如：<code>chmod -R 755 /home/ftproot</code><ul><li><code>x</code>：可有可无，代表的是特殊权限,即 SUID/SGID/SBIT。<code>yzw</code>：就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加</li><li>各权限的分数对照表为：<code>r:4、w:2、x:1、SUID:4、SGID:2、SBIT:1</code>。如rwx = 4+2+1 = 7，r-s = 4+1 = 5</li></ul></li><li>符号类型改变文件权限 <code>chmod 对象 操作符 文件/目录</code><ul><li>对象取值为<code>ugoa</code>：u=user, g=group, o=others, a=all</li><li>操作符取值为：<code>+-=</code>：+ 为增加，- 为除去，= 为设定</li><li>如：<code>chmod u=rwx,go=rx test</code>、<code>chmod g+s,o+t test</code></li></ul></li></ul></li><li><code>umask</code> 创建文件时的默认权限<ul><li><code>umask</code> 查看umask分数值。如0022(一般umask分数值指后面三个数字022; umask值相当于基于666做减法，022=&gt;644，002=&gt;664)<ul><li><code>umask -S</code> 查看umask。如u=rwx,g=rx,o=rx</li><li>系统默认新建文件的权限为666(3个rw)，文件夹为777(3个rwx)。最终新建文件的默认权限为系统默认权限减去umask分数值。如umask为002，新建的文件为-rw-r–r–，文件夹为drw-r-xr-x</li><li>centos7中root用户默认为022，其他新创建的用户默认为002</li></ul></li><li>命令行运行<code>umask 022</code>只能临时改变</li><li>永久修改umask值<ul><li><strong>方式一</strong>：修改<code>sudo vi /etc/profile</code>，加入一行<code>umask 022</code></li><li>方式二：修改每个用户<code>sudo vi ~/.bashrc</code>文件，加入一行<code>umask 022</code></li></ul></li></ul></li><li>常用命令<ul><li><code>find . -type d -exec chmod 755 {} \;</code> 修改当前目录及其子目录为775</li><li><code>find . -type f -exec chmod 644 {} \;</code> 修改当前目录及其子目录的所有文件为644</li></ul></li></ul><h3 id="系统资源权限"><a href="#系统资源权限" class="headerlink" title="系统资源权限"></a>系统资源权限</h3><ul><li><code>ulimit</code> 用来限制系统用户对shell资源的访问<ul><li><code>ulimit -a</code> 查看对单一用户资源限制情况<ul><li>如<code>open files</code>为能打开的文件(包括网络连接产生的文件描述符)个数限制</li><li>-H(hard) 设定资源的硬性限制，即不允许超过这个限制</li><li>-S(soft) 设定资源的弹性限制，可在资源不足的情况下修改此设置，但是不能超过hard</li></ul></li><li><code>ulimit -SHn 50000</code> 设定打开文件个数上限为50000(一般1G内存可以打开10W个文件，可通过<code>cat /proc/sys/fs/file-max</code>查看硬件最大能打开的文件)<ul><li>这个设置只是针对普通用户，root用户可能会超过这个设置</li></ul></li><li><code>vi /etc/security/limits.conf</code> 也可通过修改配置文件设置资源限制</li></ul></li><li>Linux core文件：<a href="https://blog.csdn.net/arau_sh/article/details/8182744" target="_blank" rel="noopener">https://blog.csdn.net/arau_sh/article/details/8182744</a></li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="ssh介绍-2"><a href="#ssh介绍-2" class="headerlink" title="ssh介绍 ^2"></a>ssh介绍 <a href="http://www.linuxidc.com/Linux/2016-03/129204.htm" title="ssh登录" target="_blank" rel="noopener">^2</a></h3><ul><li>SSH是建立在传输层和应用层上面的一种安全的传输协议。SSH目前较为可靠，专为远程登录和其他网络提供的安全协议。在主机远程登录的过程中有两种认证方式：<ul><li><code>基于口令认证</code>：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。</li><li><code>基于秘钥认证</code>：需要依靠秘钥，也就是你必须为自己创建一对秘钥，并把公用的秘钥放到你要访问的服务器上，客户端软件就会向服务器发出请求，请求用你的秘钥进行安全验证。服务器收到请求之后，现在该服务器你的主目录下寻找你的公用秘钥，然后吧它和你发送过来的公用秘钥进行比较。弱两个秘钥一致服务器就用公用秘钥加密“质询”并把它发送给客户端软件，客户端软件收到质询之后，就可以用你的私人秘钥进行解密再把它发送给服务器。</li></ul></li><li>用基于秘钥认证，你必须要知道自己的秘钥口令。但是与第一种级别相比，这种不需要再网络上传输口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒</li></ul><h3 id="查看SSH服务"><a href="#查看SSH服务" class="headerlink" title="查看SSH服务"></a>查看SSH服务</h3><ul><li>CentOS 7.1安装完之后默认已经启动了ssh服务我们可以通过以下命令来查看ssh服务是否启动</li><li>查看开放的端口 <code>netstat -lnt</code> ssh默认端口为22</li><li>查看服务是否启动 <code>systemctl status sshd.service</code> 查看ssh服务是否启动</li></ul><h3 id="SSH客户端连接服务器（口令认证）"><a href="#SSH客户端连接服务器（口令认证）" class="headerlink" title="SSH客户端连接服务器（口令认证）"></a>SSH客户端连接服务器（口令认证）</h3><ul><li>直接连接到对方的主机，这样登录服务器的默认用户<ul><li><code>ssh 192.168.1.1</code> 回车输入密码即可</li><li><code>exit</code> 退出登录</li></ul></li><li>使用账号登录对方主机aezocn用户<ul><li><code>ssh aezocn@192.168.1.1</code></li></ul></li></ul><h3 id="SSH客户端连接服务器（秘钥认证）"><a href="#SSH客户端连接服务器（秘钥认证）" class="headerlink" title="SSH客户端连接服务器（秘钥认证）"></a>SSH客户端连接服务器（秘钥认证）</h3><ul><li>SSH连接<ul><li><strong><code>ssh-keygen</code> 生成秘钥对</strong>。可以在服务器、客户端、开发机上生成</li><li><strong>将公钥 <code>id_rsa.pub</code> 内容追加到服务器的 <code>~/.ssh/authorized_keys</code> 文件中</strong>。如登录服务器root账号则是<code>/root/.ssh/authorized_keys</code>，如登录aezo账号则是<code>/home/aezo/.ssh/authorized_keys</code></li><li><strong>将私钥 <code>id_rsa</code> 保存在客户端的<code>~/.ssh/</code>目录</strong></li></ul></li><li><code>ssh-keygen</code> 命令生成秘钥对<ul><li>运行 <code>ssh-keygen</code> 命令后再按三次回车会看到<code>RSA</code>，生成的秘钥文件默认路径为家目录下的<code>.ssh</code>，如<code>/home/smalle/.ssh/</code>。包含文件<ul><li><code>id_rsa</code> 密钥，保存在客户端。<strong>客户端在通过ssh登录时，默认查找 id_rsa 文件，那么如果想让此客户端登录多个服务器，一般需要将此秘钥对应的公钥保存在多个服务器上，因此还需保管好相应公钥备用</strong></li><li><code>id_rsa.pub</code> 公钥，保存服务端。</li><li><code>known_hosts</code>(此机器作为客户端进行ssh连接时，认证过的服务器信息) 3 个文件。如：此客户端ip为<code>192.168.1.2</code></li></ul></li><li><code>ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsa</code> 以dsa模式生成</li><li><code>ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;</code> -C起到一个密码备注的作用，可以为任何内容</li></ul></li><li><strong>公钥保存到服务器</strong><ul><li><strong><code>ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.1.1</code></strong> 输入192.168.1.1密码，则会自动将公钥保存在服务器的<code>/root/.ssh/authorized_keys</code>文件中去此时。需要保证192.168.1.1服务器的root用户没有被禁用</li><li>手动追加到authorized_keys文件中，<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></li><li><strong>注意<code>authorized_keys</code>权限必须是600</strong>。如果没有此文件，上述两种方式会自动创建，其中ssh-copy-id创建的是600，而通过cat追加创建的可能不是600权限导致无法使用</li></ul></li><li><strong>秘钥保存在客户端</strong><ul><li>如果是为了让客户端root用户登录服务器，则将公钥放入到/root/.ssh目录；如果提供给其他用户登录，可将公钥放在对应的家目录，如/home/aezo/.ssh/下</li><li><code>.ssh</code>目录不存在可手动新建（可通过<code>ll -al</code>查看） <a href="https://www.douban.com/doulist/44111547/" title="阿里云服务器ssh设置" target="_blank" rel="noopener">^5</a></li></ul></li><li>服务器说明<ul><li>把生成的公钥保存到服务器<code>authorized_keys</code>文件中(文件名有s)</li></ul></li><li>客户端说明<ul><li>客户端可能是windos、linux，在某种业务场景可能也被当做一台服务器</li><li>客户端公钥需要写入到服务端的<code>authorized_keys</code>文件</li><li>客户端登录成功后会将服务器ip等信息加入到客户端<code>known_hosts</code>文件中(没有此文件时会自动新建)</li></ul></li><li>免密登录服务器<ul><li><code>ssh 192.168.1.1</code> 此时不需要输入密码</li><li>如果需要在<code>192.168.1.1</code>(客户机)上通过ssh登录<code>192.168.1.1</code>(服务器)，需要按照上述命令把公钥保存到服务器的<code>authorized_keys</code></li><li>如果是使用服务器的aezo账号登录服务器，则将公钥追加到/home/aezo/.ssh/authorized_keys文件中，并通过 <code>ssh aezo@192.168.1.1</code>进行登录</li></ul></li><li>其他说明<ul><li>如何客户端登录失败，可在服务器查看访问日志<code>cat /var/log/secure</code><ul><li>客户端登录提示<code>Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</code>。说明秘钥验证失败，检查服务端是否有公钥，客户端是否有正确秘钥</li></ul></li><li>密钥格式<ul><li>目前主流的密钥（或者说私钥）格式有两种：OpenSSH格式的密钥(.pem或者无id_ras的后缀文件) 和 PuTTY格式的密钥（.ppk）</li><li>id_ras、pem、ppk直接的转换参考下文</li></ul></li><li><strong>阿里云服务器使用</strong><ul><li>方式一：如上文所述方式，此时无需重启阿里云服务器</li><li>方式二<ul><li>在阿里云管理后台生成秘钥或手动导入秘钥对，并关联到对应ECS上。阿里云生成的只能下载到秘钥，公钥可通过xshell连接后进行查看或连接后到服务器的authorized_keys文件中查看</li><li>关联阿里云服务器秘钥后，需要到阿里云管理后进行服务器重启(不能在终端重启)。<em>重启后会自动禁用密码登录</em></li></ul></li></ul></li><li><strong>AWS服务器(EC2)使用</strong><ul><li>使用PuTTY连接时：PuTTY 本身不支持 Amazon EC2 生成的私有密钥格式 (.pem)，PuTTY 有一个名为 PuTTYgen 的工具，可将密钥转换成所需的 PuTTY 格式 (.ppk)</li></ul></li></ul></li><li>ssh-keygen、Putty/WinSCP、xshell/xftp<ul><li>文件格式区分<ul><li><code>ssh-keygen</code> 生成的为<code>id_rsa</code>(秘钥)和<code>id_rsa.pub</code></li></ul></li><li>Putty是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。它包含Puttygen等工具，Puttygen可用于生成公钥和密钥（还可以将如AWS亚马逊云的密钥文件.pem转换为.ppk的通用密钥文件）<ul><li>在知道密钥文件时，可以通过Putty连接到服务器(命令行)，通过WinSCP连接到服务器的文件系统(FTP形式显示)</li><li>Puttygen使用：<code>类型选择RSA，大小2048</code> - <code>点击生成</code> - <code>鼠标在空白处滑动</code> - <code>保存公钥和密钥</code></li><li>Putty使用：<code>Session的Host Name输入username@ip，端口22</code> - <code>Connection-SSH-Auth选择密钥文件</code> - <code>回到Session，在save session输入一个会话名称</code> - <code>点击保存会话</code> - <code>点击open登录服务器</code> - <code>下次可直接点击会话名称登录</code></li></ul></li><li>通过PuttyGen将id_rsa转为.ppk(PuTTY format private key file)，将.ppk转成.pem(OpenSSH) <a href="https://www.cnblogs.com/cidgur/p/9447847.html" target="_blank" rel="noopener">^13</a><ul><li>将id_rsa(或.pem)转为.ppk<ul><li>windows操作: PuttyGen - Conversions - Import key - Save private Key</li><li>linux操作: <code>puttygen id_rsa.pem -o id_rsa.ppk</code></li></ul></li><li>将.ppk转成.pem<ul><li>windows操作: PuttyGen - Load - Conversions - Export OpenSSH Key - 保存为.pem文件</li><li>linux操作: <code>puttygen id_rsa.ppk -o id_rsa.pem -O private-openssh</code></li></ul></li></ul></li><li>xshell/xftp是一个连接ssh的客户端<ul><li>使用xshell生成的秘钥进行连接：连接 - 用户身份验证 - 方法选择”public key”公钥 - 用户名填入需要登录的用户 - 用户密钥可点击浏览生成(需要将生成的公钥保存到对应用户的.ssh目录<code>cat /home/aezo/.ssh/id_rsa.pub &gt;&gt; /home/aezo/.ssh/authorized_keys</code>)。(必须使用自己生成的公钥和密钥，如果AWS亚马逊云转换后的ppk文件无法直接登录)</li><li>使用服务器生成的秘钥文件连接：连接 - 用户身份验证 - 方法选择”public key”公钥 - 用户名填入需要登录的用户 - 用户密钥可点击浏览导入(<strong>导入服务器生成的秘钥文件id_rsa，不是公钥文件</strong>)</li><li>xshell提示”用户秘钥导入失败”：centos上生成的秘钥类型在xshell中不支持，<strong>可以使用xshell进行秘钥生成</strong> <a href="https://www.cnblogs.com/tintin1926/archive/2012/07/23/2605039.html" title="秘钥类型" target="_blank" rel="noopener">^9</a><ul><li>工具 - 用户秘钥管理 - 生成 - 保存公钥 - 选择生成的秘钥 - 导出秘钥</li><li>将公钥追加到到服务器的<code>authorized_keys</code>文件：<code>cat my_key.pub &gt;&gt; authorized_keys</code></li></ul></li></ul></li><li>Unix终端：<code>ssh -i my_private_file root@10.10.10.10</code><ul><li><code>-i</code> 登录时指定私钥文件。ssh登录服务器默认使用的私有文件为<code>~/.ssh/id_dsa</code>、<code>~/.ssh/id_ecdsa</code>、<code>~/.ssh/id_ed25519</code>、<code>~/.ssh/id_rsa</code>，其他则需要使用<code>-i</code>指定</li></ul></li><li><code>cat /var/log/secure</code>查看登录日志</li></ul></li><li><p><strong>当支持证书登录后，可修改ssh配置禁用密码登录</strong> <a href="https://www.xiaohui.com/dev/server/linux-centos-ssh-security.htm" title="服务器安全ssh配置" target="_blank" rel="noopener">^7</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改文件内容</span></span><br><span class="line">Port 222 <span class="comment"># 修改原22端口为222端口</span></span><br><span class="line"><span class="comment"># (可选)是否允许root用户登陆(no不允许)，**如果要基于root证书登录则还是需要设置为yes**</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"><span class="comment"># 是否允许使用用户名密码登录(no不允许，此时只能使用证书登录。在没有生成好Key，并且成功使用之前，不要设置为no)</span></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li></ul><h2 id="corn定时任务"><a href="#corn定时任务" class="headerlink" title="corn定时任务"></a>corn定时任务</h2><ul><li>crontab命令语法：<code>crontab [ -u user ] { -e | -l | -r }</code> <a href="http://www.360doc.com/content/16/1013/10/15398874_598063092.shtml" title="定时任务" target="_blank" rel="noopener">^4</a><ul><li><code>-u</code> 指定某用户任务(<strong>默认是当前用户</strong>，最终目标命令会已此用户身份运行)<ul><li><code>sudo crontab -e</code> 此时未指定<code>-u</code>，sudo则相当于<code>-u root</code></li></ul></li><li><code>-e</code> 编辑当前用户的定时任务，默认在<code>/var/spool/</code>目录。或者 <code>sudo vi /etc/crontab</code></li><li><code>-l</code> 列出目前的时程表(<code>crontab -u root -l</code>)</li><li><code>-r</code> 删除目前的时程表</li></ul></li><li><code>systemctl reload crond</code> 重新加载配置</li><li><code>systemctl restart crond</code> 重启crond(<strong>添加配置后需要重启</strong>)</li><li><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## root用户定时执行脚本</span></span><br><span class="line"><span class="comment"># 1.编辑脚本</span></span><br><span class="line">crontab -u root -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.加入每分钟执行脚本配置(对应用户必须有执行此脚本权限，且此脚本文件有+x可执行属性)</span></span><br><span class="line"><span class="comment"># 01 * * * * /home/smalle/script/test.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.重新加载</span></span><br><span class="line">systemctl reload crond</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看日志</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/cron</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果执行的任务脚本中有echo输出，则会给对应用户发系统邮件</span></span><br><span class="line">cat /var/spool/mail/root</span><br></pre></td></tr></table></figure></li></ul><h3 id="cron配置"><a href="#cron配置" class="headerlink" title="cron配置"></a>cron配置</h3><ul><li><p>相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   crontab -l <span class="comment"># 查看当前用户定时器</span></span><br><span class="line">   sudo crontab -l <span class="comment"># 查看root用户</span></span><br><span class="line">   crontab -e <span class="comment"># 编辑当前用户定时器</span></span><br><span class="line">   sudo crontab -e <span class="comment"># 编辑root用户定时器，加入`00 02 * * * /home/smalle/script/backup_mysql.sh`</span></span><br><span class="line">systemctl restart crond <span class="comment"># 重启crond服务</span></span><br></pre></td></tr></table></figure></li><li><p>配置举例(需要将此配置加入到crontab)</p><ul><li><code>30 2 1 * * /sbin/reboot</code> 表示每月第一天的第2个小时的第30分钟，执行命令/sbin/reboot(重启)</li><li><code>00 02 * * * /home/smalle/script/backup_mysql.sh</code> 每天执行mysql备份脚本。脚本具体参考：<a href="/_posts/db/mysql-dba.md#linux脚本备份(mysqldump">http://blog.aezo.cn/2016/10/12/db/mysql-dba/</a>)</li><li><code>*/3 * * * * /home/smalle/script/test.sh</code> 每3分钟执行一次脚本</li></ul></li><li><p>配置说明如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example of job definition:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .---------------- minute (0 - 59)，如 10 表示没第10分钟运行。每分钟用 * 或者*/1表示，整点分钟数为00或0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  *  *  *  * [user] my-command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (1) 其中用户名一般可以省略</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (2) 精确到秒解决方案, 以下3行表示每20秒执行一次</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * * * * * my-command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * * * * * sleep 20; my-command</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * * * * * sleep 40; my-command</span></span><br></pre></td></tr></table></figure></li><li><p>常用符号</p><ul><li><code>*</code> 表示所有值</li><li><code>?</code> 表示未说明的值，即不关心它为何值</li><li><code>-</code> 表示一个指定的范围</li><li><code>,</code> 表示附加一个可能值</li><li><code>/</code> 符号前表示开始时间，符号后表示每次递增的值</li></ul></li></ul><h2 id="运维-amp-工具"><a href="#运维-amp-工具" class="headerlink" title="运维&amp;工具"></a>运维&amp;工具</h2><h3 id="系统信息查询"><a href="#系统信息查询" class="headerlink" title="系统信息查询"></a>系统信息查询</h3><ul><li>查看内核版本 <code>uname -r</code></li><li>查看操作系统版本 <code>cat /proc/version</code><ul><li>如腾讯云服务器 <code>Linux version 3.10.0-327.36.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) ) #1 SMP Mon Oct 24 16:09:20 UTC 2016</code> 中的 <code>3.10.0</code> 表示内核版本 <code>x86_64</code> 表示是64位系统</li></ul></li><li>查看CentOS版本 <strong><code>cat /etc/redhat-release</code>/<code>cat /etc/system-release</code></strong> 如：CentOS Linux release 7.2.1511 (Core)</li><li><code>cat /proc/meminfo &amp;&amp; free</code> 查看内存使用情况<ul><li><code>/proc/meminfo</code>为内存详细信息<ul><li><code>MemTotal</code> 内存总数</li><li><code>MemFree</code> 系统尚未使用的内存</li><li><code>MemAvailable</code> 应用程序可用内存数。系统中有些内存虽然已被使用但是可以回收的，比如cache/buffer、slab都有一部分可以回收，所以MemFree不能代表全部可用的内存，这部分可回收的内存加上MemFree才是系统可用的内存，即：<strong>MemAvailable ≈ MemFree + Buffers + Cached</strong>。MemFree是说的系统层面，MemAvailable是说的应用程序层面</li></ul></li><li><code>free</code> 为内存概要信息，单位Kb</li></ul></li><li><p><code>lscpu</code> 列举cpu信息</p><ul><li><p><code>cat /proc/cpuinfo</code> 查看CPU使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看CPU信息(型号): Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line"><span class="comment"># 查看物理CPU个数，eg: 1</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span>| sort| uniq| wc -l</span><br><span class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)，eg：6</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span>| uniq</span><br><span class="line"><span class="comment"># 查看逻辑CPU的个数，eg：12</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"processor"</span>| wc -l</span><br></pre></td></tr></table></figure></li></ul></li><li><p>磁盘使用查看</p><ul><li><code>df -h</code> 查看磁盘使用情况和挂载点信息<ul><li><code>df /root -h</code> <strong>查看/root目录所在挂载点</strong>(一般/dev/vda1为系统挂载点，重装系统数据无法保留；/dev/vab或/dev/mapper/centos-root等用来存储数据)</li></ul></li><li><code>du -h --max-depth=1</code> 查看当前目录以及一级子目录磁盘使用情况；二级子目录可改成2；<code>du -h</code> 查看当前目录及其子目录大小</li></ul></li><li><code>hostname</code> 查看hostname<ul><li><code>hostnamectl --static set-hostname aezocn</code> 修改主机名并重启</li></ul></li><li><code>env</code> 查看环境变量</li></ul><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><ul><li>更多网络知识参考：<a href="/_posts/linux/network.md">《网络》http://blog.aezo.cn/2019/06/20/linux/network/</a></li><li><code>ip addr</code> 查看机器ip，显示说明<ul><li><code>lo</code>为内部网卡接口，不对外进行广播；<code>eth0</code>/<code>ens33</code>网卡接口会对外广播</li><li><code>link/ether 00:0c:29:bb:ea:e2</code>中link/ether后为<code>mac</code>地址</li><li><code>inet 192.168.6.130/24 brd 192.168.6.255 scope global ens33</code>中192.168.6.130/24为内网ip和子网掩码(24代表32位中有24个1其他都是0，即255.255.255.0) <code>brd</code>(broadcast)后为广播地址</li></ul></li><li><code>ifconfig</code>命令(centos7无法使用可安装工具<code>yum install net-tools</code>)<ul><li><code>ifconfig ens33:1 192.168.6.10</code> 给网络接口ens33绑定一个虚拟ip</li><li><code>ifconfig ens33:1 down</code> 删除此虚拟ip</li><li><code>ifconfig br-9118c1fdedb8 up|down</code> 启用|关闭br-9118c1fdedb8网卡(网桥等接口)</li><li>添加虚拟ip方式二<ul><li>编辑类似文件<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></li><li>加入代码<code>IPADDR=192.168.6.130</code>(本机ip)和<code>IPADDR1=192.168.6.135</code>(添加的虚拟ip，可添加多个。删除虚拟ip则去掉IPADDR1)，可永久生效</li><li>重启网卡<code>systemctl restart network</code></li><li>修改ip即修改上述<code>IPADDR</code></li></ul></li></ul></li><li><code>ping 192.168.1.1</code>(或者<code>ping www.baidu.com</code>) 检查网络连接</li><li><code>telnet 192.168.1.1 8080</code> 检查端口(<code>yum -y install telnet</code>)</li><li><p><code>curl http://www.baidu.com</code> 获取网页内容。参考：<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-d              <span class="comment"># 发送 POST 请求的数据体    # curl -d'login=emma＆password=123'-X POST https://google.com/login</span></span><br><span class="line">-H              <span class="comment"># 添加 HTTP 请求的标头      # curl -H 'Accept-Language: en-US' https://google.com</span></span><br><span class="line">-L              <span class="comment"># 会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向</span></span><br><span class="line">-O              <span class="comment"># 将服务器回应保存成文件，并将 URL 的最后部分当作文件名。等同于wget # curl -O https://www.example.com/foo/bar.html (文件名bar.html)</span></span><br><span class="line">-o              <span class="comment"># 将服务器的回应保存成文件并重命名 # curl -o my.html https://www.example.com (文件名my.html)</span></span><br><span class="line">-v              <span class="comment"># 输出通信的整个过程，用于调试</span></span><br><span class="line">-b              <span class="comment"># 向服务器发送 Cookie       # curl -b 'foo1=bar' -b 'foo2=baz' https://google.com # -b也可接cookie文件</span></span><br><span class="line">-c              <span class="comment"># 将服务器设置的 Cookie 写入一个文件</span></span><br><span class="line">--<span class="built_in">limit</span>-rate    <span class="comment"># 用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境  # curl --limit-rate 200k https://google.com</span></span><br><span class="line">--socks5        <span class="comment"># 使用socks5协议            # curl --socks5 127.0.0.1:1080 http://www.qq.com</span></span><br></pre></td></tr></table></figure></li><li><p><code>wget http://www.baidu.com</code> 检查是否可以上网，成功会显示或下载一个对应的网页</p><ul><li><code>wget -o /tmp/wget.log -P /home/data --no-parent --no-verbose -m -D www.qq.com -N --convert-links --random-wait -A html,HTML http://www.qq.com</code> wget爬取网站</li></ul></li><li><code>netstat -lnp</code> 查看端口占用情况(端口、PID)<ul><li><code>yum install net-tools</code> 安装net-tools即可使用netstat、ifconfig等命令</li><li><code>sudo netstat -lnp</code> 可查看使用root权限运行的进程PID(否则PID隐藏)</li><li><code>netstat -tnl</code> 查看开放的端口</li><li><code>netstat -lnp | grep tomcat</code> 查看含有tomcat相关的进程</li><li><code>lsof -i -P | grep 21</code> mac查看端口和pid方法，或<code>lsof -i :21</code></li><li><code>ss -ant</code> CentOS 7 查看所有监听端口</li></ul></li><li><code>ss -lnt</code> 查看端口</li></ul><h3 id="查看进程信息"><a href="#查看进程信息" class="headerlink" title="查看进程信息"></a>查看进程信息</h3><ul><li><strong><code>ps -ef | grep java</code></strong>(其中java可换成run.py等)<ul><li>结果如：<code>root 23672 22596 0 20:36 pts/1 00:00:02 python -u main.py</code>. 运行用户、进程id、…</li><li><code>ps axo pid,ppid,comm,pmem,lstart,etime,cmd | grep java</code> lstart启动时间，etime运行时间</li></ul></li><li><code>pwdx &lt;pid&gt;</code> <strong>查看进程执行目录</strong>(同<code>ls -al /proc/8888 | grep cwd</code>)</li><li><code>ls -al /proc/进程id</code> 查看此进程信息<ul><li><code>cwd</code>符号链接的是进程运行目录 <strong><code>ls -al /proc/8888 | grep cwd</code></strong></li><li><code>exe</code>符号连接就是执行程序的绝对路径</li><li><code>cmdline</code>就是程序运行时输入的命令行命令</li><li><code>environ</code>记录了进程运行时的环境变量</li><li><code>fd</code>目录下是进程打开或使用的文件的符号连接</li></ul></li></ul><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><ul><li>自带程序<code>top</code>查看，推荐安装功能更强大的<code>htop</code></li><li><p>面板介绍 <a href="https://zhuanlan.zhihu.com/p/24464526" target="_blank" rel="noopener">^11</a></p><ul><li><p><code>Load Average</code>: 负载均值。对应的三个数分别代表不同时间段的系统平均负载（一分钟、五 分钟、以及十五分钟），它们的数字当然是越小越好；数字越高说明服务器的负载越大。如果是单核，load=1表示CPU所有的资源都在处理请求，一般维持0.7以下，如果长期在1左右建议进行监测，维持在2左右则说明负载很高。多核情况，<strong>即负载最好要小于<code>CPU个数 * 核数 * 0.7</code></strong></p><p><img src="/data/images/linux/top-view.jpg" alt="top面板介绍"></p></li><li><p><strong>PID：包含了该进程ID和线程ID</strong></p></li><li>VIRT 值最高的进程就是内存使用最多的进程</li><li>S列进程状态：一般 I 代表空闲，R 代表运行，S 代表休眠，D 代表不可中断的睡眠状态，Z 代表(zombie)僵尸进程，T 或 t 代表停止</li></ul></li><li><p>快捷键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h 进入帮助；Exc/q 退出帮助</span></span><br><span class="line">Help <span class="keyword">for</span> Interactive Commands - procps-ng version 3.3.10</span><br><span class="line">Window 3:Mem: Cumulative mode On.  System: Delay 3.0 secs; Secure mode Off.</span><br><span class="line">    <span class="comment"># 全局配置：Z 颜色，B 背景</span></span><br><span class="line">    Z,B,E,e   Global: <span class="string">'Z'</span> colors; <span class="string">'B'</span> bold; <span class="string">'E'</span>/<span class="string">'e'</span> summary/task memory scale</span><br><span class="line">    <span class="comment"># 总的统计：l 显示负载(默认显示)；t 显示CPU使用图示（重复按键可切换显示模式）；m 显示内存使用图示（重复按键可切换显示模式）</span></span><br><span class="line">    l,t,m     Toggle Summary: <span class="string">'l'</span> load avg; <span class="string">'t'</span> task/cpu stats; <span class="string">'m'</span> memory info</span><br><span class="line">    0,1,2,3,I Toggle: <span class="string">'0'</span> zeros; <span class="string">'1/2/3'</span> cpus or numa node views; <span class="string">'I'</span> Irix mode</span><br><span class="line">    <span class="comment"># 字段配置：f 进入字段操作界面（d 增加/删除字段，s 切换排序字段）；F 进入字段列显示顺序排序界面(选中一行上下切换即可)</span></span><br><span class="line">    f,F,X     Fields: <span class="string">'f'</span>/<span class="string">'F'</span> add/remove/order/sort; <span class="string">'X'</span> increase fixed-width</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定位配置：L 查找字符串, &amp; 查找下一个; &lt;,&gt; 切换排序列</span></span><br><span class="line">    L,&amp;,&lt;,&gt; . Locate: <span class="string">'L'</span>/<span class="string">'&amp;'</span> find/again; Move sort column: <span class="string">'&lt;'</span>/<span class="string">'&gt;'</span> left/right</span><br><span class="line">    <span class="comment"># 切换配置：R切换排序； H 显示线程视图；V 显示父子进程树</span></span><br><span class="line">    R,H,V,J . Toggle: <span class="string">'R'</span> Sort; <span class="string">'H'</span> Threads; <span class="string">'V'</span> Forest view; <span class="string">'J'</span> Num justify</span><br><span class="line">    <span class="comment"># c 显示Command详细命令</span></span><br><span class="line">    c,i,S,j . Toggle: <span class="string">'c'</span> Cmd name/line; <span class="string">'i'</span> Idle; <span class="string">'S'</span> Time; <span class="string">'j'</span> Str justify</span><br><span class="line">    <span class="comment"># x,y 高亮显示排序列和运行行</span></span><br><span class="line">    x,y     . Toggle highlights: <span class="string">'x'</span> sort field; <span class="string">'y'</span> running tasks</span><br><span class="line">    <span class="comment"># 当使用x,y时，同z改变字体颜色，b改变背景</span></span><br><span class="line">    z,b     . Toggle: <span class="string">'z'</span> color/mono; <span class="string">'b'</span> bold/reverse (only <span class="keyword">if</span> <span class="string">'x'</span> or <span class="string">'y'</span>)</span><br><span class="line">    <span class="comment"># 过滤：o/O 增加过滤项（其中O区分大小写。如输入 COMMAND=java 表示COMMAND含java字符串的，或 !PID=100 表示PID不含100的，或 %CPU&gt;5.0，回车即可应用过滤条件）</span></span><br><span class="line">    u,U,o,O . Filter by: <span class="string">'u'</span>/<span class="string">'U'</span> effective/any user; <span class="string">'o'</span>/<span class="string">'O'</span> other criteria</span><br><span class="line">    <span class="comment"># Ctrl+O 展示过滤条件；top界面输入 = 即可清除所有过滤条件</span></span><br><span class="line">    n,\<span class="comment">#,^O  . Set: 'n'/'#' max tasks displayed; Show: Ctrl+'O' other filter(s)</span></span><br><span class="line">    <span class="comment"># 显示成滚动窗口，在通过上下左右键/home/end移动</span></span><br><span class="line">    C,...   . Toggle scroll coordinates msg <span class="keyword">for</span>: up,down,left,right,home,end</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 管理进程：k 杀死某个进程；r 重设优先级</span></span><br><span class="line">    k,r       Manipulate tasks: <span class="string">'k'</span> <span class="built_in">kill</span>; <span class="string">'r'</span> renice</span><br><span class="line">    <span class="comment"># 设置数据更新频率，默认3秒</span></span><br><span class="line">    d or s    Set update interval</span><br><span class="line">    W,Y       Write configuration file <span class="string">'W'</span>; Inspect other output <span class="string">'Y'</span></span><br><span class="line">    q         Quit</span><br><span class="line">            ( commands shown with <span class="string">'.'</span> require a visible task display window ) </span><br><span class="line">Press <span class="string">'h'</span> or <span class="string">'?'</span> <span class="keyword">for</span> <span class="built_in">help</span> with Windows,</span><br><span class="line">Type <span class="string">'q'</span> or &lt;Esc&gt; to <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他快捷键</span></span><br><span class="line">M <span class="comment"># 按照内存排序</span></span><br><span class="line">N <span class="comment"># 按照PID排序</span></span><br><span class="line">V <span class="comment"># 排序反转</span></span><br><span class="line">0 <span class="comment"># 隐藏Time为0的数据</span></span><br><span class="line">1 <span class="comment"># 显示CPU所有核心的信息</span></span><br><span class="line">2 <span class="comment"># 显示NUMA信息</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="查看IO信息-磁盘读写情况"><a href="#查看IO信息-磁盘读写情况" class="headerlink" title="查看IO信息(磁盘读写情况)"></a>查看IO信息(磁盘读写情况)</h3><ul><li>参考：<a href="https://www.cnblogs.com/quixotic/p/3258730.html" target="_blank" rel="noopener">https://www.cnblogs.com/quixotic/p/3258730.html</a> <a href="https://www.cnblogs.com/quixotic/p/3258730.html" title="Linux下的IO监控与分析" target="_blank" rel="noopener">^12</a></li></ul><h4 id="系统级IO监控"><a href="#系统级IO监控" class="headerlink" title="系统级IO监控"></a>系统级IO监控</h4><ul><li>基于<code>top</code>查看<ul><li>top面板的<code>%Cpu</code>展示栏中的 wa 的百分比数值可以大致的体现出当前的磁盘io请求是否频繁。如果 wa 较大，说明等待输入输出的的io比较多，如 75 wa表示75%的IO等待</li></ul></li><li>基于<code>vmstat</code><ul><li>vmstat是Virtual Meomory Statistics(虚拟内存统计，Swap Space)的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析</li><li><code>vmstat 5 5</code> 在5秒时间内进行5次采样</li><li>字段说明<ul><li>Procs(进程)：r:运行队列中进程数量，b:等待IO的进程数量</li><li>Memory(内存)：swpd:使用虚拟内存大小，free:可用内存大小，buff:用作缓冲的内存大小，cache:用作缓存的内存大小</li><li>Swap：si:每秒从交换区写到内存的大小，so:每秒写入交换区的内存大小</li><li>IO(单位1kb)：bi:每秒读取的块数，bo:每秒写入的块数</li><li>System：in: 每秒中断数(包括时钟中断)，cs: 每秒上下文切换数</li><li>CPU(%)： us:用户进程执行时间(user time)；sy:系统进程执行时间(system time)；id:空闲时间(包括IO等待时间)，中央处理器的空闲时间，以百分比表示；wa:等待IO时间</li></ul></li><li>状态说明<ul><li>如果r经常大于4，id经常少于40，表示cpu的负荷很重</li><li>如果bi，bo长期不等于0，表示内存不足</li><li>如果disk经常不等于0，且在b中的队列大于3，表示io性能不好</li></ul></li></ul></li><li>基于iostat查看<ul><li>安装iostat <code>yum install sysstat</code>(iostat属于sysstat软件包)</li><li><code>iostat -xdm 1</code><ul><li>-x输出扩展信息；-d仅显示磁盘统计信息(与-c仅显示CPU信息互斥)；-m显示磁盘读写速度单位为MB(默认为KB，影响rMB/s、wMB/s选项)；1秒统计一次</li><li>显示结果含义如下<ul><li><code>r/s</code>、<code>w/s</code> 每秒的读操作和写操作，磁盘读写速度</li><li><code>rKB/s</code>、<code>wKB/s</code> 每秒读和写的数据量(KB为单位)，对应的有rMB/s、wMB/s<ul><li>如果r/s、w/s，rKB/s、wKB/s这两对数据值都很高的话说明磁盘io操作是很频繁</li></ul></li><li><code>avgrq-sz</code> 提交给驱动层的IO请求大小，一般不小于4K，不大于max(readahead_kb, max_sectors_kb)。可用于判断尤其是磁盘繁忙时，越大代表顺序读，越小代表随机读</li><li><strong><code>%util</code></strong> 代表磁盘繁忙程度。100% 表示磁盘繁忙，0%表示磁盘空闲。但是磁盘繁忙不代表磁盘利用率高(重要指标)</li><li><strong><code>svctm</code></strong> 一次IO请求的服务时间，对于单块盘，完全随机读时基本在7ms左右，既寻道+旋转延迟时间(重要指标)</li></ul></li></ul></li></ul></li></ul><h4 id="进程级IO监控"><a href="#进程级IO监控" class="headerlink" title="进程级IO监控"></a>进程级IO监控</h4><ul><li>安装iotop <code>yum install iotop</code>(io版的top)</li><li><code>iotop</code> 命令可直接运行，界面操作快捷键如下<ul><li>左右箭头：改变排序方式，默认是按IO排序</li><li>r：改变排序顺序</li><li>o：只显示有IO输出的进程</li><li>p：进程/线程的显示方式的切换</li><li>a：显示累积使用量</li><li>q：退出</li></ul></li><li><code>iotop -p &lt;pid&gt;</code> 单独监控此进程</li></ul><h4 id="业务级IO监控"><a href="#业务级IO监控" class="headerlink" title="业务级IO监控"></a>业务级IO监控</h4><ul><li><code>pt-ioprofile</code> <strong>不建议在生产环境使用</strong></li></ul><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul><li>建议使用<code>safe-rm</code>等工具进行删除操作，减少误删除几率</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考: https://blog.csdn.net/weixin_43143310/article/details/121343821</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 恢复正在被进程使用的文件</span></span><br><span class="line">lsof | grep delete.txt</span><br><span class="line"><span class="built_in">cd</span> /proc/&#123;pid&#125;/fd</span><br><span class="line"><span class="comment"># 类似显示 3 -&gt; /root/delete.txt (deleted)</span></span><br><span class="line">ll -l</span><br><span class="line"><span class="comment"># 基于句柄将对应文件恢复到指定目录</span></span><br><span class="line">cp 3 /opt/recover/delete.txt.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 恢复未被进程使用的文件。基于 extundelete，参考: https://www.e-learn.cn/topic/3928412</span></span><br><span class="line"><span class="comment"># 1.extundelete是支持ext3/ext4双格式分区恢复，基于整个磁盘的恢复功能较为强大,基于目录和文件的恢复还不够强大</span></span><br><span class="line"><span class="comment"># 2.在实际线上恢复过程中，切勿将extundelete安装到你误删的文件所在硬盘，即尽量不要操作被删除数据的磁盘</span></span><br><span class="line"><span class="comment"># 3.extundelete执行完毕后在当前目录生产一个RECOVERED_FILES目录，里面即是恢复出来的文件，还包括文件夹</span></span><br><span class="line"><span class="comment"># 4.(***)任何的文件恢复工具，在使用前，均要将要恢复的分区卸载或挂载为只读，防止数据被覆盖使用。被重新使用后会出现 Space has been reallocated 将无法恢复</span></span><br><span class="line">umount /dev/your_del_partition</span><br><span class="line">mount -o remount,ro /dev/your_del_partition</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于整个磁盘的恢复功能较为强大,基于目录和文件的恢复还不够强大</span></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="comment"># yum install e2fsprogs* e2fslibs* -y</span></span><br><span class="line">wget https://nchc.dl.sourceforge.net/project/extundelete/extundelete/0.2.4/extundelete-0.2.4.tar.bz2</span><br><span class="line">tar jxvf extundelete-0.2.4.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> extundelete-0.4.0</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印区块信息</span></span><br><span class="line">extundelete /dev/vda1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复指定时间戳的文件</span></span><br><span class="line">date -d <span class="string">"Jul 26 14:30"</span> +%s <span class="comment"># 获取当前秒数</span></span><br><span class="line">extundelete /dev/sdb1 --after 1234567890 --restore-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复指定文件</span></span><br><span class="line">extundelete /dev/vda1 --restore-file /root/delete.txt</span><br><span class="line"><span class="comment"># 恢复目录</span></span><br><span class="line">extundelete /dev/vda1 --restore-directory /root/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 恢复整个分区</span></span><br><span class="line">extundelete /dev/vda1 --restore-all</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html</a></li><li><code>pstack</code> 跟踪进程栈</li><li><code>strace</code> 跟踪进程中的系统调用(软中断)<ul><li><code>yum -y install strace</code></li><li><code>strace -ff -o out java HelloWorld</code> 将跟踪日志写入到out文件中</li></ul></li><li><code>top</code> linux下的任务管理器</li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h3><ul><li><code>sysctl</code>命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录<code>/proc/sys</code>中</li><li>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sysctl [options] [variable[=value] ...]</span><br><span class="line"><span class="comment"># sysctl变量的设置通常是字符串、数字或者布尔型(1/0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前所有可用的内核参数变量和值</span></span><br><span class="line">sysctl -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改参数值(临时修改)</span></span><br><span class="line">sysctl -w vm.dirty_background_ratio=5</span><br><span class="line"><span class="comment"># 执行一次或多次`-w`后需要通过`-p`持久化(使生效)</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ul><li>配置sysctl(永久修改)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line">/sbin/sysctl -p</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## sysctl -a | grep dirty # 缓存相关</span></span><br><span class="line"><span class="comment"># vm.dirty_background_ratio 是内存可以填充“脏数据”的百分比。这些“脏数据”在稍后是会写入磁盘的，pdflush/flush/kdmflush这些后台进程会稍后清理脏数据。举一个例子，我有32G内存，那么有3.2G的内存可以待着内存里，超过3.2G的话就会有后来进程来清理它</span></span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line"><span class="comment"># vm.dirty_ratio 是绝对的脏数据限制，内存里的脏数据百分比不能超过这个值。如果脏数据超过这个数量，新的IO请求将会被阻挡，直到脏数据被写进磁盘。这是造成IO卡顿的重要原因，但这也是保证内存中不会存在过量脏数据的保护机制。对于将这些数据刷新到磁盘，默认时间限制为120秒，如果超时可能会报错 `INFO: task xxx blocked for more than 120 seconds`，进而导致系统不可用(https://www.blackmoreops.com/2014/09/22/linux-kernel-panic-issue-fix-hung_task_timeout_secs-blocked-120-seconds-problem/)</span></span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line"><span class="comment"># vm.dirty_expire_centisecs 指定脏数据能存活的时间。在这里它的值是30秒。当 pdflush/flush/kdmflush 进行起来时，它会检查是否有数据超过这个时限，如果有则会把它异步地写到磁盘中。毕竟数据在内存里待太久也会有丢失风险</span></span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line"><span class="comment"># vm.dirty_writeback_centisecs 指定多长时间 pdflush/flush/kdmflush 这些进程会起来一次</span></span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br></pre></td></tr></table></figure><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>Linux是基于Unix的，其内核是开源的。redhat、centos、ubuntu都是基于linux内核将一些小程序组装到一起的linux发行套件</li><li>linux的库为<code>.so</code>共享对象，windows的库为<code>.dll</code>动态链接库</li><li><code>#</code>为root命令提示符，<code>$</code>普通用户提示符</li><li>命令格式：<code>命令 选项 参数</code></li></ul><h3 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h3><ul><li>linux分区命名(/dev/xxyN)<ul><li>linux将所有的硬件也看作是文件，全部在<code>/dev</code>目录<ul><li><code>/dev/cdrom</code> 光驱</li></ul></li><li>xx：分区名的前两个字母表明设备类型，hd(IDE磁盘)或sd(SCSI磁盘)</li><li>y：标明分区所在设备，<code>/dev/hda</code>(第一个IDE磁盘)或<code>/dev/sdb</code>(第二个SCSI磁盘)</li><li>N：最后的数字代表分区。前四个分区(主分区或扩展分区)是用数字从1-4表示，逻辑分区从5开始。<code>/dev/sdb6</code>(第二个SCSI磁盘上的第二个逻辑分区)</li></ul></li><li>磁盘分区和挂载点<ul><li>挂载是将分区关联到某一目录(通常称为挂载点)的过程。</li><li>一般在<code>/mnt</code>目录创建对应的挂载目录，如cdrom直接访问不了，通过挂载实现访问：<ul><li>在<code>/mnt</code>下新建目录<code>cdr</code></li><li>挂载分区<code>mount /dev/cdrom /mnt/cdr</code><ul><li>访问<code>/mnt/cdr</code>即是访问<code>/dev/cdrom</code>的数据</li></ul></li><li>卸载分区<code>umount /dev/cdrom</code></li></ul></li></ul></li><li>手动分区<ul><li><code>/</code> 根分区(硬盘上分一个区挂载到’/‘上)</li><li><code>/usr</code> 应用软件存放位置</li><li><code>/home</code> 用户宿主目录</li><li><code>/var</code> 存放临时文件</li><li><code>/boot</code> 存放启动文件(128M足够了)</li><li><code>SWAP</code> 交换分区(一般是内存的两倍)</li></ul></li><li>目录结构<ul><li><code>/bin</code> 基础系统所需命令位于此目录，如<code>ls</code>、<code>mkdir</code>，普通用户都可以使用的命令。和<code>/usr/bin</code>类似</li><li><code>/dev</code> 设备文件存储目录，如声卡(eth0)、磁盘、光驱(cdrom)</li><li><strong><code>/etc</code></strong> 系统配置文件所在地，一些服务器的配置文件也在此处<ul><li><code>rc.local</code> 文件，是<code>/etc/rc.d/rc.local</code>的symbolic link（系统启动会执行此文件）<ul><li>centos7以不推荐使用，如需基于此文件自动启动，则须执行<code>chmod +x /etc/rc.d/rc.local</code></li></ul></li><li><code>/init.d</code> 服务启动文件目录(脚本文件书写参考此目录下network文件)。是<code>/etc/rc.d/init.d</code>的symbolic link。(ubuntu启动目录是/etc/init.d)</li><li><code>hosts</code></li></ul></li><li><code>/home</code> 用户家目录</li><li><code>/lib</code> 库文件存放目录</li><li><code>/lost+found</code> 在ext2或ext3文件系统中，当系统意外崩溃或意外关机，而产生的一些文件碎片存放在此处。当再次启动时会进行检查修复。</li><li><code>/media</code> 即插即用型存储设备挂载点自动在这个目录下创建，如USB盘系统</li><li><code>/mnt</code> 用于存放挂载存储设备的挂载目录</li><li><strong><code>/proc</code></strong> 操作系统运行时，进场信息及内核信息(cpu，内存)存放在这里<ul><li>proc目录为内核映射文件，修改此目录的文件就会修改内存数据</li></ul></li><li><code>/root</code> 超级权限用户root的家目录</li><li><code>/sbin</code> 大多设计系统管理的命令存放，是超级权限用户root的可执行命令存放地，普通用户无法执行。和<code>/usr/sbin</code>、<code>/usr/local/sbin</code>目录类似</li><li><code>/tmp</code> 临时文件目录。和<code>/var/tmp</code>目录类似</li><li><code>/var</code><ul><li><strong><code>cat /var/log/messages</code></strong> 服务运行的日志文件</li><li><code>/var/log</code>目录下其他日志文件，详细参考：<a href="https://www.cnblogs.com/kaishirenshi/p/7724963.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaishirenshi/p/7724963.html</a><ul><li><code>dmesg</code> 包含内核缓冲信息（kernel ringbuffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看</li><li><code>auth.log</code> 包含系统授权信息，包括用户登录和使用的权限机制等</li><li><code>daemon.log</code> 包含各种系统后台守护进程日志信息</li><li><code>kern.log</code> 包含内核产生的日志，有助于在定制内核时解决问题</li><li><code>yum.log</code> 包含使用yum安装的软件包信息</li><li><code>cron</code> 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中</li><li><code>secure</code> 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里</li><li><code>btmp</code> 记录所有失败登录信息。使用last命令可以查看btmp文件（centos7）</li><li><code>faillog</code> 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中</li><li><code>wtmp</code>或<code>utmp</code> 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等</li><li><code>maillog</code>和<code>mail.log</code> 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件</li><li><code>anaconda/</code> 在安装Linux时，所有安装信息都储存在这个文件中</li><li><code>mail/</code> 这个子目录包含邮件服务器的额外日志</li></ul></li></ul></li><li><code>/usr</code> 用户目录。系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32<ul><li><code>/local</code> <strong>一般为安装软件目录</strong>，源码编译安装一般在<code>/usr/local/lib</code>目录下。用户级的程序目录，可以理解为C:/Progrem Files/，用户自己编译的软件默认会安装到这个目录下</li><li><code>src</code> 系统级的源码目录</li><li><code>/local/src</code>：用户级的源码目录</li></ul></li><li><code>/opt</code> <strong>标识可选择的意思，一些软件包也会安装在这里，也就是自定义软件包</strong>。用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用</li></ul></li></ul><h3 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h3><ul><li><code>/etc/profile</code> 系统环境信息，如环境变量，对所有用户生效；当用户第一次登录时，该文件被执行。并从 <code>/etc/profile.d</code> 目录的配置文件中收集 shell 的设置。对 /etc/profile 有修改的话必须得 source 一下修改才会生效(如果第二次登录仍然不生效可考虑重启一下系统，当系统不能重启时，可考虑将设置添加到<code>/etc/bashrc</code>)</li><li><code>/etc/bashrc</code> 当 bash shell 被打开时，该文件被读取执行，对所有用户生效。修改文件后，重新打开一个 bash 即可生效</li><li><code>~/.bash_profile</code> 当用户登录时，文件仅仅执行一次，对当前用户生效(有时候修改了此文件，不想重新登录，可通过source执行一下此文件使其生效)。默认情况下，为了设置一些环境变量，和<strong>执行用户的 <code>~/.bashrc</code> 文件</strong></li><li><code>~/.bashrc</code> 对当前登录用户生效，每次打开 bash shell 时生效，<strong>默认调用了<code>/etc/bashrc</code></strong></li><li><code>~/.bash_logout</code> 当每次退出系统(退出 bash shell)时，执行该文件</li><li><code>/etc/environment</code> 设置环境变量。/etc/profile &gt; /etc/environment &gt; ~/.bash_profile</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>参考 <a href="/_posts/linux/network.md#Linux网络">《网络》http://blog.aezo.cn/2019/06/20/linux/network/</a></p><h2 id="xshell使用"><a href="#xshell使用" class="headerlink" title="xshell使用"></a>xshell使用</h2><ul><li>工具-&gt;选项-&gt;键盘和鼠标-将选定的文本自动复制到剪贴板</li><li>数字小键盘输入，如果不设置的话，会显示乱码：连接配置 - 终端 - VT模式 - 设置为普通</li><li>复制屏幕内容到记事本：鼠标右键 - 选择”To Notepad”(记事本)</li><li>快速切换打开的Tab：快捷键：Alt+1~9 或者Shift+Tab</li></ul><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><ul><li><a href="https://man7.org/linux/man-pages/dir_all_alphabetic.html" target="_blank" rel="noopener">man-pages</a>、<a href="https://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a></li><li>linux三剑客grep、sed、awk语法</li></ul><h3 id="grep-过滤器"><a href="#grep-过滤器" class="headerlink" title="grep 过滤器"></a>grep 过滤器</h3><ul><li><p>语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] <span class="string">'搜寻字符串'</span> filename</span><br><span class="line"><span class="comment"># filename不能缺失</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项与参数：</span></span><br><span class="line"><span class="comment"># -v **反向选择**，亦即显示出没有 '搜寻字符串' 内容的那一行</span></span><br><span class="line"><span class="comment"># -R/-r 递归查询子目录</span></span><br><span class="line"><span class="comment"># -i 忽略大小写的不同，所以大小写视为相同</span></span><br><span class="line"><span class="comment"># -l 显示文件名</span></span><br><span class="line"><span class="comment"># -E 以 egrep 模式匹配，开启扩展（Extend）的正则表达式。egerp更加规范，`egrep -o "oldboy|hello" h.txt` 仅仅输出 oldboy 和 hello</span></span><br><span class="line"><span class="comment"># -P 应用正则表达式</span></span><br><span class="line"><span class="comment"># -n 顺便输出行号</span></span><br><span class="line"><span class="comment"># -c 计算找到 '搜寻字符串' 的次数</span></span><br><span class="line"><span class="comment"># --color=auto 可以将找到的关键词部分加上颜色的显示喔；--color=none去掉颜色显示</span></span><br><span class="line"><span class="comment"># -a 将 binary 文件以 text 文件的方式搜寻数据</span></span><br><span class="line"><span class="comment"># -A &lt;n&gt; 打印匹配行的后几行</span></span><br><span class="line"><span class="comment"># -B &lt;n&gt; 打印匹配行的前几行</span></span><br></pre></td></tr></table></figure></li><li><p>grep的规则表达式（正则一定要转义）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">\    <span class="comment"># 转义符</span></span><br><span class="line">^    <span class="comment">#锚定行的开始 如：'^grep'匹配所有以grep开头的行。    </span></span><br><span class="line">$    <span class="comment">#锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 </span></span><br><span class="line">.    <span class="comment">#匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。</span></span><br><span class="line">*    <span class="comment">#匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。  </span></span><br><span class="line">.*   <span class="comment">#一起用代表任意字符。   </span></span><br><span class="line">[]   <span class="comment">#匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    </span></span><br><span class="line">[^]  <span class="comment">#匹配一个不在指定范围内的字符</span></span><br><span class="line">\(..\)  <span class="comment">#标记匹配字符，如'\(love\)'，love被标记为1。    </span></span><br><span class="line">\&lt;      <span class="comment">#锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。    </span></span><br><span class="line">\&gt;      <span class="comment">#锚定单词的结束，如'grep\&gt;'匹配包含以grep结尾的单词的行。    </span></span><br><span class="line">x\&#123;m\&#125;  <span class="comment">#重复字符x，m次，如：'0\&#123;5\&#125;'匹配包含5个o的行。    </span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment">#重复字符x,至少m次，如：'o\&#123;5,\&#125;'匹配至少有5个o的行。    </span></span><br><span class="line">x\&#123;m,n\&#125;<span class="comment">#重复字符x，至少m次，不多于n次，如：'o\&#123;5,10\&#125;'匹配5--10个o的行。   </span></span><br><span class="line">\w    <span class="comment">#匹配文字和数字字符，也就是[A-Za-z0-9]，</span></span><br><span class="line">\W    <span class="comment">#\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span></span><br><span class="line">\b    <span class="comment">#单词锁定符，如: '\bgrep\b'只匹配grep。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符类(类似oracle正则的字符簇)</span></span><br><span class="line">[[:digit:]] <span class="comment">#数字</span></span><br><span class="line">[[:lower:]] <span class="comment">#小写字母</span></span><br><span class="line">[[:upper:]] <span class="comment">#大写字母</span></span><br><span class="line">[[:alpha:]] <span class="comment">#字母</span></span><br><span class="line">[[:alnum:]] <span class="comment">#字母数字</span></span><br><span class="line">[[:blank:]] <span class="comment">#空字符: 空格键符 和 制表符</span></span><br><span class="line">[[:space:]] <span class="comment">#空格字符: 制表符、换行符、垂直制表符、换页符、回车符和空格键符</span></span><br></pre></td></tr></table></figure></li><li><p>说明</p><ul><li>grep命令的模式(即搜寻字符串)，可以是字符串、变量，还可以是正则表达式。如果模式中包含空格则需要单双引号包裹</li></ul></li><li><a href="https://www.cnblogs.com/terryjin/p/5167789.html" target="_blank" rel="noopener">grep正则表达式</a></li><li><p>常见用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"search content"</span> filename1 filename2.... filenamen <span class="comment"># 在多个文件中查找数据(查询文件内容)</span></span><br><span class="line">grep <span class="string">'search content'</span> *.sql <span class="comment"># 查找已`.sql`结尾的文件</span></span><br><span class="line">grep -R <span class="string">'test'</span> /data/* <span class="comment"># 在/data目录及子目录查询</span></span><br><span class="line">grep hello -rl * <span class="comment"># 查询当前目录极其子目录文件(-r)，并只输出文件名(-l)</span></span><br><span class="line"></span><br><span class="line">grep -5 <span class="string">'parttern'</span> filename <span class="comment"># 打印匹配行的前后5行。或 `grep -C 5 'parttern' filename`</span></span><br><span class="line">grep -A 5 <span class="string">'parttern'</span> filename <span class="comment"># 打印匹配行的后5行</span></span><br><span class="line">grep -B 5 <span class="string">'parttern'</span> filename <span class="comment"># 打印匹配行的前5行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配或、且、非</span></span><br><span class="line">grep -E <span class="string">'A|B|C.*'</span> filename <span class="comment"># 打印匹配 A 或 B 或 C* 的数据</span></span><br><span class="line">egrep <span class="string">'word1|word2'</span> 文件名</span><br><span class="line">grep <span class="string">'word1/|word2'</span> 文件名 <span class="comment"># /转义</span></span><br><span class="line">grep <span class="string">'A'</span> filename | grep <span class="string">'B'</span> <span class="comment"># 打印匹配 A 且 B 的数据</span></span><br><span class="line">grep -v <span class="string">'A'</span> filename <span class="comment"># 打印不包含 A 的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -P正则</span></span><br><span class="line"><span class="built_in">echo</span> office365 | grep -P <span class="string">'\d+'</span> -o <span class="comment"># 返回 365</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配2022-05-12 17:19这个分钟的某线程日志</span></span><br><span class="line">grep <span class="string">'2022-05-12 17:19.* |-0.0.0.0-7100-exec-9'</span> *-2022-05-12-*.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 匹配如：`...51:1:CMAU0245097:H4832357:22G1:8:22:4629:2190:21:::::::1'...`</span></span><br><span class="line">egrep -r <span class="string">"51:.*:1'"</span> /data/BTC_RECV/RecvCN1101/21/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取10分钟内容(包含12:09:59的数据，但是分钟不能写成12:[05-15])</span></span><br><span class="line">grep <span class="string">"2000-01-01 12:0[0-9]"</span> out.log &gt; log.txt</span><br><span class="line"><span class="comment"># sed截取则更方便</span></span><br><span class="line">sed -n <span class="string">'/2000-01-01 12:00:00/,/2000-01-01 12:01:30/p'</span> out.log &gt; log.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转义和字符类</span></span><br><span class="line">grep <span class="string">'192\.168\.1\.254'</span> /etc/hosts <span class="comment"># 三个点字符都需要转义</span></span><br><span class="line">egrep <span class="string">'[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;'</span> 文件名 <span class="comment"># 只能匹配出 IP 地址</span></span><br><span class="line">grep <span class="string">"[[:digit:]]\&#123;2\&#125;[ -]\?[[:digit:]]\&#123;10\&#125;"</span> 文件名 <span class="comment"># 会匹配 91-1234567890、91 1234567890、911234567890这种格式的手机号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据日志查询最近执行命令时间(结合tail -1)</span></span><br><span class="line">grep <span class="string">'cmd-hostory'</span> /var/<span class="built_in">log</span>/local1-info.log | tail -1 | awk <span class="string">'&#123;print $1,$2&#125;'</span></span><br><span class="line"><span class="comment"># 查看20号的oracle trc日志，并找出日志中出现ORA-的情况</span></span><br><span class="line">ll -hrt *.trc | grep <span class="string">' 20 '</span> | awk <span class="string">'&#123;print $9&#125;'</span> | xargs grep <span class="string">'ORA-'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站访问量相关统计</span></span><br><span class="line"><span class="comment"># https://mp.weixin.qq.com/s/vUvYdeo5eAXR1vdOpSN0WQ</span></span><br></pre></td></tr></table></figure></li><li><p>grep结果单独处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">ps -ewo pid,etime,cmd | grep ofbiz.jar | grep -v grep | <span class="keyword">while</span> <span class="built_in">read</span> -r pid etime cmd ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"===&gt;<span class="variable">$pid</span> <span class="variable">$cmd</span> <span class="variable">$etime</span>"</span>; <span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r proc; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'====&gt;'</span> <span class="variable">$proc</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;&lt; <span class="string">"<span class="variable">$(ps -ef | grep ofbiz.jar | grep -v grep)</span>"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="sed-行编辑器"><a href="#sed-行编辑器" class="headerlink" title="sed 行编辑器"></a>sed 行编辑器</h3><ul><li><code>sed</code> 行编辑器，默认不编辑原文件，仅对模式空间中的数据做处理；而后处理结束后将模式空间打印至屏幕</li><li>语法 <strong><code>sed [options] &#39;内部命令表达式&#39; file ...</code></strong><ul><li>“sed “s/zhangsan/lisi/g” <code>grep zhangsan -rl *</code>“ 修改(未加-i参数不会真正修改数据)当前目录极其子目录下所有文件，将zhangsan改成lisi。grep -rl 递归显示文件名</li></ul></li><li>参数<ul><li><code>-n</code> 静默模式，不再默认显示模式空间中的内容</li><li><code>-i</code> <strong>直接修改原文件</strong>(默认只输出结果。可以先不加此参数进行修改预览)</li><li><code>-e script -e script</code> 可以同时执行多个脚本</li><li><code>-f</code> 如<code>sed -f /path/to/scripts file</code></li><li><code>-r</code> 表示使用扩展正则表达式</li></ul></li><li>内部命令<ul><li>内部命令表达式如果含有变量可以使用双引号，单引号无法解析变量</li><li>前缀修饰符<ul><li><code>s</code> 查找并替换，<strong><code>s/pattern/string/修饰符</code></strong><ul><li>默认只替换每行中第一次被模式匹配到的字符串；<strong>其中/可为其他分割符，如<code>#</code>、<code>@</code>等，也可通过右斜杠转义分隔符</strong></li><li><code>sed &quot;s/foo/bar/g&quot; test.md</code> 替换每一行中的”foo”都换成”bar”(加-i直接修改源文件)</li><li><code>sed &#39;s#/data#/data/harbor#g&#39; docker-compose.yml</code> 修改所有”/data”为”/data/harbor”</li></ul></li></ul></li><li>后缀修饰符<ul><li><code>g</code> 全局查找</li><li><code>i</code> 忽略字符大小写</li><li><code>p</code> 显示符合条件的行</li><li><code>d</code> 删除符合条件的行</li></ul></li><li><code>a \string</code>: 在指定的行后面追加新行，内容为string<ul><li><code>\n</code> 可以用于换行</li></ul></li><li><code>i \string</code>: 在指定的行前面添加新行，内容为string</li><li><code>r &lt;file&gt;</code> 将指定的文件的内容添加至符合条件的行处</li><li><code>w &lt;file&gt;</code> 将地址指定的范围内的行另存至指定的文件中</li><li><code>&amp;</code> 引用模式匹配整个串</li></ul></li><li>示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改(未加-i参数不会真正修改数据)当前目录极其子目录下所有文件，将zhangsan改成lisi。grep -rl 递归显示文件名</span></span><br><span class="line">sed <span class="string">"s/zhangsan/lisi/g"</span> `grep zhangsan -rl *`</span><br><span class="line"><span class="comment"># 加上参数`-i`会直接修改原文件(去掉文件中所有空行)</span></span><br><span class="line">sed -i -e <span class="string">'/^$/d'</span> /home/smalle/test.txt</span><br><span class="line"><span class="comment"># 删除/etc/grub.conf文件中行首的空白符</span></span><br><span class="line">sed -r <span class="string">'s@^[[:space:]]+@@g'</span> /etc/grub.conf</span><br><span class="line"><span class="comment"># 替换/etc/inittab文件中"id:3:initdefault:"一行中的数字为5</span></span><br><span class="line">sed <span class="string">'s@\(id:\)[0-9]\(:initdefault:\)@\15\2@g'</span> /etc/inittab</span><br><span class="line"><span class="comment"># 删除/etc/inittab文件中的空白行(此时会返回修改后的数据，但是原始文件中的内容并不会被修改)</span></span><br><span class="line">sed <span class="string">'/^$/d'</span> /etc/inittab</span><br><span class="line"></span><br><span class="line"><span class="comment"># s表示替换，\1表示用第一个括号里面的内容替换整个字符串。sed支持*，不支持?、+，不能用\d之类，正则支持有限</span></span><br><span class="line"><span class="built_in">echo</span> here365test | sed <span class="string">'s/.*ere\([0-9]*\).*/\1/g'</span> <span class="comment"># 365</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找一段时间的日志（此处查询2020-12-03 02到2020-12-03 04的日志，此处使用*表示模糊查询）。注意：开始时间和结束时间必须要是日志里面有的，否则查询不到结果</span></span><br><span class="line">cat access.log | sed -n <span class="string">'/03\/Dec\/2020:02*/,/03\/Dec\/2020:04*/p'</span> | more</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/lutaoact/script/blob/master/sed%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC.txt" target="_blank" rel="noopener">其他示例</a></li></ul><h3 id="awk-文本分析工具"><a href="#awk-文本分析工具" class="headerlink" title="awk 文本分析工具"></a>awk 文本分析工具</h3><ul><li>相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。<strong>简单来说awk就是把文件逐行的读入，以空格/tab为默认分隔符将每行切片，切开的部分再进行各种分析处理(每一行都会执行一次awk主命令)</strong></li><li>简单案例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示最近登录的5个帐号。读入有'\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域(填充域)。**$0则表示所有域, $1表示第一个域**，$n表示第n个域。默认域分隔符是空格/tab，所以$1表示登录用户，$3表示登录用户ip，以此类推</span></span><br><span class="line">last -n 5 | awk <span class="string">'&#123;print $1 $2&#125;'</span> <span class="comment">#此时打印的两个变量中间不带空格</span></span><br><span class="line">last -n 5 | awk <span class="string">'&#123;print $1,$2&#125;'</span> <span class="comment"># print多个变量用逗号分割，显示默认带有空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是显示/etc/passwd中的账户。`-F`指定域分隔符为`:`，默认是空格/tab</span></span><br><span class="line">cat /etc/passwd | awk -F <span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找root开头的用户记录</span></span><br><span class="line">awk -F : <span class="string">'/^root/'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉所有的java进程</span></span><br><span class="line">ps -ef | grep java | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><ul><li><p>语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'[BEGIN &#123;&#125;] &#123;pattern + action&#125; [END &#123;&#125;]'</span> &#123;filenames&#125;</span><br><span class="line"><span class="comment"># pattern 表示AWK在文件中查找的内容。pattern就是要表示的正则表达式，用斜杠(`'/xxx/'`)括起来</span></span><br><span class="line"><span class="comment"># action 是在找到匹配内容时所执行的一系列命令(awk主命令)</span></span><br><span class="line"><span class="comment"># 花括号(`&#123;&#125;`)不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## awk --help</span></span><br><span class="line">Usage: awk [POSIX or GNU style options] -f progfile [--] file ...</span><br><span class="line">Usage: awk [POSIX or GNU style options] [--] <span class="string">'program'</span> file ...</span><br><span class="line">POSIX options:		GNU long options: (standard)</span><br><span class="line">-f progfile		--file=progfile         <span class="comment"># 指定程序文件</span></span><br><span class="line">-F fs			--field-separator=fs    <span class="comment"># 指定域分割符(可使用正则，如 `-F '[\t \\\\]'`)</span></span><br><span class="line">-v var=val		--assign=var=val</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p>awk中同时提供了<code>print</code>和<code>printf</code>两种打印输出的函数</p><ul><li><code>print</code> 参数可以是变量、数值或者字符串。<strong>字符串必须用双引号引用，参数用逗号分隔。</strong>如果没有逗号，参数就串联在一起而无法区分。</li><li><code>printf</code> 其用法和c语言中printf基本相似，可以格式化字符串，输出复杂时</li></ul></li><li><p>awk相关变量</p><ul><li><code>$0</code>变量是指整条记录，<code>$1</code>表示当前行的第一个域，<code>$2</code>表示当前行的第二个域，以此类推</li><li>awk内置变量：awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量<ul><li><code>ARGC</code> 命令行参数个数</li><li><code>ARGV</code> 命令行参数排列</li><li><code>ENVIRON</code> 支持队列中系统环境变量的使用</li><li><code>FILENAME</code> awk浏览的文件名</li><li><code>FNR</code> 浏览文件的记录数</li><li><code>FS</code> 设置输入域分隔符，等价于命令行-F选项</li><li><code>NF</code> 浏览记录的域的个数</li><li><code>NR</code> 已读的记录数</li><li><code>OFS</code> 输出域分隔符</li><li><code>ORS</code> 输出记录分隔符(<code>\n</code>)</li><li><code>RS</code> 控制记录分隔符</li></ul></li><li><p>自定义变量</p><ul><li><p>下面统计/etc/passwd的账户人数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;count++;print $0;&#125; END &#123;print "user count is ", count&#125;'</span> /etc/passwd</span><br><span class="line"><span class="comment"># 打印如下</span></span><br><span class="line"><span class="comment"># root:x:0:0:root:/root:/bin/bash</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># user count is 40</span></span><br></pre></td></tr></table></figure><ul><li>count是自定义变量。之前的action{}里都是只有一个print，其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0</li></ul></li></ul></li><li><p>awk与shell之间的变量传递方法</p><ul><li><p>awk中使用shell中的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取普通变量(第一个双引号为了转义单引号，第二个双引号为了转义变量中的空格)</span></span><br><span class="line">var=<span class="string">"hello world"</span> &amp;&amp; awk <span class="string">'BEGIN&#123;print "'</span><span class="string">"<span class="variable">$var</span>"</span><span class="string">'"&#125;'</span></span><br><span class="line"><span class="comment"># 把系统变量var传递给了awk变量awk_var</span></span><br><span class="line">var=<span class="string">"hello world"</span> &amp;&amp; awk -v awk_var=<span class="string">"<span class="variable">$var</span>"</span> <span class="string">'BEGIN &#123;print awk_var&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取环境变量(ENVIRON)</span></span><br><span class="line">var=<span class="string">"hello world"</span> &amp;&amp; <span class="built_in">export</span> var &amp;&amp; awk <span class="string">'BEGIN&#123;print ENVIRON["var"]&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>awk向shell变量传递值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(awk <span class="string">'BEGIN&#123;print "var1='</span><span class="string">"'str 1'"</span><span class="string">';var2='</span><span class="string">"'str 2'"</span><span class="string">'"&#125;'</span>) &amp;&amp; <span class="built_in">echo</span> <span class="string">"var1=<span class="variable">$var1</span> ----- var2=<span class="variable">$var2</span>"</span> <span class="comment"># var1=str1 ----- var2=str2</span></span><br><span class="line"><span class="comment"># 读取temp_file中数据设置到变量中(temp_file中输入`hello world:test`，如果文件中有多行，则最后一行会覆盖原来的赋值)</span></span><br><span class="line"><span class="built_in">eval</span> $(awk <span class="string">'&#123;printf("var3=%s; var4=%s;",$1,$2)&#125;'</span> temp_file) &amp;&amp; <span class="built_in">echo</span> <span class="string">"var3=<span class="variable">$var3</span> ----- var4=<span class="variable">$var4</span>"</span> <span class="comment"># var3=hello ----- var4=world:test</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>支持<code>BEGIN/END</code>语句(必须大写)</p><ul><li>BEGIN和END，这两者都可用于pattern中，<strong>提供BEGIN的作用是扫描输入之前赋予程序初始状态，END是扫描输入结束且在程序结束之后执行一些扫尾工作</strong>。任何在BEGIN之后列出的操作(紧接BEGIN后的{}内)将在awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。通常使用BEGIN来显示变量和预置(初始化)变量，使用END来输出最终结果。</li><li><p>统计某个文件夹下的文件占用的字节数，过滤4096大小的文件(一般都是文件夹):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l | awk <span class="string">'BEGIN &#123;size=0;print "[start]size is", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END &#123;print "[end]size is", size/1024/1024, "M"&#125;'</span></span><br><span class="line"><span class="comment"># 打印如下</span></span><br><span class="line"><span class="comment"># [start]size is 0</span></span><br><span class="line"><span class="comment"># [end]size is 30038.8 M</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>支持if判断、循环等语句</p></li></ul><h3 id="cut-文本剪切"><a href="#cut-文本剪切" class="headerlink" title="cut 文本剪切"></a>cut 文本剪切</h3><ul><li>参数说明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一</span></span><br><span class="line">usage: cut -b list [-n] [file ...]</span><br><span class="line">       cut -c list [file ...]</span><br><span class="line">       cut -f list [-s] [-d delim] [file ...]</span><br><span class="line">-b <span class="comment">#以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志</span></span><br><span class="line">-n <span class="comment">#取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</span></span><br><span class="line">-c <span class="comment">#以字符为单位进行分割</span></span><br><span class="line">-d <span class="comment">#自定义分隔符，默认(不加-d参数时)为制表符. 如：-d ' ' 分割符为空格</span></span><br><span class="line">-f <span class="comment">#与-d一起使用，指定要显示的字段. 如：-f1(显示第1个字段)、-f 1,3(显示第1至3个字段)、-f 1-3</span></span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示第3个字符(此时-b也是一样的)</span></span><br><span class="line">who | cut -c 3</span><br><span class="line"><span class="comment"># 显示第1个字符，和第3个字符及之后的数据</span></span><br><span class="line">who | cut -c 1,3- <span class="comment"># salle   console  Dec 21 21:39</span></span><br><span class="line"><span class="comment"># 如查看用户数</span></span><br><span class="line">wc -l /etc/passwd | cut -d <span class="string">' '</span> -f1</span><br><span class="line"><span class="comment"># 查看ip</span></span><br><span class="line">ifconfig lo0 | grep <span class="string">"inet "</span> | cut -d <span class="string">' '</span> -f 2 <span class="comment"># 127.0.0.1</span></span><br></pre></td></tr></table></figure><h3 id="sort-文本排序"><a href="#sort-文本排序" class="headerlink" title="sort 文本排序"></a>sort 文本排序</h3><ul><li>语法：<strong><code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件][-k field1[,field2]]</code></strong><ul><li><code>ll | sort -n --key=5</code> 以第5列的字段(文件大小)进行排序</li></ul></li><li>参数说明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-b <span class="comment">#忽略每行前面开始出的空格字符</span></span><br><span class="line">-c <span class="comment">#检查文件是否已经按照顺序排序</span></span><br><span class="line">-d <span class="comment">#排序时，处理英文字母、数字及空格字符外，忽略其他的字符</span></span><br><span class="line">-f <span class="comment">#排序时忽略字符大小写</span></span><br><span class="line">-i <span class="comment">#排序时，除了040至176之间的ASCII字符外，忽略其他的字符</span></span><br><span class="line">-m <span class="comment">#将几个排序好的文件进行合并</span></span><br><span class="line">-M <span class="comment">#将前面3个字母依照月份的缩写进行排序</span></span><br><span class="line">-n <span class="comment">#数值排序</span></span><br><span class="line">-r <span class="comment">#降序</span></span><br><span class="line">-u <span class="comment">#排序后相同的行只显示一次</span></span><br><span class="line">-o&lt;输出文件&gt; <span class="comment">#将排序后的结果存入指定的文件</span></span><br><span class="line">-t&lt;分隔字符&gt; <span class="comment">#指定排序时所用的栏位分隔字符</span></span><br><span class="line">+&lt;起始栏位&gt;-&lt;结束栏位&gt; <span class="comment">#以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位</span></span><br><span class="line">--<span class="built_in">help</span> <span class="comment">#显示帮助</span></span><br><span class="line">--version <span class="comment">#显示版本信息</span></span><br><span class="line">[-k field1[,field2]] <span class="comment">#按指定的列进行排序</span></span><br></pre></td></tr></table></figure><h3 id="wc-文本统计"><a href="#wc-文本统计" class="headerlink" title="wc 文本统计"></a>wc 文本统计</h3><ul><li><code>wc</code> 文本统计<ul><li>统计指定文本文件的行数(<code>-l</code>)、字数(-w)、字节数(-c)</li><li><code>sudo docker ps | wc -l</code></li></ul></li></ul><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">date -d <span class="string">'yesterday'</span> <span class="comment"># 获取昨天。或 date -d 'last day' </span></span><br><span class="line">date -d <span class="string">'tomorrow'</span> <span class="comment"># 获取明天。或 date -d 'next day' </span></span><br><span class="line">date -d <span class="string">'last month'</span> <span class="comment"># 获取上个月 </span></span><br><span class="line">date -d <span class="string">'next month'</span> <span class="comment"># 获取下个月 </span></span><br><span class="line">date -d <span class="string">'last year'</span> <span class="comment"># 获取上一年 </span></span><br><span class="line">date -d <span class="string">'next year'</span> <span class="comment"># 获取下一年 </span></span><br><span class="line">date -d <span class="string">'1 minute ago'</span> <span class="comment"># 获取1分钟前</span></span><br><span class="line">date -d <span class="string">'3 year ago'</span> <span class="comment"># 三年前 </span></span><br><span class="line">date -d <span class="string">'-5 year ago'</span> <span class="comment"># 五年后 </span></span><br><span class="line">date -d <span class="string">'-2 day ago'</span> <span class="comment"># 两天后 </span></span><br><span class="line">date -d <span class="string">'1 month ago'</span> <span class="comment"># 一个月前 </span></span><br><span class="line"></span><br><span class="line">time=$(date <span class="string">"+%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># default path is the current directory; default expression is -print</span></span><br><span class="line"><span class="comment"># expression由options、tests、actions组成</span></span><br><span class="line">find [-H] [-L] [-P] [-Olevel] [-D <span class="built_in">help</span>|tree|search|<span class="built_in">stat</span>|rates|opt|<span class="built_in">exec</span>] [path...] [expression]</span><br><span class="line"></span><br><span class="line"><span class="comment">## expression#options</span></span><br><span class="line">-mindepth n <span class="comment"># 目录进入最小深度</span></span><br><span class="line">    <span class="comment"># eg: -mindepth 1 # 意味着处理所有的文件，除了命令行参数指定的目录中的文件</span></span><br><span class="line">-maxdepth n <span class="comment"># 目录进入最大深度</span></span><br><span class="line">    <span class="comment"># eg: -maxdepth 0 # 只处理当前目录的文件(.)，且目录必须为/xxx/*的格式，具体案例参考下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## expression#tests</span></span><br><span class="line">-path/-prune/-o</span><br><span class="line">    <span class="comment"># "-path 过滤的文件或目录 -prune -o" 如果-prune之前的语句为真，即当前文件/目录为-path指定的文件/目录，就不再执行后面-o跟的语句了，如果没有找到则执行后面的语句。其中的"-o" 是 "-or" 的意思</span></span><br><span class="line">-name &lt;patten&gt; <span class="comment"># 基本的文件名与shell模式pattern相匹配。**正则建议使用""或''包裹**</span></span><br><span class="line">    <span class="comment"># eg: -name "*.log" # `.log`开头的文件。如果不用双引号包裹，*可能展开为当前目录下所有的文件；或者使用\转义</span></span><br><span class="line">-<span class="built_in">type</span> &lt;c&gt; <span class="comment"># 文件类型，c取值</span></span><br><span class="line">    f <span class="comment"># 普通文件(regular file)</span></span><br><span class="line">    d <span class="comment"># 目录(directory)</span></span><br><span class="line">    s <span class="comment"># socket</span></span><br><span class="line"></span><br><span class="line">-atime &lt;n&gt; <span class="comment"># 针对文件的访问时间，判断 "其访问时间" &lt; "当前时间-(n*24小时)" 是否为真。对应stat命令获取的 Access 时间，读取文件或者执行文件时更改的</span></span><br><span class="line">-mtime &lt;n&gt; <span class="comment"># 针对文件的修改时间(天)。对应stat命令获取的 Modify 时间，是在写入文件时随文件内容的更改而更改的</span></span><br><span class="line">    <span class="comment"># eg: -mtime +30 # 30天之前的修改过的文件</span></span><br><span class="line">    <span class="comment"># eg：-mtime -30 # 过去30天之内修改过的文件</span></span><br><span class="line">-ctime &lt;n&gt; <span class="comment"># 针对文件的改变时间(天)。对应stat命令获取的 Change 时间，是在写入文件，更改所有者，权限或链接设置是随inode(存放文件基本信息)内容的更改而更改的</span></span><br><span class="line">-amin &lt;n&gt; <span class="comment"># 类似-atime，只不过此参数是基于分钟计算</span></span><br><span class="line">-mmin &lt;n&gt;</span><br><span class="line">-cmin &lt;n&gt;</span><br><span class="line">-newerXY &lt;reference&gt; <span class="comment"># 比较文件的时间戳，其中XY的取值为：a(访问时间)、c(改变时间,移动目录时间也会变)、m(修改时间)、t(绝对时间)、B(文件引用的出现时间)；参数值时间必须精确到天或者秒，且为前闭后开区间</span></span><br><span class="line">    <span class="comment"># find . -type f -newermt '2020-01-17 13:40:00' ! -newermt '2020-01-17 13:45:00' -exec cp &#123;&#125; ./bak \; # 将当前目录下 [2020-01-17 13:40:00,2020-01-17 13:45:00) 时间段内修改或生成的文件拷贝到bak目录下。同理：-newerat、-newerct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## expression#actions</span></span><br><span class="line">-<span class="built_in">exec</span> <span class="built_in">command</span> <span class="comment"># 执行命令。命令的参数中，字符串`&#123;&#125;`将以正在处理的文件名替换；这些参数可能需要用 `\`来escape，或者用括号括住，防止它们被shell展开；其余的命令行参数将作为提供给此命令的参数，直到遇到一个由`;`组成的参数为止</span></span><br><span class="line">    <span class="comment"># eg: -exec cp &#123;&#125; &#123;&#125;.bak \; # 复制查询到的文件</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name nginx.conf <span class="comment"># 全局查询文件位置(查看`nginx.conf`文件所在位置)</span></span><br><span class="line">find /home/smalle/s_*/<span class="keyword">in</span> -maxdepth 1 -<span class="built_in">type</span> f <span class="comment"># 查询s_开头目录下，in目录的文件（不包含in的子目录）。或者 find /home/smalle/s_*/in/* -type f</span></span><br><span class="line">find path_A -name <span class="string">'*AAA*'</span> -<span class="built_in">exec</span> mv -t path_B &#123;&#125; + <span class="comment"># 批量移动，下同</span></span><br><span class="line">find path_A -name <span class="string">"*AAA*"</span> -print0 | xargs -0 -I &#123;&#125; mv &#123;&#125; path_B</span><br><span class="line">find . -mtime +15 | wc -l <span class="comment"># 统计15天前修改过的文件的个数</span></span><br><span class="line"></span><br><span class="line">find . -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \; <span class="comment"># 修改当前目录及其子目录为775</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> chmod 644 &#123;&#125; \; <span class="comment"># 修改当前目录及其子目录的所有文件为644</span></span><br><span class="line"></span><br><span class="line">find -name <span class="string">'*.TXT'</span> -<span class="built_in">type</span> f -mtime +15 -<span class="built_in">exec</span> mv &#123;&#125; ./bak \; <span class="comment"># 将15天前修改过的文件移动到备份目录</span></span><br><span class="line"><span class="comment"># **将当前目录下的去年修改过的文件移动到备份目录(如: ./backup/backup_log_2020)**. (1) 需先创建好备份目录 (2) 时间精确到秒且为前闭后开区间</span></span><br><span class="line">find . -name <span class="string">'*.log'</span> -newermt <span class="string">"<span class="variable">$(($(date +%Y)</span>-1))-01-01 00:00:00"</span> ! -newermt <span class="string">"<span class="variable">$(($(date +%Y)</span>))-01-01 00:00:00"</span> | xargs -i mv &#123;&#125; ./backup/backup_log_$(($(date +%Y)-1))</span><br><span class="line"></span><br><span class="line">find -<span class="built_in">type</span> f | xargs <span class="comment"># xargs会在一行中打印出所有值</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> $(find -<span class="built_in">type</span> f | xargs) ; <span class="keyword">do</span> <span class="comment"># 循环打印每个文件</span></span><br><span class="line">    file <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxdepth注意</span></span><br><span class="line">find /home/<span class="built_in">test</span>/* -maxdepth 0 -name <span class="string">'*.txt'</span> <span class="comment"># 只查询当前目录下文件(不会考虑子目录)</span></span><br><span class="line">find /home/<span class="built_in">test</span>/ -maxdepth 0 -name <span class="string">'*.txt'</span> <span class="comment"># 由于目录没有*，此时获取不到文件，需设置成`-maxdepth 1`才会只查询当前目录下文件(不会考虑子目录)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找/data路径下除tmp目录之外的目录，并统计目录大小，以G位单位进行排序（默认为降序），并统计前10个大小的目录</span></span><br><span class="line">find /data/* -path /data/tmp -prune -o -maxdepth 0 -<span class="built_in">type</span> d -<span class="built_in">exec</span> /usr/bin/du -sh &#123;&#125; \;|grep <span class="string">'[0-9]G'</span>|sort -rh|head -10</span><br></pre></td></tr></table></figure><h3 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh [options] [file] <span class="comment"># 同 bash，从标准输入中读取命令，命令在子shell中执行</span></span><br><span class="line">    -c <span class="comment"># 命令从-c后的字符串读取</span></span><br><span class="line">    -s <span class="comment"># 后面跟的参数，从第一个非 - 开头的参数，就被赋值为子shell的$1,$2,$3....</span></span><br><span class="line">        <span class="comment"># echo 'ls $2' | sh -s '' '-l' # 类似 ls -l</span></span><br></pre></td></tr></table></figure><h3 id="xrags"><a href="#xrags" class="headerlink" title="xrags"></a>xrags</h3><ul><li>xargs 可以将管道或标准输入(stdin)数据转换成命令行参数，也能够从文件的输出中读取数据。它能够捕获一个命令的输出，然后传递给另外一个命令</li><li>xargs 默认的命令是 echo</li><li>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行</li><li>示例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-n&lt;num&gt; <span class="comment"># 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。eg：`cat test.txt | xargs` 多行转单行</span></span><br><span class="line">-i/-I <span class="comment"># 这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给 &#123;&#125;</span></span><br><span class="line">-d delim <span class="comment"># 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 示例</span></span><br><span class="line">cat test.txt | xargs <span class="comment"># 多行转单行</span></span><br><span class="line">cat test.txt | xargs -n3 <span class="comment"># 多行输出，每此使用3个参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameXnameXnameXname"</span> | xargs -dX <span class="comment"># 定义分割符：name name name name</span></span><br><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images <span class="comment"># 复制所有图片文件到 /data/images 目录下(第一个&#123;&#125;可以省略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合自定义函数使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'echo $*'</span> &gt; my.sh</span><br><span class="line">cat &gt; arg.txt &lt;&lt; EOF</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">EOF</span><br><span class="line">cat arg.txt | xargs -I &#123;&#125; ./my.sh &#123;&#125; ...</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line">aaa ...</span><br><span class="line">bbb ...</span><br></pre></td></tr></table></figure><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><ul><li><code>rsyslog</code>是一个C/S架构的服务，可监听于某套接字，帮其它主机记录日志信息。rsyslog是CentOS 6以后的系统使用的日志系统，之前为syslog</li><li><code>logger</code> 是用于往系统中写入日志，他提供一个shell命令接口到rsyslog系统模块。默认记录到系统日志文件<code>/var/log/messages</code></li><li>Linux系统日志信息分为两个部分内核信息和设备信息。共用配置文件<code>/etc/rsyslog.conf</code>(CentOS 6之前为<code>/etc/syslog.conf</code>)<ul><li>内核信息 -&gt; klogd -&gt; syslogd -&gt; /var/log/messages等文件</li><li>设备信息 -&gt; syslogd -&gt; /var/log/dmesg、/var/log/messages等文件<ul><li>设备可以使用自定义的设备local0-local7，使用自定义的设备照样可以将设备信息(日志)发送给rsyslog</li></ul></li></ul></li><li>查看linux相关日志<ul><li><code>/var/log/messages</code> 查看系统日志</li><li><code>dmesg</code> 查看设备日志，如引导时的日志</li><li><code>last</code> 查看登录成功记录</li><li><code>lastb -10</code> 查看最近10条登录失败记录</li><li><code>history</code> 执行命令历史</li></ul></li><li>CentOS 7 修改日志时间戳格式 <a href="https://my.oschina.net/sallency/blog/827737" title="nohup 命令实现守护进程" target="_blank" rel="noopener">^8</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jul 14 13:30:01 localhost systemd: Starting Session 38 of user root.</span></span><br><span class="line"><span class="comment"># 2018-07-14 13:32:57 desktop0 systemd: Starting System Logging Service...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改 /etc/rsyslog.conf </span></span><br><span class="line"><span class="comment"># Use default timestamp format</span></span><br><span class="line"><span class="comment">#$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat # 这行是原来的将它注释，添加下面两行</span></span><br><span class="line"><span class="variable">$template</span> CustomFormat,<span class="string">"%<span class="variable">$NOW</span>% %TIMESTAMP:8:15% %HOSTNAME% %syslogtag% %msg%\n"</span></span><br><span class="line"><span class="variable">$ActionFileDefaultTemplate</span> CustomFormat</span><br><span class="line"></span><br><span class="line"><span class="comment">## 重启</span></span><br><span class="line">systemctl restart rsyslog.service</span><br></pre></td></tr></table></figure><ul><li>logger使用案例 <a href="http://www.cnblogs.com/zutbaz/p/4248845.html" title="用户配置" target="_blank" rel="noopener">^6</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 简单使用</span></span><br><span class="line"><span class="comment"># 默认记录到系统日志文件 /var/log/messages</span></span><br><span class="line">logger hello world  <span class="comment"># 记录如 `Dec  5 15:34:58 localhost root: hello world`</span></span><br><span class="line"><span class="comment"># -i 记录进程id</span></span><br><span class="line">logger -i test1...  <span class="comment"># `Dec  5 15:34:58 localhost root[23162]: test1`</span></span><br><span class="line"><span class="comment"># -s 输出标准错误(命令行会显示此错误)，并且将信息打印到系统日志中</span></span><br><span class="line">logger -i -s test2  <span class="comment"># `Dec  5 15:34:58 localhost root[23162]: test2`</span></span><br><span class="line"><span class="comment"># -t 日志标记，默认是root</span></span><br><span class="line">logger -i -t <span class="built_in">test</span> test3 <span class="comment"># `Dec  5 15:34:58 localhost test[23162]: test2`</span></span><br><span class="line"><span class="comment"># -p 指定输入消息日志级别，优先级可以是数字或者指定为 "facility(设施、信道).level(优先级)" 的格式(默认级别为 "user.notice")，日志会根据配置文件/etc/rsyslog.conf将日志输出到对应日志文件，默认为/var/log/messages</span></span><br><span class="line"><span class="comment"># 固定的 facility 和 level 的类型参考：https://www.cnblogs.com/xingmuxin/p/8656498.html</span></span><br><span class="line">logger -it <span class="built_in">test</span> -p syslog.info <span class="string">"test4..."</span> <span class="comment"># `Dec  5 15:34:58 localhost test[23162]: test4...`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 基于日志级别自定义日志输出文件</span></span><br><span class="line"><span class="comment"># 修改日志配置文件。增加配置`local1.info /var/log/local1-info.log`</span></span><br><span class="line">vi /etc/rsyslog.conf</span><br><span class="line">systemctl restart rsyslog <span class="comment"># 重启使配置文件生效</span></span><br><span class="line">logger -it <span class="built_in">test</span> -p local1.info <span class="string">"test5..."</span> <span class="comment"># 此时在 /var/log/local1-info.log 中可看到 `Dec  5 15:34:58 localhost test[23162]: test5...`</span></span><br></pre></td></tr></table></figure><ul><li><code>/etc/rsyslog.conf</code> 配置说明<ul><li>会自动根据日志文件大小切割日志，生成 xxx-YYYYMMDD 的日志历史</li><li>修改日志文件后需要重启服务 <code>systemctl restart rsyslog</code> (重启后新配置生效会有一点延迟)</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### RULES ####</span></span><br><span class="line"><span class="comment"># 如果日志级别为 local1.info，则将日志输出到文件 /var/log/local1-info.log</span></span><br><span class="line">local1.info /var/<span class="built_in">log</span>/local1-info.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># ### begin forwarding rule ###</span></span><br><span class="line"><span class="comment"># 可配置同步日志到远程机器</span></span><br></pre></td></tr></table></figure><ul><li>记录命令执行历史到日志文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：此脚本无法记录清除日志的的命令`history -c`</span></span><br><span class="line"><span class="comment"># root用户执行</span></span><br><span class="line">su - root</span><br><span class="line"><span class="built_in">source</span> &lt;(curl -L https://raw.githubusercontent.com/oldinaction/scripts/master/shell/prod/conf-recode-cmd-history.sh)</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/local1-info.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志格式如下</span></span><br><span class="line">2019-01-01 07:55:42 localhost [pybiz_monitor][1594]: [pybiz_monitor.run_script][success]程序启动成功 <span class="comment"># python监控脚本日志</span></span><br><span class="line">2019-01-01 15:17:20 localhost cmd-hostory[root][14479]: [/root]  3001  2020-12-15 15:17:20 10.10.10.10 root <span class="built_in">cd</span> /home <span class="comment"># 执行命令日志</span></span><br></pre></td></tr></table></figure><h3 id="dd-磁盘读写测试"><a href="#dd-磁盘读写测试" class="headerlink" title="dd 磁盘读写测试"></a>dd 磁盘读写测试</h3><ul><li><p>磁盘性能</p><ul><li>固态硬盘，在SATA 2.0接口上平均读取速度在<code>225MB/S</code>，平均写入速度在<code>71MB/S</code>。在SATA 3.0接口上，平均读取速度骤然提升至<code>311MB/S</code></li></ul></li><li><p>用于复制文件并对原文件的内容进行转换和格式化处理</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 参数说明</span></span><br><span class="line"><span class="keyword">if</span>      <span class="comment"># 代表输入文件。如果不指定if，默认就会从stdin中读取输入</span></span><br><span class="line">of      <span class="comment"># 代表输出文件。如果不指定of，默认就会将stdout作为默认输出</span></span><br><span class="line">bs      <span class="comment"># 代表字节为单位的块大小，如64k</span></span><br><span class="line">count   <span class="comment"># 代表被复制的块数，如4k/4000</span></span><br><span class="line"><span class="comment"># 大多数文件系统的默认I/O操作都是缓存I/O，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。dd命令不指定oflag或conv参数时默认使用缓存I/O</span></span><br><span class="line">oflag=direct    <span class="comment"># 指定采用直接I/O操作。直接I/O的优点是通过减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，降低了对文件读取和写入时所带来的CPU的使用以及内存带宽的占用</span></span><br><span class="line">oflag=dsync     <span class="comment"># dd在执行时每次都会进行同步写入操作，可能是最慢的一种方式了，因为基本上没有用到写缓存(write cache)。每次读取64k后就要先把这64k写入磁盘(每次都同步)，然后再读取下面这64k，一共重复4k次(4000)。可能听到磁盘啪啪的响，比较伤磁盘</span></span><br><span class="line">oflag=syns      <span class="comment"># 与上者dsyns类似，但同时也对元数据（描述一个文件特征的系统数据，如访问权限、文件拥有者及文件数据块的分布信息等。）生效，dd在执行时每次都会进行数据和元数据的同步写入操作</span></span><br><span class="line">conv=fdatasync  <span class="comment"># dd命令执行到最后会执行一次"同步(sync)"操作，这时候得到的速度是读取这286M数据到内存并写入到磁盘上所需的时间</span></span><br><span class="line">conv=fsync      <span class="comment"># 与上者fdatasync类似，但同时元数据也一同写入</span></span><br><span class="line"></span><br><span class="line">/dev/null <span class="comment"># 伪设备，回收站，写该文件不会产生IO</span></span><br><span class="line">/dev/zero <span class="comment"># 伪设备，会产生空字符流，但不会产生IO</span></span><br></pre></td></tr></table></figure><ul><li><code>dd if=/dev/zero of=test bs=64k count=4k oflag=dsync</code> 在当前目录创建文件test，并每次以64k的大小往文件中读写数据，总共执行4000次，最终产生test文件大小为268M。以此测试磁盘操作速度</li><li>测试案例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dd if=/dev/zero of=test bs=64k count=4k oflag=dsync # 测试结果如下</span></span><br><span class="line">268435456 bytes (268 MB) copied, 26.3299 s, 10.2 MB/s               <span class="comment"># 本地 SSD 磁盘直接操作</span></span><br><span class="line">268435456 bytes (268 MB) copied, 261.475 s, 1.0 MB/s                <span class="comment"># 本地 HDD 磁盘直接操作</span></span><br><span class="line">268435456 bytes (268 MB) copied, 14.8903 s, 18.0 MB/s               <span class="comment"># 阿里云 SSD 磁盘直接操作</span></span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 1637.61 s, 164 kB/s       <span class="comment"># 本地ceph集群(1 ssd + 2 hdd)</span></span><br><span class="line">268435456 bytes (268 MB, 256 MiB) copied, 90.0906 s, 3.0 MB/s       <span class="comment"># 本地ceph集群(3 ssd)</span></span><br></pre></td></tr></table></figure><h3 id="sgdisk-磁盘操作工具"><a href="#sgdisk-磁盘操作工具" class="headerlink" title="sgdisk 磁盘操作工具"></a>sgdisk 磁盘操作工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install -y gdisk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有GPT分区</span></span><br><span class="line">sgdisk -p /dev/sdb</span><br><span class="line"><span class="comment"># 查看第一个分区</span></span><br><span class="line">sgdisk -i 1 /dev/sdb</span><br><span class="line"><span class="comment"># 创建了一个不指定大小、不指定分区号的分区</span></span><br><span class="line">sgdisk -n 0:0:0 /dev/sdb <span class="comment"># -n 分区号:起始地址:结束地址</span></span><br><span class="line"><span class="comment"># 创建分区1，从默认起始地址开始的10G的分区</span></span><br><span class="line">sgdisk -n 1:0:+10G /dev/sdb</span><br><span class="line"><span class="comment"># 将分区方案写入文件进行备份</span></span><br><span class="line">sgdisk --backup=/root/sdb.partitiontable /dev/sdb</span><br><span class="line"><span class="comment"># 删除第一分区</span></span><br><span class="line">sgdisk -d 1 /dev/sdb</span><br><span class="line"><span class="comment"># 删除所有分区(提示：GPT data structures destroyed!)</span></span><br><span class="line">sgdisk --zap-all --clear --mbrtogpt /dev/sdb</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li><p>帮助</p><ul><li><code>ls --help</code> 查看ls的命令说明</li><li><code>curl -h</code> 查看curl命令帮助</li><li><code>help ulimit</code> 查看ulimit命令帮助</li><li><code>info ls</code></li><li><p><code>man ls</code> 查看ls的详细命令说明</p><ul><li><code>yum install -y man man-pages</code></li><li><p>安装中文man手册</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/manpages-zh-1.5.2.tar.bz2/cab232c7bb49b214c2f7ee44f7f35900/manpages-zh-1.5.2.tar.bz2</span><br><span class="line"></span><br><span class="line">yum install bzip2</span><br><span class="line">tar jxvf  manpages-zh-1.5.2.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> manpages-zh-1.5.2</span><br><span class="line">sudo ./configure --<span class="built_in">disable</span>-zhtw <span class="comment">#默认安装 </span></span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="built_in">alias</span> cman=<span class="string">'man -M /usr/local/share/man/zh_CN'</span> <span class="comment"># 为了不抵消man，创建cman命令</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>系统</p><ul><li><code>date</code> 显示当前时间; <code>cal</code> 显示日历</li><li><code>history</code> 查看历史执行命令<ul><li>默认记录1000条命令，编号越大表示越近执行。用户所键入的命令都会记录在用户家目录下的<code>.bash_history</code>文件中<ul><li><code>!n</code> 再次执行此命令(n 是命令编号)</li><li><code>!$</code> 它用于指代上次键入的参数</li><li><code>!!</code> 可以指代上次键入的命令</li></ul></li><li><code>history -c</code> 清除历史。其他人登录也将看不到，历史中不会显示清除的命令</li></ul></li><li><code>last</code> 查看最近登录用户</li><li><code>w</code> 查看计算机运行时间，当前登录用户信息</li><li><code>wall &lt;msg&gt;</code> 通知所有人登录人一些信息</li></ul></li><li>程序<ul><li><code>sudo -H -u www bash -c &#39;nohup /home/web/start /home/web/conf.json &amp;&#39;</code> 调用www用户运行指定命令(其他用户或系统自动执行此命令)</li></ul></li><li>技巧<ul><li><code>clear</code> 清屏</li><li><code>yes y</code> 一直输出字符串y<ul><li><code>yes y | cp -i new old</code> <code>cp</code> 用文件覆盖就文件(<code>-i</code>存在old文件需进行提示，否则无需提示；<code>-f</code>始终不进行提示)，而此时前面会一致输出<code>y</code>，相当于自动输入了y进行确认cp操作</li></ul></li><li><code>\</code> 回车后可将命令分多行运行(后面不能带空格)</li></ul></li></ul><hr><p>参考文章</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> smalle</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.aezo.cn/2016/07/21/linux/linux/" title="linux系统">http://blog.aezo.cn/2016/07/21/linux/linux/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/linux/" rel="tag"># linux</a> <a href="/tags/shell/" rel="tag"># shell</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/07/17/lang/uml/" rel="next" title="UML"><i class="fa fa-chevron-left"></i> UML</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2016/08/14/arch/rabbitmq/" rel="prev" title="RabbitMQ">RabbitMQ<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400" alt="smalle"><p class="site-author-name" itemprop="name">smalle</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">162</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">144</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础操作"><span class="nav-number">1.1.</span> <span class="nav-text">基础操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务相关命令"><span class="nav-number">1.2.</span> <span class="nav-text">服务相关命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开机启动设置"><span class="nav-number">1.3.</span> <span class="nav-text">开机启动设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash使用"><span class="nav-number">1.4.</span> <span class="nav-text">bash使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shell脚本"><span class="nav-number">1.5.</span> <span class="nav-text">shell脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文本处理"><span class="nav-number">1.6.</span> <span class="nav-text">文本处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">2.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘"><span class="nav-number">2.1.</span> <span class="nav-text">磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">2.2.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件夹-目录"><span class="nav-number">2.3.</span> <span class="nav-text">文件夹/目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘分区和挂载"><span class="nav-number">2.4.</span> <span class="nav-text">磁盘分区和挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVM使用"><span class="nav-number">2.5.</span> <span class="nav-text">LVM使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压缩包-推荐tar-1"><span class="nav-number">2.6.</span> <span class="nav-text">压缩包(推荐tar) ^1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tar"><span class="nav-number">2.6.1.</span> <span class="nav-text">tar</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gz"><span class="nav-number">2.6.2.</span> <span class="nav-text">gz</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unzip"><span class="nav-number">2.6.3.</span> <span class="nav-text">unzip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rar"><span class="nav-number">2.6.4.</span> <span class="nav-text">rar</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件误删恢复"><span class="nav-number">2.7.</span> <span class="nav-text">文件误删恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vi-vim编辑器"><span class="nav-number">3.</span> <span class="nav-text">vi/vim编辑器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vi命令"><span class="nav-number">3.1.</span> <span class="nav-text">vi命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限系统"><span class="nav-number">4.</span> <span class="nav-text">权限系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户管理-6"><span class="nav-number">4.1.</span> <span class="nav-text">用户管理 ^6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件权限"><span class="nav-number">4.2.</span> <span class="nav-text">文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统资源权限"><span class="nav-number">4.3.</span> <span class="nav-text">系统资源权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ssh"><span class="nav-number">5.</span> <span class="nav-text">ssh</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ssh介绍-2"><span class="nav-number">5.1.</span> <span class="nav-text">ssh介绍 ^2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看SSH服务"><span class="nav-number">5.2.</span> <span class="nav-text">查看SSH服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSH客户端连接服务器（口令认证）"><span class="nav-number">5.3.</span> <span class="nav-text">SSH客户端连接服务器（口令认证）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSH客户端连接服务器（秘钥认证）"><span class="nav-number">5.4.</span> <span class="nav-text">SSH客户端连接服务器（秘钥认证）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#corn定时任务"><span class="nav-number">6.</span> <span class="nav-text">corn定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cron配置"><span class="nav-number">6.1.</span> <span class="nav-text">cron配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运维-amp-工具"><span class="nav-number">7.</span> <span class="nav-text">运维&amp;工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统信息查询"><span class="nav-number">7.1.</span> <span class="nav-text">系统信息查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看网络信息"><span class="nav-number">7.2.</span> <span class="nav-text">查看网络信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看进程信息"><span class="nav-number">7.3.</span> <span class="nav-text">查看进程信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#top命令"><span class="nav-number">7.3.1.</span> <span class="nav-text">top命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看IO信息-磁盘读写情况"><span class="nav-number">7.4.</span> <span class="nav-text">查看IO信息(磁盘读写情况)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统级IO监控"><span class="nav-number">7.4.1.</span> <span class="nav-text">系统级IO监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程级IO监控"><span class="nav-number">7.4.2.</span> <span class="nav-text">进程级IO监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#业务级IO监控"><span class="nav-number">7.4.3.</span> <span class="nav-text">业务级IO监控</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据恢复"><span class="nav-number">7.5.</span> <span class="nav-text">数据恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">7.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核"><span class="nav-number">8.</span> <span class="nav-text">内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sysctl"><span class="nav-number">8.1.</span> <span class="nav-text">sysctl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux基础"><span class="nav-number">9.</span> <span class="nav-text">Linux基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本"><span class="nav-number">9.1.</span> <span class="nav-text">基本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘-1"><span class="nav-number">9.2.</span> <span class="nav-text">磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关文件"><span class="nav-number">9.3.</span> <span class="nav-text">相关文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络"><span class="nav-number">9.4.</span> <span class="nav-text">网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xshell使用"><span class="nav-number">10.</span> <span class="nav-text">xshell使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux命令"><span class="nav-number">11.</span> <span class="nav-text">linux命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#grep-过滤器"><span class="nav-number">11.1.</span> <span class="nav-text">grep 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sed-行编辑器"><span class="nav-number">11.2.</span> <span class="nav-text">sed 行编辑器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#awk-文本分析工具"><span class="nav-number">11.3.</span> <span class="nav-text">awk 文本分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cut-文本剪切"><span class="nav-number">11.4.</span> <span class="nav-text">cut 文本剪切</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-文本排序"><span class="nav-number">11.5.</span> <span class="nav-text">sort 文本排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wc-文本统计"><span class="nav-number">11.6.</span> <span class="nav-text">wc 文本统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#date"><span class="nav-number">11.7.</span> <span class="nav-text">date</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-number">11.8.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sh"><span class="nav-number">11.9.</span> <span class="nav-text">sh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xrags"><span class="nav-number">11.10.</span> <span class="nav-text">xrags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logger"><span class="nav-number">11.11.</span> <span class="nav-text">logger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dd-磁盘读写测试"><span class="nav-number">11.12.</span> <span class="nav-text">dd 磁盘读写测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sgdisk-磁盘操作工具"><span class="nav-number">11.13.</span> <span class="nav-text">sgdisk 磁盘操作工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他命令"><span class="nav-number">11.14.</span> <span class="nav-text">其他命令</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">smalle</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class="powered-by"> 由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div></div><div class="ad"> <span style="font-weight:700">AD&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=oby5nolb">阿里云大礼包</a></div></div><div class="aezocn"> <span style="font-weight:700">&copy;AEZO.CN&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="powered-by"> <a target="_blank" href="https://shengqitech.aezo.cn/">圣骑科技</a></div><div class="powered-by"> <a target="_blank" href="https://cdn7.aezo.cn/common/qrcode/one_qrcode.jpg">【One能抽屉】小程序</a></div><div class="theme-info"> <a target="_blank" href="http://shop.aezo.cn/">杂货铺(省钱小助手)</a></div></div><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?085f9cd91ef2ad985f791c677472f0d1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script></body></html>