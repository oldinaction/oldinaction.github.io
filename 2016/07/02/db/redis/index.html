<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="redis,"><link rel="alternate" href="/atom.xml" title="月星墙的博客" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="Redis简介 redis.cn、官网：http://redis.io/、Redis Github、redis 在线测试 Redis 是一款开源的，基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统 由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被"><meta name="keywords" content="redis"><meta property="og:type" content="article"><meta property="og:title" content="redis"><meta property="og:url" content="http://blog.aezo.cn/2016/07/02/db/redis/index.html"><meta property="og:site_name" content="月星墙的博客"><meta property="og:description" content="Redis简介 redis.cn、官网：http://redis.io/、Redis Github、redis 在线测试 Redis 是一款开源的，基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统 由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/bio-nio-select-epoll.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-bit.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-list.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-预分区.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-sharding.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-proxy.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-proxy-vs.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-击穿-穿透-雪崩.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/db/redis-bloom.png"><meta property="og:updated_time" content="2025-04-16T14:20:08.102Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="redis"><meta name="twitter:description" content="Redis简介 redis.cn、官网：http://redis.io/、Redis Github、redis 在线测试 Redis 是一款开源的，基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统 由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被"><meta name="twitter:image" content="http://blog.aezo.cn/data/images/linux/bio-nio-select-epoll.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"BWD6R9FA4K",apiKey:"3330f3cbaa099dfc30395de5f5b20151",indexName:"blog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}}}</script><link rel="canonical" href="http://blog.aezo.cn/2016/07/02/db/redis/"><title>redis | 月星墙的博客</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?085f9cd91ef2ad985f791c677472f0d1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">月星墙的博客</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Better Code, Better Life</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2016/07/02/db/redis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="smalle"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="月星墙的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">redis</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-02T12:11:00+08:00">2016-07-02</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><ul><li><a href="http://redis.cn/" target="_blank" rel="noopener">redis.cn</a>、<a href="http://redis.io/" target="_blank" rel="noopener">官网：http://redis.io/</a>、<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis Github</a>、<a href="https://try.redis.io/" target="_blank" rel="noopener">redis 在线测试</a></li><li>Redis<ul><li>是一款开源的，基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统</li><li>由于 Redis 的键包括 <code>string</code>，<code>hash</code>，<code>list</code>，<code>set</code>，<code>sorted set</code>，<code>bitmap</code> 和 <code>hyperloglog</code>，所以常常被称为数据结构服务器</li><li>单实例，单进程、单线程(epoll)，占用资源少(单实例只使用1M内存)<ul><li>版本3.×（最早版本）为单线程</li><li>版本4.×，负责处理客户端请求的线程单线程，但是开始加了点多线程的东西（异步删除）</li><li>版本6.x 开始，全面支持多线程。将网络数据读写、请求协议解析通过多个IO线程来处理，真正执行命令的线程仍然是主线程单独进行操作</li></ul></li></ul></li><li><a href="/_posts/arch/分布式架构原理及选型方案.md#缓存">常见的缓存memcached、redis比较参考</a></li><li>redis windows客户端(64x，官网不提供window安装包)：<a href="https://github.com/MSOpenTech/redis" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis</a></li><li>redis客户端连接管理软件<ul><li>Navicat Premium 17支持redis</li><li>(推荐)<a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases/tag/v1.5.9" target="_blank" rel="noopener">AnotherRedisDesktopManager</a></li><li><a href="https://github.com/RedisInsight/RedisDesktopManager/releases/tag/0.9.3" target="_blank" rel="noopener">RedisDesktopManager</a></li></ul></li><li>java操作redis(客户端jar)<ul><li><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a></li><li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">jedis</a></li></ul></li><li>bio-nio-select-epoll，参考<a href="/_posts/linux/计算机底层知识.md#网络IO">网络IO</a></li></ul><p><img src="/data/images/linux/bio-nio-select-epoll.png" alt="bio-nio-select-epoll"></p><h2 id="安装Redis服务"><a href="#安装Redis服务" class="headerlink" title="安装Redis服务"></a>安装Redis服务</h2><ul><li>Windows<ul><li>方式一: 下载<a href="https://github.com/redis-windows/redis-windows/releases" target="_blank" rel="noopener">Redis-7.4.2-Windows-x64-cygwin-with-Service.zip</a><ul><li>执行<code>install_redis_service.bat</code>安装到服务；默认没有设置密码，可修改redis.conf设置requirepass参数</li></ul></li><li>方式二: 下载redis windows客户端（3.2.100）：<a href="https://github.com/MSOpenTech/redis" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis</a><ul><li>直接启动解压目录下的：<code>redis-server.exe</code>服务程序；<code>redis-cli.exe</code>客户端程序，即可在客户端使用命令行进行新增和查看数据（默认没有设置密码）</li></ul></li><li><strong>设置密码</strong><ul><li>修改<code>redis.windows.conf</code>，将<code># requirepass foobared</code> 改成 <code>requirepass your_password</code>(行前不能有空格)</li><li>cmd进入到redis解压目录，运行<code>redis-server redis.windows.conf</code>，之后登录则需要密码</li></ul></li></ul></li><li>Linux</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 简单的可直接安装</span></span><br><span class="line">yum install redis -y</span><br><span class="line"><span class="comment"># 配置文件 /etc/redis.conf，如果需要密码，需先修改配置文件后启动</span></span><br><span class="line">systemctl restart redis &amp;&amp; systemctl <span class="built_in">enable</span> redis &amp;&amp; systemctl status redis</span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载源码(或手动下载后上传)</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.8.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.8</span><br><span class="line"><span class="comment"># 可查看README.md进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 编译及安装</span></span><br><span class="line"><span class="comment"># 编译测试(可能会提示：Redis need tcl 8.5 or newer。解决办法：yum install tcl。其他问题参考：http://blog.csdn.net/for_tech/article/details/51880647)</span></span><br><span class="line"><span class="comment"># 编译测试不通过也可正常运行</span></span><br><span class="line">make <span class="built_in">test</span> <span class="comment"># 可选，make需要有gcc(yum -y install gcc)</span></span><br><span class="line">make install <span class="comment"># 在源码目录安装(建议如下文安装到特定目录)</span></span><br><span class="line"><span class="comment"># make distclean # 安装失败可进行清除</span></span><br><span class="line"><span class="comment"># 编译成功后，可直接在源码目录运行命令(一般为临时测试)：启动 `src/redis-server`，客户端连接 `src/redis-cli`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装到特定目录</span></span><br><span class="line">make PREFIX=/opt/soft/reds5 install</span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 增加以下两行</span></span><br><span class="line"><span class="comment">#export REDIS_HOME=/opt/soft/redis5</span></span><br><span class="line"><span class="comment">#export PATH=$PATH:$REDIS_HOME/bin</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">redis-server <span class="comment"># 即可启动服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装成服务</span></span><br><span class="line"><span class="comment"># 一个物理机中可以有多个redis实例(进程)，通过port区分</span></span><br><span class="line"><span class="comment"># 可执行程序就一份在目录，但是内存中未来的多个实例需要各自的配置文件，持久化目录等资源</span></span><br><span class="line">./utils/install_server.sh <span class="comment"># 默认即可。多次运行安装多节点时可输入不同的端口</span></span><br><span class="line"><span class="comment"># 安装成功后会自动启动(自启动脚本在/etc/init.d目录)并设置为开机启动，查看服务状态。像创建Redis Cluster仍然需要源码中的脚本</span></span><br><span class="line">service redis_6379 status</span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line">redis-cli <span class="comment"># 启动客户端</span></span><br><span class="line">127.0.0.1:6379&gt; ping <span class="comment"># PONG</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> foo bar <span class="comment"># 设置</span></span><br><span class="line">127.0.0.1:6379&gt; get foo <span class="comment"># bar, 取值</span></span><br></pre></td></tr></table></figure><ul><li>Mac<ul><li>安装 <code>brew install redis</code></li><li>启动 <code>brew services start redis</code></li><li>配置文件路径如<code>/opt/homebrew/etc/redis.conf</code></li></ul></li><li>解决服务器Redis无法连接问题(内网)：<a href="https://blog.csdn.net/qq_57408330/article/details/129681386" target="_blank" rel="noopener">https://blog.csdn.net/qq_57408330/article/details/129681386</a></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果设置为yes，那么只允许我们在本机的回环连接，其他机器无法连接</span></span><br><span class="line"><span class="comment"># protected-mode设置为yes的情况下，为了我们的应用服务可以正常访问Redis，我们需要设置Redis的bind参数或者密码参数requirepass</span></span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure><h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><ul><li><a href="#string">string</a><ul><li>字符类型</li><li>数值类型计算</li><li>bitmap位图</li></ul></li><li><a href="#list">list</a><ul><li>栈(同向操作)</li><li>队列(反向操作)</li><li>数组</li><li>阻塞，单播队列(FIFO)</li></ul></li><li><a href="#hash">hash</a></li><li><a href="#set">set</a><ul><li>无序去重集合</li><li>随机事件，如可用于抽奖</li></ul></li><li><a href="#sorted_set">sorted set</a></li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="comment"># 启动客户端</span></span><br><span class="line">redis-cli -h <span class="comment"># 进入命令行，也可输入help + 空格 +Tab获取帮助，如`help @set`</span></span><br><span class="line">redis-cli -p 6379 -n 1 -a &lt;password&gt; <span class="comment"># 连接6379的第一个数据库(默认从0开始，总共有16个库)</span></span><br><span class="line"><span class="comment"># redis是二进制安全的</span></span><br><span class="line"><span class="comment"># 如果客户端以不同的编码(如GBK/UTF-8)连接；当GBK连接时存储"中"，则占用2个字节，如果UTF-8连接时，则占用3个字节</span></span><br><span class="line"><span class="comment"># 实际存储是按照二进制存储的，如果不加--raw默认以16进制显示(只能显示ASCII码)，加了--raw会按照此时的客户端连接编码进行解码显示出"中"</span></span><br><span class="line">redis-cli --raw</span><br><span class="line">redis-cli --pipe <span class="comment"># cat pipe.txt | redis-cli --pipe # 通过文件批量发送命令，pipe.txt中每一行一个命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## redis-cli命令行，命令不区分大小写</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 退出redis-cli命令行</span></span><br><span class="line"><span class="built_in">help</span> @string <span class="comment"># 查看string类型的相关操作</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">set</span> <span class="comment"># 查看set命令：group为string则说明set操作的是字符串</span></span><br><span class="line">info <span class="comment"># 查看服务器信息</span></span><br><span class="line">info Replication <span class="comment"># 查看服务器主从复制相关信息</span></span><br><span class="line"></span><br><span class="line">select 2 <span class="comment"># 选择2号数据库</span></span><br><span class="line">flushdb <span class="comment"># 清空整个库(删除全部数据)，生产环境一般改写此命令</span></span><br><span class="line">keys * <span class="comment"># 查看所有key，生产环境一般改写此命令</span></span><br><span class="line">keys key* <span class="comment"># 查看所有key开头的key</span></span><br><span class="line">del key1 <span class="comment"># 删除某个key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key1 <span class="comment"># 查看key1值的类型</span></span><br><span class="line">object encoding key1 <span class="comment"># 查看key1编码类型，如返回int说明此字符串可以进行计算</span></span><br></pre></td></tr></table></figure><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name smalle</span><br><span class="line">get name <span class="comment"># 返回 smalle</span></span><br><span class="line">getset &lt;key&gt; &lt;value&gt; <span class="comment"># 设置key的值并返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于命名空间(namespace)定义key名(可视化可分目录展示成app1/module1/name)</span></span><br><span class="line"><span class="built_in">set</span> app1:module1:name smalle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line">mset k1 123 k2 v2</span><br><span class="line">mget k1 k2 <span class="comment"># 返回123、v2两行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加</span></span><br><span class="line">append name <span class="string">", hi"</span> <span class="comment"># smalle, hi</span></span><br><span class="line"><span class="comment"># 获取索引8-9(左右都包含)之间的值</span></span><br><span class="line">getrange name 8 9 <span class="comment"># hi</span></span><br><span class="line"><span class="comment"># redis包含正负向索引，正向从左到右从0递增，负向从右到左从-1递减</span></span><br><span class="line">getrange name 8 -1 <span class="comment"># hi</span></span><br><span class="line"><span class="comment"># 插入，smalle, hello</span></span><br><span class="line">setrange name 8 hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看字符串字节长度</span></span><br><span class="line">strlen name <span class="comment"># 13</span></span><br><span class="line"><span class="built_in">type</span> k1 <span class="comment"># string，k2也是</span></span><br><span class="line">object encoding k1 <span class="comment"># int，k2返回embstr。key实际是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据值加1</span></span><br><span class="line">incr k1 <span class="comment"># 124，此时k2不能计算</span></span><br><span class="line"><span class="comment"># 对数据减去指定值</span></span><br><span class="line">decrby k1 2 <span class="comment"># 122</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nx表示如果不存在name这个key才允许创建。可用于分布式锁</span></span><br><span class="line"><span class="built_in">set</span> name hello nx</span><br><span class="line"><span class="comment"># m批量，nx不存在key才设置。此时会设置失败(但不会报错)，可用于原子性赋值操作</span></span><br><span class="line">msetnx k1 100 k3 abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于二进制设置字符串，参考下文二进制图</span></span><br><span class="line">setbit b1 1 1 <span class="comment"># 设置b1的第1位(下标1/索引1，对应二进制位)值为1 =&gt; 01000000 =&gt; `get b1`得到字符值为@(可通过`man ascii`查看字符集) =&gt; `strlen b1`得到字节长度为1</span></span><br><span class="line">setbit b1 7 1 <span class="comment"># 基于之前的值设置 =&gt; 01000010(设置第7个二进制位为1) =&gt; 字符值为A =&gt; 字节长度为1</span></span><br><span class="line">setbit b1 9 1 <span class="comment"># 基于之前的值设置 =&gt; 01000010 01000000(中间实际没有空格，设置第9个二进制位为1) =&gt; 字符值为A@ =&gt; 字节长度为2</span></span><br><span class="line"><span class="comment"># 从b1中的第0个字节到第1个字节查找第一个1的下标</span></span><br><span class="line">bitpos b1 1 0 1 <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 统计b1中第**0到1字节(前16位)**出现1的次数</span></span><br><span class="line">bitcount b1 0 1 <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 统计b1中第**0到-1(倒数第二位)字节(即除掉倒数第一个字节)**出现1的次数</span></span><br><span class="line">bitcount b1 0 -1 <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置b2下标1的二进制位为1，最终得到b2=A(01000001)，b3=B(01000010)</span></span><br><span class="line">setbit b2 1 1</span><br><span class="line">setbit b2 7 1</span><br><span class="line">setbit b3 1 1</span><br><span class="line">setbit b3 6 1</span><br><span class="line"><span class="comment"># 按位与操作，并将结果赋值给andkey1：有0则0，全1为1 =&gt; 且</span></span><br><span class="line">bitop and andkey1 b2 b3 <span class="comment"># andkey1=@ (01000000)</span></span><br><span class="line"><span class="comment"># 按位或操作：有1则1，全0为0 =&gt; 或</span></span><br><span class="line">bitop or orkey1 b2 b3 <span class="comment"># C(01000011)</span></span><br></pre></td></tr></table></figure><ul><li>setbit二进制图</li></ul><p><img src="/data/images/db/redis-bit.png" alt="redis-bit"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li>首字母L/R代表left/right，L有时候可能指list，B代表blocking</li><li>list结构</li></ul><p><img src="/data/images/db/redis-list.png" alt="redis-list"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @list</span><br><span class="line"><span class="comment"># 向左边插入数据(重复执行会重复往此key中追加)，最终为：c b a</span></span><br><span class="line">lpush k1 a b c</span><br><span class="line"><span class="comment"># 向右边插入数据，最终为：a b c</span></span><br><span class="line">rpush k2 a b c</span><br><span class="line"><span class="comment"># 获取list的从0到-1(最后一个)的数据</span></span><br><span class="line">lrange k1 0 -1 <span class="comment"># 返回 c b a 三行</span></span><br><span class="line"><span class="comment"># 弹出左边的元素(会从数组中删除这个元素) =&gt; FILO =&gt; lpush + lpop(同向操作)相当于栈</span></span><br><span class="line">lpop k1 <span class="comment"># 返回c，此时k1=[b, a]</span></span><br><span class="line"><span class="comment"># 弹出右边元素 =&gt; FIFO =&gt; lpush + rpop(反向操作)相当于队列</span></span><br><span class="line">rpop k1 <span class="comment"># 返回a，此时k1=[b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取k2的下标为2的元素 =&gt; 相当于数组</span></span><br><span class="line">lindex k2 2 <span class="comment"># c</span></span><br><span class="line"><span class="comment"># 设置k2下标2的值为d，k2=[a,b,b]</span></span><br><span class="line">lset k2 2 b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在k2的第一个b元素后面(before/after)插入1，k2=[a,b,1,b]</span></span><br><span class="line">linsert k2 after b 1</span><br><span class="line">rpush k3 1 a a 2 a 2 2 <span class="comment"># k3=[1,a,a,2,a,2,2]</span></span><br><span class="line"><span class="comment"># 从左边开始移除(count=2的值为正数则从左边开始移除)2个a元素，k3=[1,2,a,2,2]</span></span><br><span class="line">lrem k3 2 a</span><br><span class="line"><span class="comment"># 从右边（负号）开始移除1个"2"元素，k3=[1,2,a,2]</span></span><br><span class="line">lrem k3 -1 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回list长度</span></span><br><span class="line">llen k2 <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果kn1对应的list存在，则向左边插入值。此时不存在</span></span><br><span class="line">lpushx kn1 1 <span class="comment"># (integer) 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左边弹出k4，如果k4没有则等待一定超时时间，0表示一直阻塞直到k4有值；如果有多个客户端阻塞弹出k4的值，则谁先阻塞谁先弹出，且一次只能弹出1个(放掉一个客户端) =&gt; 阻塞，单播队列，FIFO</span></span><br><span class="line">blpop k4 0</span><br></pre></td></tr></table></figure><h3 id="hash-map"><a href="#hash-map" class="headerlink" title="hash(map)"></a>hash(map)</h3><ul><li>命令字母H开头表示hash</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @<span class="built_in">hash</span></span><br><span class="line"><span class="comment"># 设置h1这个hash为 &#123;name: test&#125;</span></span><br><span class="line">hset h1 name <span class="built_in">test</span></span><br><span class="line">hset h1 age 18</span><br><span class="line">hget h1 age <span class="comment"># 18</span></span><br><span class="line"></span><br><span class="line">hmget h1 name age <span class="comment"># 返回test、18两行</span></span><br><span class="line">hkeys h1 <span class="comment"># 返回name、age两行</span></span><br><span class="line">hgetall h1 <span class="comment"># 返回name、test、age、18四行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对属性age增加0.5（负数则表示减少）</span></span><br><span class="line">hincrbyfloat h1 age 0.5 <span class="comment"># 18.5</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @<span class="built_in">set</span></span><br><span class="line"><span class="comment"># 插入后无序，可能为k1=[c,b,d,a,e]</span></span><br><span class="line">sadd k1 a b c d e a</span><br><span class="line"><span class="comment"># 获取集合(多次获取顺序一样)，返回c、b、d、a、e五行</span></span><br><span class="line">smembers k1</span><br><span class="line"><span class="comment"># 返回集合元素个数</span></span><br><span class="line">scard k1 <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 移除元素b、c(修改后顺序可能变化)，移除后k1=[a,e,d]</span></span><br><span class="line">srem k1 b c</span><br><span class="line">sadd k2 d e f</span><br><span class="line"><span class="comment"># 获取交集（intersection），直接返回e、d两行</span></span><br><span class="line">sinter k1 k2</span><br><span class="line"><span class="comment"># 获取交集，将结果放到destkey中</span></span><br><span class="line">sinterstore destkey k1 k2</span><br><span class="line"><span class="comment"># 获取并集，直接返回e、a、f、d</span></span><br><span class="line">sunion k1 k2 </span><br><span class="line"><span class="comment"># 取差集(k1是被减数)，直接返回a</span></span><br><span class="line">sdiff k1 k2</span><br><span class="line"><span class="comment"># 取差集，直接返回f</span></span><br><span class="line">sdiff k2 k1</span><br><span class="line"><span class="comment"># 随机获取5个值，由于是正数，因此返回结果不会重复，但是结果数可能小于期望数</span></span><br><span class="line">srandmember k1 5</span><br><span class="line"><span class="comment"># 随机获取5个值，由于是负数，因此结果可能会重复，结果数等于期望数</span></span><br><span class="line">srandmember k1 -5</span><br><span class="line"><span class="comment"># 弹出一个值并返回(会移除此元素)</span></span><br><span class="line">spop k1</span><br></pre></td></tr></table></figure><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted_set"></a>sorted_set</h3><ul><li>Z开头命令表示sorted set，REV表示取反（reversal）</li><li>排序器实现原理：<a href="/_posts/linux/algorithms.md#跳跃表(skip-list">skip list(跳跃表)</a>)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> @sorted_set</span><br><span class="line"><span class="comment"># 基于分值(会基于分值从小到大排序)添加元素，物理内存左小右大</span></span><br><span class="line">zadd k1 5 apple 2 banana 7 orange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素：banana,apple,orange</span></span><br><span class="line">zrange k1 0 -1</span><br><span class="line"><span class="comment"># 获取元素和分值：banana,2,apple,5,orange,7</span></span><br><span class="line">zrange k1 0 -1 withscores</span><br><span class="line"><span class="comment"># 取出分值4-7的元素：apple、orange</span></span><br><span class="line">zrangebyscore k1 4 7</span><br><span class="line"><span class="comment"># rev取反：orange、apple</span></span><br><span class="line">zrevrange k1 0 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取分数：5</span></span><br><span class="line">zscore k1 apple</span><br><span class="line"><span class="comment"># 获取元素apple在集合中的下标：1</span></span><br><span class="line">zrank k1 apple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对banana的分值加4.5 =&gt; 之后k1排序结果为：apple,5,banana,6.5,orange,7</span></span><br><span class="line">zincrby k1 4.5 banana</span><br><span class="line"></span><br><span class="line">zadd k2 3 apple 1 pear <span class="comment"># k2为：pear,1,apple,3</span></span><br><span class="line"><span class="comment"># 取并集(会合计分值)，`zrange destkey1 0 -1` =&gt; pear,1,banana,6.5,orange,7,apple,8</span></span><br><span class="line">zunionstore destkey1 2 k1 k2</span><br><span class="line"><span class="comment"># 基于权重(k1的权重为0.5，则k1的分值*0.5的权重后再去做加法)取并集 =&gt; pear,1,banana,3.25,orange3.5,apple,5.5</span></span><br><span class="line">zunionstore destkey2 2 k1 k2 weights 0.5 1</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><code>incr</code> 可用于统计不要求太精准的字段，如点赞数、评论数、抢购、秒杀等。从而规避并发下对数据库的事物操作，完全由redis内存操作代替</li><li><code>set my_lock id_12345678 nx ex 60</code> 实现<strong>分布式锁</strong>(nx不存在才能创建进行加锁，ex过期时间是60s防止死锁)，参考下文<a href="#实现分布式锁">实现分布式锁</a>。其中nx表示如果不存在此key时才允许创建</li><li><code>msetnx</code>命令：nx如上，m表示set多个key，此时要么都成功要么都失败。可用于字符串类型的<strong>原子性赋值操作</strong></li><li><p><code>setbit</code>位图命令使用。参考上文setbit相关案例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 记录每个用户一年365天是否登录过 =&gt; 46字节*1000w ~= 460M =&gt; 相比存储空间小且速度快</span></span><br><span class="line">setbit smalle 0 1</span><br><span class="line">setbit smalle 7 1</span><br><span class="line">setbit smalle 364 1</span><br><span class="line">strlen smalle <span class="comment"># 46，只需46个字节即可保存一个人一年的登录状态</span></span><br><span class="line">bitcount smalle -7 -1 <span class="comment"># 1，获取用户最近一周的登录次数；bitcount统计smalle中-7到-1字节(最后7个字节)出现1的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 统计一段时间的活跃用户数。假设A用户使用第1号位，B用户使用第7号位，且A用户在1-1(0101)、1-2(0102)号登录了，B用户只在1-2登录</span></span><br><span class="line">setbit 0101 1 1</span><br><span class="line">setbit 0102 1 1</span><br><span class="line">setbit 0102 7 1</span><br><span class="line">bitop or destkey 0101 0102 <span class="comment"># 按位或操作，并将结果赋值给destkey</span></span><br><span class="line">bitcount destkey 0 -1 <span class="comment"># 2 =&gt; 这两天的活跃用户数为2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端A往p1通道里面发送消息</span></span><br><span class="line">publish p1 hello</span><br><span class="line"><span class="comment"># 客户端B监听在通道p1上(可监听多个)，会阻塞客户端；由于在A发送消息之后监听，因此默认无法收到之前的消息</span></span><br><span class="line">subscribe p1 <span class="comment"># 执行后打印3行：1) "subscribe"、2) "p1"、3) (integer) 1</span></span><br><span class="line">publish p1 hi <span class="comment"># 客户端A再次发送消息，客户端B收到消息：1) "message"、2) "p1"、3) "hi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于正则(通道名)监听消息，可写多个正则。此时*表示监听所有通道消息</span></span><br><span class="line">psubscribe * <span class="comment"># 收到消息时打印如：1) "pmessage"、2) "*"、3) "p2"、4) "hi"</span></span><br></pre></td></tr></table></figure><h3 id="pipeline管道"><a href="#pipeline管道" class="headerlink" title="pipeline管道"></a>pipeline管道</h3><ul><li>在管道中可一次性发送多条命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nc连接服务器，然后直接发数据回车即可获得返回</span></span><br><span class="line"><span class="comment"># -e支持换行符，一次性发送多条命令</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"set k1 1\nkeys *\nincr k1"</span> | nc 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过文件批量发送命令，pipe.txt中每一行一个命令</span></span><br><span class="line">cat pipe.txt | redis-cli --pipe</span><br></pre></td></tr></table></figure><h3 id="transactions事物"><a href="#transactions事物" class="headerlink" title="transactions事物"></a>transactions事物</h3><ul><li>注意redis是单线程的，因此是按照时间先后顺序响应客户端命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 相关命令</span></span><br><span class="line">multi <span class="comment"># 开启一个事务，它总是返回 OK</span></span><br><span class="line"><span class="built_in">exec</span> <span class="comment"># 提交事务。将每条命令的结果放在数组中返回</span></span><br><span class="line">discard <span class="comment"># 放弃事务。事务队列会被清空，并且客户端会从事务状态中退出</span></span><br><span class="line"><span class="comment"># 观测某个key(必须在multi之前)，可以为 Redis 事务提供 check-and-set（CAS）行为</span></span><br><span class="line"><span class="comment"># 如果开启事务前和提交事务前的值一致则事务提交成功(观测的客户端修改此值，事务可正常提交；其他客户端修改此值事务提交失败)；</span></span><br><span class="line"><span class="comment"># 否则事务执行失败，返回(nil)，不报错</span></span><br><span class="line">watch</span><br><span class="line">unwatch <span class="comment"># 去掉所有观测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 案例1</span></span><br><span class="line"><span class="comment"># 客户端1执行</span></span><br><span class="line">multi</span><br><span class="line"><span class="built_in">set</span> k1 hello <span class="comment"># 返回QUEUED</span></span><br><span class="line">keys * <span class="comment"># 返回QUEUED</span></span><br><span class="line"><span class="comment"># 客户端2执行</span></span><br><span class="line">multi</span><br><span class="line">get k1</span><br><span class="line"><span class="comment"># 客户端2执行，返回：1) (nil)</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="comment"># 客户端1执行，返回：1) OK、2) 1) "k1"</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="comment"># 如果客户端1先执行exec提交事务，客户端2后提交事务，则客户端2执行exec是返回：1) "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 案例2</span></span><br><span class="line"><span class="comment"># 客户端1执行</span></span><br><span class="line"><span class="built_in">set</span> k1 hello</span><br><span class="line">watch k1</span><br><span class="line">multi</span><br><span class="line">get k1</span><br><span class="line"><span class="comment"># 客户端2执行</span></span><br><span class="line">multi</span><br><span class="line"><span class="built_in">set</span> k1 world</span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="comment"># 客户端1执行，此时返回：(nil)。由于观测的值以及发生了变化</span></span><br><span class="line"><span class="built_in">exec</span></span><br></pre></td></tr></table></figure><h3 id="数据有效期-作为缓存"><a href="#数据有效期-作为缓存" class="headerlink" title="数据有效期(作为缓存)"></a>数据有效期(作为缓存)</h3><ul><li>redis作为缓存数据不重要、不是全量数据，缓存应该随着访问变化(保存热数据，内存是有限的)</li></ul><h4 id="key的有效期"><a href="#key的有效期" class="headerlink" title="key的有效期"></a>key的有效期</h4><ul><li>通常Redis keys创建时没有设置相关过期时间，他们会一直存在，除非使用显示的命令移除，例如使用DEL命令</li><li><code>expire</code> 倒计时，当key执行过期操作时，Redis会确保按照规定时间删除他们(尽管中途使用过，过期时间也不会自动改变)。从 Redis 2.6 起，过期时间误差缩小到0-1毫秒</li><li><code>expireat</code> 设定再某个时间点失效</li><li><code>pexpire</code> 基于正则的倒计时</li><li><code>pexpireat</code></li><li>过期判定原理：<strong>被动访问判定、主动轮询判定</strong><ul><li>被动访问判定：当访问某个key时判断其是否过期，过期则先执行移除</li><li>主动轮询判定为增量<ul><li>默认每秒进行10次扫描，每次随机取20个key判断，超过25%过期，则再取20个判断，并且默认的每次扫描时间上限不会超过25ms</li><li>目的：redis是单线程，此时稍微牺牲下内存(延时过期)，但是保住了redis性能为王</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## expire和expireat</span></span><br><span class="line"><span class="built_in">set</span> k1 <span class="string">"hello"</span></span><br><span class="line"><span class="comment"># 设置k1在10s之后过期(删除此key，设置为负值则相当于认为已经过期)。尽管中途使用过，初始过期时间也不会自动改变(且实际过期时间会随着时间流逝而减少)</span></span><br><span class="line">expire k1 10</span><br><span class="line"><span class="comment"># 查看k1剩余有效期，-2表示此key已经不存在，-1表示此key永远不会过期</span></span><br><span class="line">ttl k1 <span class="comment"># (integer) 5、(integer) -2等</span></span><br><span class="line"><span class="built_in">set</span> k1 world</span><br><span class="line">ttl k1 <span class="comment"># (integer) -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间戳：1) "1594293836"、2) "713339"</span></span><br><span class="line">time</span><br><span class="line"><span class="built_in">set</span> k2 hello</span><br><span class="line">expireat k1 1594294836</span><br><span class="line">ttl k2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 注意事项</span></span><br><span class="line"><span class="comment"># 1.设值并设置过期时间为300s</span></span><br><span class="line"><span class="built_in">set</span> k3 hello ex 300</span><br><span class="line"><span class="comment"># 2.set/getset会丢失过期时间；incr/lpush/hset不会丢失过期时间</span></span><br><span class="line"><span class="built_in">set</span> k3 hi <span class="comment"># 过期时间会丢失</span></span><br><span class="line"><span class="comment"># 3.持久化一个key，会清除过期时间</span></span><br><span class="line">persist k3</span><br><span class="line"><span class="comment"># 4.重命名key，过期时间会转到新key上</span></span><br><span class="line">rename k2 k2_new</span><br></pre></td></tr></table></figure><h4 id="回收策略配置-数据淘汰机制"><a href="#回收策略配置-数据淘汰机制" class="headerlink" title="回收策略配置/数据淘汰机制"></a>回收策略配置/数据淘汰机制</h4><ul><li>回收策略不同于上文过期策略，二者有一定的区别</li><li><a href="http://redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">将redis当做使用LRU算法的缓存来使用</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑支持的最大内存(maxmemory)和回收策略</span></span><br><span class="line">vi /etc/redis/6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt; # 配置Redis存储数据时指定限制的内存大小，比如100m。**当缓存消耗的内存超过这个数值时, 将触发数据淘汰**。该数据配置为0时，表示缓存的数据量没有限制, 即LRU功能不生效。64位的系统默认值为0，32位的系统默认内存限制为3GB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="comment"># is reached. You can select among five behaviors:</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.   # 回收最久使用的键，但仅对设置了过期时间的键</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; Evict any key using approximated LRU.                              # 回收最久使用的键</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.   # 回收最少使用的键，但仅对设置了过期时间的键</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.                              # 回收最少使用的键</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; Remove a random key among the ones with an expire set.         # 随机回收建，但仅对设置了过期时间的键</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; Remove a random key, any key.                                   # 随机回收建</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)           # 回收生存时间TTL(Time To Live)更小的键（即将过期），但仅对设置了过期时间的键</span></span><br><span class="line"><span class="comment"># noeviction -&gt; Don't evict anything, just return an error on write operations.     # 当客户端需要使用更多内存，且内存不足时返回错误</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU means Least Recently Used # 最近使用的</span></span><br><span class="line"><span class="comment"># LFU means Least Frequently Used # 最频繁使用的</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br></pre></td></tr></table></figure><h3 id="持久化-数据库"><a href="#持久化-数据库" class="headerlink" title="持久化(数据库)"></a>持久化(数据库)</h3><ul><li>redis持久化主要有：RDB、AOF、<strong>AOF&amp;RDB</strong>(默认)</li><li>redis作为数据库，数据不能丢失，即需要做持久化，一般使用AOF(最好结合RDB)；如果作为缓存使用RDB就行，数据丢失可再从数据库获取</li></ul><h4 id="RDB方式持久化"><a href="#RDB方式持久化" class="headerlink" title="RDB方式持久化"></a>RDB方式持久化</h4><ul><li>调用bgsave命令时，使用<code>fork()</code>进程时的<code>copy-on-write</code>写时复制机制来实现。具体参考<a href="/_posts/linux/计算机底层知识.md#Copy-On-Write写时复制">Copy-On-Write写时复制</a></li><li>RDB特点<ul><li>优点：恢复速度相对快</li><li>不支持拉链，只有一个dump.rdb文件(为二进制编码，但是以REDIS开头)</li><li>丢失数据相对多一些，两次持久化之间的数据容易丢失</li></ul></li><li>rdb配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment"># save "" # 关闭写磁盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下条件将会被触发自动保存 =&gt; 创建子进程进行数据持久化</span></span><br><span class="line">save 900 1 <span class="comment"># 当900s(15m)后有1个及以上key发生了改变则会触发save</span></span><br><span class="line">save 300 10 <span class="comment"># 当300s(5m)后有10个及以上key发生了改变则会触发save</span></span><br><span class="line">save 60 10000 <span class="comment"># 当60s(1m)...</span></span><br><span class="line"><span class="comment"># 如900后有1个key发送改变时的日志如下</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:49:17.306 * 1 changes in 900 seconds. Saving...</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:49:17.307 * Background saving started by pid 7582           # 开启（fork）新进程保存数据到磁盘</span></span><br><span class="line"><span class="comment"># 7582:C 11 Jul 2020 15:49:17.514 * DB saved on disk                                # 数据已经保存到磁盘上</span></span><br><span class="line"><span class="comment"># 7582:C 11 Jul 2020 15:49:17.515 * RDB: 4 MB of memory used by copy-on-write       # 4M 内存数据使用copy-on-write的方式被使用</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:49:17.551 * Background saving terminated with success       # 保存成功, 进程中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据持久化的文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 数据保存的文件目录</span></span><br><span class="line">dir /var/lib/redis/6379</span><br></pre></td></tr></table></figure><ul><li>执行备份导出及导入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 连接待导出的redis成功后. 查看目录，如: /var/lib/redis</span></span><br><span class="line">config get dir</span><br><span class="line"><span class="comment"># redis命令行执行`save`(会占用主进程)或`bgsave`(后台运行)生成dump文件</span></span><br><span class="line">bgsave</span><br><span class="line"><span class="comment"># 备份完成后，进入到对应目录下载文件 /var/lib/redis/dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 连接待导入的redis成功后. 查看配置目录，备份当前redis的dump.rdb，并停止redis</span></span><br><span class="line"><span class="comment"># 覆盖导出的dump.rdb到当前redis目录</span></span><br><span class="line"><span class="comment"># 重启redis即可</span></span><br></pre></td></tr></table></figure><h4 id="AOF方式持久化"><a href="#AOF方式持久化" class="headerlink" title="AOF方式持久化"></a>AOF方式持久化</h4><ul><li><code>AOF</code>(Append Only Mode) Redis的写操作记录到文件中。默认是关闭的，可通过配置文件<code>appendonly yes</code>开启</li><li>特点<ul><li>丢失数据少</li><li>弊端：体量大、恢复慢。减少日志量的方法如下可通过重写实现</li></ul></li><li>AOF重写<ul><li>手动重写命令rewriteaof和bgrewriteaof</li><li>aof自动重写条件参考下文配置文件</li><li>重写时先fork一个子进程并创建aof临时文件，然后将数据库中的数据通过命令保存到aof临时文件(如果开启了AOF&amp;RDB混合使用，则将数据通过RDB的方式保存到AOF临时文件中)，最后用临时文件覆盖掉原AOF文件</li></ul></li><li>推荐使用<strong>AOF&amp;RDB混合使用</strong></li><li>redis当做内存数据库，写操作会触发IO，相关配置如</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"><span class="comment"># 默认是关闭AOF，开启设置成yes</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># 记录日志的文件</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行flush的时机</span></span><br><span class="line"><span class="comment"># appendfsync always # 每个写指令都进行flush</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒调用flush</span></span><br><span class="line"><span class="comment"># appendfsync no # redis不控制flush，交由OS控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof自动重写，也可调用bgrewriteaof手动重写。AOF重写不会读取老的AOF文件，而是根据当前服务器的状态生成一份新的AOF文件，将老的AOF文件进行替换</span></span><br><span class="line"><span class="comment"># aof文件增长比例，指当前aof文件比上次重写的增长比例大小为100%时触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># aof文件重写最小的文件大小，即最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小)</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启RDB和AOF混合使用(v4.0才有，重写前先将老的数据RDB到AOF文件中)</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><ul><li>aof文件说明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示是RDB和AOF混合使用</span></span><br><span class="line"><span class="comment">#REDIS...</span></span><br><span class="line"><span class="comment"># *代表需要读取的记录行，此时读取两个：select 0</span></span><br><span class="line">*2</span><br><span class="line"><span class="comment"># $表示读取的字节</span></span><br><span class="line"><span class="variable">$6</span></span><br><span class="line"><span class="comment"># 为实际的命令组成</span></span><br><span class="line">select</span><br><span class="line"><span class="variable">$1</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h3><ul><li>redis单机(单节点、单实例)问题<ul><li>单点故障</li><li>容量有限</li><li>压力太大</li></ul></li><li>AKF拆分原则<ul><li>X轴：表示主备，全量备份</li><li>Y轴：基于业务模块进行细分，可再结合X周特性进行主备</li><li>Z轴：在XY的情况下，对某模块下的单一业务再次划分XY(如对用户基于身份证号进行划分)</li><li>设计微服务的4个原则：AKF拆分原则、前后端分离原则、无状态服务、Restful的通信风格</li></ul></li><li>数据同步方式<ul><li>同步(强一致性)：client对主请求，主保存数据后通知给备，等所有备返回后再返回给client。可能丢失可用性</li><li>异步(弱一致性)：client对主请求，主保存数据后立即返回给client。之后再同步给备。可能产生数据不一致</li><li>队列(最终一致性)：client对主请求，主保存数据后并发送给队列(如kafka)，然后返回给client。之后从节点从队列中获取数据并保存</li></ul></li><li>主备和主从(redis的这两种模式可进行配置，默认主备)<ul><li>主备：一般只有主对外提供服务(无特殊说明，有时候提到的主从也是主备的意思)</li><li>主从：主提供全量服务，从提供部分服务</li><li>这两种情况都需要有一个主，如果主挂了则也不可用，因此需要对主做高可用(HA)</li></ul></li><li>高可用(HA)方式<ul><li>一般使用奇数节点监控，并超过半数进行主备切换<ul><li>为什么使用奇数节点进行监控：如3台和4台都允许挂1台，同样的情况使用4台更容易挂掉一台</li></ul></li></ul></li><li>集群相关配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</span></span><br><span class="line"><span class="comment"># 1) "yes" (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据</span></span><br><span class="line"><span class="comment"># 2) "no"，slave会回复"正在从master同步（SYNC with master in progress）"来处理各种请求，除了 INFO 和 SLAVEOF 命令</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"><span class="comment"># 从节点是否为只读(no则可接受写请求)</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"><span class="comment"># 是否不使用磁盘方式进行同步。同步策略: 磁盘或socket(网络)，默认磁盘方式；磁盘方式表示先数据线落到主节点磁盘，然后同步给子节点；网络方式表示直接通过网络同步给子节点</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"><span class="comment"># 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录新增的数据缓冲，所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段时间内把slave丢失的部分数据传送给它</span></span><br><span class="line"><span class="comment"># 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。backlog只分配一次并且至少需要一个slave连接</span></span><br><span class="line">repl-backlog-size 1mb</span><br><span class="line"><span class="comment"># 当健康的slave的个数小于3个时，mater就禁止写入。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能，默认是关闭</span></span><br><span class="line">min-replicas-to-write 3</span><br><span class="line"><span class="comment"># 延迟小于等于10秒的slave才认为是健康的slave。是从最后一个从slave接收到的ping（通常每秒发送）开始计数</span></span><br><span class="line">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><ul><li><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis官方集群方案</a></li><li><p>redis预分区</p><p> <img src="/data/images/db/redis-预分区.png" alt="redis-预分区"></p><ul><li>假设刚开始只有2个节点，一般此时算法是hash%2，此时可改成直接hash%10(实际会更大，Redis 集群有16384个哈希槽)，那么所有数据会在刚开始就分布在不同的槽位(0-9)；当新增节点时，只需要将部分槽位的数据复制到新节点即可；当客户端查询的数据不在该节点时，会自动路由到目标节点</li></ul></li><li>Redis Cluster特点<ul><li>多主(高可用)多从(主备模式)，去中心化，支持分区：从节点作为备用，复制主节点，不做读写操作，不提供服务</li><li>支持动态扩容节点</li><li>节点之间相互通信，相互选举，不再依赖sentinel<ul><li>相比较sentinel模式，多个master节点保证主要业务（比如master节点主要负责写）稳定性，不需要搭建多个sentinel实例监控一个master节点</li><li>Sentinel模式主要针对高可用（HA），而Cluster模式是不仅针对大数据量，高并发，同时也支持HA</li></ul></li><li>直连某个redis，会自动进行跳转（下文的代理则是连接代理端口）</li><li>部分情况下，支持事物（多条命令执行期间，没有进行redis端口跳转的情况下才支持）</li><li>支持hash tag</li></ul></li><li>Redis Cluster测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis Cluster 在5.0之后取消了ruby脚本 redis-trib.rb的支持。而是集成在redis-cli进行集群管理，查看Redis Cluster帮助</span></span><br><span class="line">redis-cli --cluster <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装</span></span><br><span class="line"><span class="comment"># 进入redis源码目录，查看README文件的集群配置帮助</span></span><br><span class="line">utils/create-cluster</span><br><span class="line"><span class="comment"># 可修改配置，如PORT、NODES、REPLICAS</span></span><br><span class="line">vi create-cluster</span><br><span class="line">./create-cluster start <span class="comment"># 启动实例</span></span><br><span class="line"><span class="comment"># 创建集群(需要输入yes进程插槽划分)：创建6个节点，--cluster-replicas为1表示创建一个副本(从节点)，因此是6/(1+1)=3套主从(3个主，3个从，一般是前3个节点为主)</span></span><br><span class="line">redis-cli --cluster create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas 1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line">redis-cli -c -p 30001 <span class="comment"># 使用以上其他端口进行连接亦可</span></span><br><span class="line"><span class="comment"># redis命令操作记录</span></span><br><span class="line">127.0.0.1:30001&gt; <span class="built_in">set</span> k1 1</span><br><span class="line"><span class="comment"># -&gt; Redirected to slot [12706] located at 127.0.0.1:30003      # 根据key进行hash得出k1应该在30003上，因此自动路由(跳转)到30003</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">127.0.0.1:30003&gt; <span class="built_in">set</span> k2 2</span><br><span class="line"><span class="comment"># -&gt; Redirected to slot [449] located at 127.0.0.1:30001        # k2应该在30001上，再跳转到30001</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">127.0.0.1:30001&gt; <span class="built_in">set</span> k3 3</span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">127.0.0.1:30001&gt; multi                                          <span class="comment"># 在30001上开启了事物</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">127.0.0.1:30001&gt; <span class="built_in">set</span> k1 2                                       <span class="comment"># k1在30003上，因此跳转到了30003</span></span><br><span class="line"><span class="comment"># -&gt; Redirected to slot [12706] located at 127.0.0.1:30003</span></span><br><span class="line"><span class="comment"># OK</span></span><br><span class="line">127.0.0.1:30003&gt; <span class="built_in">exec</span>                                           <span class="comment"># 在30003上提交事物报错，因为30003并没有开启事物</span></span><br><span class="line"><span class="comment"># (error) ERR EXEC without MULTI</span></span><br><span class="line">127.0.0.1:30003&gt; <span class="built_in">set</span> &#123;order&#125;k1 1                                <span class="comment"># 基于hash tag设置(相同tag会落到同一机器)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:30003&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:30003&gt; <span class="built_in">set</span> &#123;order&#125;k1 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:30003&gt; <span class="built_in">exec</span>                                           <span class="comment"># 提交事物成功。此结果是因为中途没有跳转到其他机器，如果跳转到其他机器事物仍然执行失败</span></span><br><span class="line">1) OK</span><br></pre></td></tr></table></figure><h4 id="基于docker搭建集群"><a href="#基于docker搭建集群" class="headerlink" title="基于docker搭建集群"></a>基于docker搭建集群</h4><ul><li>(3主3从)参考：<a href="https://juejin.cn/post/7095675331696132127" target="_blank" rel="noopener">https://juejin.cn/post/7095675331696132127</a><ul><li>需要提前创建网络如<code>docker network create sq-redis</code></li></ul></li></ul><h4 id="主备设置实践-replicaof"><a href="#主备设置实践-replicaof" class="headerlink" title="主备设置实践(replicaof)"></a>主备设置实践(replicaof)</h4><ul><li>推荐使用<a href="#Redis%20Cluster">Redis Cluster(参考下文)</a></li><li>主备设置相关命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在备节点(6380)中运行，追随主节点(6379)。5.0之前的命令使用slaveof</span></span><br><span class="line">replicaof 127.0.0.1 6379 <span class="comment"># 此时会先把备节点的数据删除掉，然后再同步主节点数据</span></span><br><span class="line"><span class="comment"># 当主节点挂了之后，此时可手动将某个从节点设置为不追随(此时数据不会丢失)，然后将其他从节点通过replicaof命令重新追随新的主</span></span><br><span class="line">replicaof no one</span><br></pre></td></tr></table></figure><details><br><summary>主备配置完整测试(伪主备)</summary><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.在一台机器上安装2个redis服务(伪主备)，先关闭所有redis服务，之后手动启动</span></span><br><span class="line"><span class="comment"># 2.复制一份配置文件出来测试(生产环境不需要)。修改配置文件中的port端口，修改`daemonize no`(不后台运行)，注释`logfile /var/log/redis_xxx.log`(日志打印在前台)</span></span><br><span class="line">cp /etc/redis/6379.conf .</span><br><span class="line">cp /etc/redis/6380.conf .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.启动服务端，打印日志如下</span></span><br><span class="line">redis-server ./6379.conf</span><br><span class="line">redis-server ./6380.conf</span><br><span class="line"><span class="comment"># 打印日志如</span></span><br><span class="line"><span class="comment"># 7507:M 11 Jul 2020 15:33:15.083 * DB loaded from disk: 0.000 seconds</span></span><br><span class="line"><span class="comment"># 7507:M 11 Jul 2020 15:33:15.083 * Ready to accept connections</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动2个客户端连接不同的服务端</span></span><br><span class="line">redis-cli -p 6379 <span class="comment"># A客户端</span></span><br><span class="line">redis-cli -p 6380 <span class="comment"># B</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.B客户端执行，使6380追随6379。或者在启动6380时使用`redis-server --port 6380 --slaveof 127.0.0.1 6379`(也可写到配置文件)</span></span><br><span class="line">replicaof 127.0.0.1 6379</span><br><span class="line"><span class="comment"># 此时6379打印日志(PID: 7442)</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.247 * Replica 127.0.0.1:6380 asks for synchronization</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.247 * Partial resynchronization not accepted: Replication ID mismatch (Replica asked for '8a87f600ddb2cace3efff018319c1964f0c38909', my replication IDs are '8a51a8a1a9eddd18477322b15611a839230c2cb9' and '0000000000000000000000000000000000000000')</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.247 * Starting BGSAVE for SYNC with target: disk      # 开始保存数据到磁盘</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.455 * Background saving started by pid 7549           # 开启（fork）新进程保存数据到磁盘</span></span><br><span class="line"><span class="comment"># 7549:C 11 Jul 2020 15:35:11.641 * DB saved on disk</span></span><br><span class="line"><span class="comment"># 7549:C 11 Jul 2020 15:35:11.642 * RDB: 6 MB of memory used by copy-on-write</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.655 * Background saving terminated with success</span></span><br><span class="line"><span class="comment"># 7442:M 11 Jul 2020 15:35:11.655 * Synchronization with replica 127.0.0.1:6380 succeeded</span></span><br><span class="line"><span class="comment"># 此时6380打印日志(PID: 7447)</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.145 * Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.145 * REPLICAOF 127.0.0.1:6379 enabled (user request from 'id=3 addr=127.0.0.1:41764 fd=7 name= age=55 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=44 qbuf-free=32724 obl=0 oll=0 omem=0 events=r cmd=replicaof')</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.246 * Connecting to MASTER 127.0.0.1:6379</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.247 * MASTER &lt;-&gt; REPLICA sync started</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.247 * Non blocking connect for SYNC fired the event.</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.247 * Master replied to PING, replication can continue...</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.247 * Trying a partial resynchronization (request 8a87f600ddb2cace3efff018319c1964f0c38909:1).</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.460 * Full resync from master: 7a40d80043aa6c94a09ee0efbd1139515a2e39bf:0</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.460 * Discarding previously cached master state.</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.655 * MASTER &lt;-&gt; REPLICA sync: receiving 330 bytes from master</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.655 * MASTER &lt;-&gt; REPLICA sync: Flushing old data                      # 删除本地之前老的数据，好准备同步主节点数据</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.656 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:35:11.656 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.对A节点增加数据</span></span><br><span class="line"><span class="built_in">set</span> k1 hello</span><br><span class="line"><span class="comment"># 然后在B节点获取数据</span></span><br><span class="line">get k1 <span class="comment"># 返回hello</span></span><br><span class="line"><span class="built_in">set</span> k2 hello <span class="comment"># 默认从节点是不能进行写操作的。(error) READONLY You can't write against a read only replica.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时让6379挂掉，从节点打印如下日志，但是数据不会丢失</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:56:19.049 # Connection with master lost.</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:56:19.049 * Caching the disconnected master state.</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:56:19.131 * Connecting to MASTER 127.0.0.1:6379</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:56:19.131 * MASTER &lt;-&gt; REPLICA sync started</span></span><br><span class="line"><span class="comment"># 7447:S 11 Jul 2020 15:56:19.131 # Error condition on socket for SYNC: Connection refused</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.在B节点运行，让6380不再追随其他节点，此时此节点可但对对外提供服务</span></span><br><span class="line">replicaof no one</span><br><span class="line"><span class="comment"># 7447:M 11 Jul 2020 15:57:39.542 # Setting secondary replication ID to 7a40d80043aa6c94a09ee0efbd1139515a2e39bf, valid up to offset: 1838. New replication ID is a7579908c5a0445e4da0e53ee1b9a35f543d257e</span></span><br><span class="line"><span class="comment"># 7447:M 11 Jul 2020 15:57:39.542 * Discarding previously cached master state.</span></span><br><span class="line"><span class="comment"># 7447:M 11 Jul 2020 15:57:39.542 * MASTER MODE enabled (user request from 'id=3 addr=127.0.0.1:41764 fd=7 name= age=1404 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=36 qbuf-free=32732 obl=0 oll=0 omem=0 events=r cmd=replicaof')</span></span><br><span class="line"><span class="built_in">set</span> k2 hello</span><br></pre></td></tr></table></figure><br><br></details><h4 id="高可用-基于Sentinel哨兵"><a href="#高可用-基于Sentinel哨兵" class="headerlink" title="高可用(基于Sentinel哨兵)"></a>高可用(基于Sentinel哨兵)</h4><ul><li>说明<ul><li>主挂了，自动选择出一个新的主节点，Sentinel模式主要针对高可用（HA）</li><li>更推荐使用<a href="#Redis%20Cluster">Redis Cluster(参考下文)</a></li></ul></li><li>Sentinel实践</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认`redis-sentinel`程序在redis安装源码的src目录，安装到特定目录时只是将`redis-sentinel`程序链接到`redis-server`(即只能通过redis-server启动)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建sentinel-26379.conf、sentinel-26380.conf、sentinel-26381.conf，写入以下配置(注意修改port)，哨兵启动后会动态修改此配置文件。详细配置文件在下载的redis源码目录的`sentinel.conf`文件中，主要如下</span></span><br><span class="line">port 26379                                      <span class="comment"># Sentinel监听的端口</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2      <span class="comment"># 监控的redis集群的主节点配置(可监听多个集群，给此集群取名为mymaster)，2表示投票达到2票才算通过(此时一般使用3个Sentinel节点)。sentinel各节点无需手动关联，原因是各节点之间是通过PUB/SUB发布订阅进行探测的各哨兵节点，通道为__sentinel__:hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.如主备设置实践中启动3个服务端，并让其他节点追随6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.启动3个sentinel进程。基于redis-server启动sentinel(此redis-server并不对外提供redis服务)</span></span><br><span class="line">redis-server ./sentinel-26379.conf --sentinel</span><br><span class="line"><span class="comment"># 启动后打印日志如下</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:26:56.733 # Sentinel ID is 6a0417e39932ff9648ad92fd6a2bebcc739cf17a</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:26:56.733 # +monitor master mymaster 127.0.0.1 6379 quorum 2</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:26:56.735 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:26:56.736 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:27:10.755 * +sentinel sentinel 83ea631a6cc216429ebce610f8c6f6ce60e4e718 127.0.0.1 26380 @ mymaster 127.0.0.1 6379</span></span><br><span class="line"><span class="comment"># 7639:X 11 Jul 2020 16:27:21.476 * +sentinel sentinel cc806355286a306e2f7298b5de9f8f3a020b68d7 127.0.0.1 26381 @ mymaster 127.0.0.1 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.使6379退出，此时会自动从6380/6381中选取一个作为主节点，并让另外一个追随新的主节点</span></span><br><span class="line"><span class="comment"># 5.使用6379重新启动，此时会发现6379会自动追随刚选出来的新主节点</span></span><br></pre></td></tr></table></figure><h4 id="分区-片"><a href="#分区-片" class="headerlink" title="分区/片"></a>分区/片</h4><ul><li>一般针对业务无法拆分的功能，受到单机容量限制，从而需要进行分区/片(每个节点存放的不是全量数据)</li><li><p>分区方式(以下3个模式均不能做数据库用)</p><ul><li>基于<code>modula</code>算法(hash取模)拆分<ul><li>缺点：取模的数必须固定，影响分布式下的扩展性(增加节点必须全量重新hash计算)</li></ul></li><li>基于<code>random</code>算法拆分(随机放到不同的节点)<ul><li>缺点：客户端不能精确知道数据具体存放的节点</li><li>应用场景：消息队列<ul><li>客户端通过lpush存放到某个key的集合中，另外一个客户端只需要通过rpop任意取出一个进行消费即可</li><li>类似kafka，此时key可理解为topic，redis节点可认为是partition</li></ul></li></ul></li><li>基于<code>ketama</code>算法(一致性hash算法)拆分<ul><li><strong>一致性hash算法</strong> <a href="https://www.jianshu.com/p/528ce5cd7e8f" target="_blank" rel="noopener">^5</a><ul><li>是对2^32方取模，即一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为0 ~ 2^32 - 1(一个32位无符号整型)</li><li>规划一个虚拟哈希环，不同的节点通过hash算法落到此环的某个点，数据通过key进行hash得到该环的位置，并将数据存放在最近的节点上</li></ul></li><li>优点：新增节点可以分担其他节点的压力，不会造成全局洗牌</li><li>缺点：新增节点造成一小部分数据不能命中(如增加node3，key为xxx对应数据原本在node1，此时客户端会到最近的node3上去找)<ul><li>问题：击穿，压到mysql</li><li>方案：去取最近的2个物理节点获取数据(只能减少一部分问题)</li></ul></li><li>数据倾斜问题：节点太少可能在某一节点的数据太多，可创建多个虚拟节点</li></ul></li><li><p>图解</p><p> <img src="/data/images/db/redis-sharding.png" alt="redis-sharding"></p></li><li>缺点<ul><li>以上3个模式均不能做数据库用，主要是新增节点时会出现一段时间的数据丢失</li><li>解决方案：<a href="#Redis%20Cluster">预分区、Redis Cluster</a></li></ul></li></ul></li><li>数据分治(分区)产生问题<ul><li>聚合操作很难实现(不同的key分布在不同的节点)，因此涉及多个key的操作通常不会被支持</li><li>事务很难实现</li><li>分区时动态扩容或缩容可能非常复杂</li></ul></li><li>hash tag<ul><li>命令可以为<code>{tag1}key1</code>、<code>{tag1}key2</code>，从而可将相同的tag放到同一个节点，实现一定程度的支持事物等功能</li></ul></li></ul><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li>更推荐使用<a href="#Redis%20Cluster">Redis Cluster(参考下文)</a>。直连某个redis，会自动进行跳转，无需代理</li><li><p>如果客户端直接连接redis各节点会产生较高的连接成本，因此可使用代理(类似nginx)，客户端只连接代理</p><p> <img src="/data/images/db/redis-proxy.png" alt="redis-proxy"></p></li><li>常见redis代理组件<ul><li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">twemproxy</a><ul><li>twitter开源</li><li>仅支持分区模式</li><li>不支持事物等命令</li><li>不支持hash tag（形如<code>{xx}key</code>）</li></ul></li><li><a href="https://github.com/joyieldInc/predixy" target="_blank" rel="noopener">predixy</a><ul><li>性能较高</li><li>支持分区、主备模式</li><li>支持监控一套主备的哨兵模式（仅支持主备，分区则不支持），此情况才支持事物等命令（分区后不支持事物）</li><li>支持hash tag（分区+主备也支持）</li></ul></li><li>codis</li><li>redis-cerberus</li></ul></li><li><p>redis代理组件对比：<a href="https://blog.csdn.net/rebaic/article/details/76384028" target="_blank" rel="noopener">https://blog.csdn.net/rebaic/article/details/76384028</a></p><p> <img src="/data/images/db/redis-proxy-vs.png" alt="redis-proxy-vs"></p></li></ul><h5 id="twemproxy测试"><a href="#twemproxy测试" class="headerlink" title="twemproxy测试"></a>twemproxy测试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装</span></span><br><span class="line">yum install -y git automake libtool</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/twitter/twemproxy.git</span><br><span class="line"><span class="built_in">cd</span> twemproxy</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure</span><br><span class="line">make <span class="comment"># 编译，会在src目录生成nutcracker的可执行文件</span></span><br><span class="line">src/nutcracker -h <span class="comment"># 查看帮助</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 上述nutcracker可直接使用，下面将它设置成服务</span></span><br><span class="line">cp scripts/nutcracker.init /etc/init.d/twemproxy</span><br><span class="line">chmod +x /etc/init.d/twemproxy</span><br><span class="line">chkconfig --add twemproxy <span class="comment"># 设置twemproxy为服务</span></span><br><span class="line">systemctl status twemproxy</span><br><span class="line">mkdir /etc/nutcracker <span class="comment"># 复制nutcracker.yml等配置文件到scripts/nutcracker.init脚本中指定的位置</span></span><br><span class="line">cp conf/* /etc/nutcracker</span><br><span class="line">cp src/nutcracker /usr/bin/ <span class="comment"># 复制可执行程序到scripts/nutcracker.init脚本中指定的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line">vi /etc/nutcracker/nutcracker.yml <span class="comment"># 参考下文进行代理配置</span></span><br><span class="line"><span class="comment"># 参考上文[主备设置实践](#主备设置实践(replicaof))启动两个redis节点。然后启动twemproxy并连接</span></span><br><span class="line">systemctl start twemproxy</span><br><span class="line">redis-cli -p 22121</span><br><span class="line"><span class="comment"># 1.普通设值</span></span><br><span class="line"><span class="built_in">set</span> k1 hello <span class="comment"># 存放在6379</span></span><br><span class="line"><span class="built_in">set</span> k1 hi <span class="comment"># 存放在6379</span></span><br><span class="line"><span class="built_in">set</span> 1 1 <span class="comment"># 存放在6380</span></span><br><span class="line">get k1 <span class="comment"># hello</span></span><br><span class="line"><span class="comment"># redis-cli -p 6379 # 单独连接各节点，发现3个key分布在不同节点(如果在同一节点可设置不同的key试试)</span></span><br><span class="line"><span class="comment"># 2.在代理客户端上执行，keys *、watch k1、mulit等命令不能执行(由于进行了分片，key可能落在多个节点)</span></span><br><span class="line">keys * <span class="comment"># Error: Server closed the connection</span></span><br><span class="line"><span class="comment"># 3.断开6380节点，发现6379的数据可正常get，但是挂掉的6380数据无法正常访问</span></span><br><span class="line">get 1 <span class="comment"># (error) ERR Connection refused</span></span><br><span class="line"><span class="built_in">set</span> 1 2 <span class="comment"># OK。6380挂掉后，重新设置此key会保存到6379</span></span><br><span class="line"><span class="comment"># 4.不支持形如`&#123;xx&#125;key`的hash tag</span></span><br></pre></td></tr></table></figure><ul><li>/etc/nutcracker/nutcracker.yml测试配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代理名称</span></span><br><span class="line"><span class="attr">alpha:</span></span><br><span class="line"><span class="attr">  listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:22121</span>       <span class="comment"># 代理监听的地址，之后客户端连接此地址访问redis即可</span></span><br><span class="line"><span class="attr">  hash:</span> <span class="string">fnv1a_64</span>                <span class="comment"># hash算法 </span></span><br><span class="line"><span class="attr">  distribution:</span> <span class="string">ketama</span>          <span class="comment"># 分片方式(每个节点存放的不是全量数据)</span></span><br><span class="line"><span class="attr">  auto_eject_hosts:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  redis:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  server_retry_timeout:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">  server_failure_limit:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  servers:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379:1</span>           <span class="comment"># 节点配置，最后的1表示权重(不同节点存放数据量的多少)</span></span><br><span class="line"><span class="bullet">   -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6380:1</span></span><br><span class="line"><span class="comment"># 可配置多个代理</span></span><br></pre></td></tr></table></figure><h5 id="predixy测试"><a href="#predixy测试" class="headerlink" title="predixy测试"></a>predixy测试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/joyieldInc/predixy/blob/master/README_CN.md</span></span><br><span class="line"><span class="comment">## 安装</span></span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line">tar -zxvf predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line"><span class="built_in">cd</span> predixy-1.0.5</span><br><span class="line"><span class="comment"># bin/predixy conf/predixy.conf # 启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line"><span class="comment"># 修改主配置：打开监听端口`Bind 127.0.0.1:7617`；使用哨兵模式，导入配置`Include sentinel.conf`(去掉此行注释，并注释掉`Include try.conf`)</span></span><br><span class="line">vi conf/predixy.conf</span><br><span class="line">vi conf/sentinel.conf <span class="comment"># 修改predixy中的哨兵配置，如下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动哨兵。配置如下文(同样启动26380/26381)，并监听两套主从节点</span></span><br><span class="line">vi ~/sentinel-26379.conf</span><br><span class="line">redis-server ./sentinel-26379.conf --sentinel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis主备。参考上文[主备设置实践](#主备设置实践(replicaof))启动两套redis主从(36379、36380和46379、46380)</span></span><br><span class="line">redis-server ./36379.conf</span><br><span class="line">redis-server ./36380.conf --slaveof 127.0.0.1 36379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并连接</span></span><br><span class="line">bin/predixy conf/predixy.conf</span><br><span class="line">redis-cli -p 7617</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.普通设值</span></span><br><span class="line"><span class="built_in">set</span> k1 1 <span class="comment"># 存放在36379主从中</span></span><br><span class="line"><span class="built_in">set</span> k2 2 <span class="comment"># 存放在46379主从中</span></span><br><span class="line"><span class="comment"># 2.hash tag设值。以&#123;order&#125;开头的全部存放在同一节点</span></span><br><span class="line"><span class="built_in">set</span> &#123;order&#125;k1 1</span><br><span class="line"><span class="built_in">set</span> &#123;order&#125;k2 2</span><br><span class="line"><span class="comment"># 3.当前版本只支持Sentinel搭配一个Group的主从时才支持事物等功能，此处conf/sentinel.conf有两个Group(xxx、yyy)因此无法支持以下命令</span></span><br><span class="line">multi <span class="comment"># (error) ERR forbid transaction in current server pool</span></span><br><span class="line">keys * <span class="comment"># (error) ERR unknown command 'keys'</span></span><br><span class="line"><span class="comment"># 4.挂掉某一套的从节点，系统仍然可用</span></span><br><span class="line"><span class="comment"># 5.挂掉某一套的主节点，系统刚开始不可用，等到哨兵重新设置主节点后恢复可用</span></span><br><span class="line"><span class="built_in">set</span> k3 3 <span class="comment"># (error) ERR server connection close =&gt; (error) ERR no server connection avaliable =&gt; OK</span></span><br><span class="line"><span class="comment"># 6.挂掉了一套主从节点(整个一套全部挂掉)，此时如果某hash tag存放在此节点，则同样的hash tag将无法继续创建</span></span><br><span class="line"><span class="built_in">set</span> &#123;order&#125;k3 3 <span class="comment"># (error) ERR server connection close</span></span><br><span class="line"><span class="comment"># 7.配置conf/sentinel.conf中只保留一个Group(实际Sentinel仍然监控了两套主从)，则可支持事物</span></span><br><span class="line">keys * <span class="comment"># (error) ERR unknown command 'keys'</span></span><br><span class="line">multi <span class="comment"># OK</span></span><br><span class="line">keys * <span class="comment"># QUEUED</span></span><br><span class="line"><span class="built_in">exec</span> <span class="comment"># 通过事物执行keys *可成功</span></span><br><span class="line">watch k1 <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><ul><li>测试配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## conf/sentinel.conf</span></span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">"&#123;&#125;"</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    <span class="comment"># 配置3个哨兵节点</span></span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 127.0.0.1:26379</span><br><span class="line">        + 127.0.0.1:26380</span><br><span class="line">        + 127.0.0.1:26381</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 哨兵配置文件中定义监控组名称(xxx为一套主从，yyy为一套主从)。如果需要支持事物，此处只能配置一个Group</span></span><br><span class="line">    Group xxx &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Group yyy &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## sentinel-26379.conf(监控两套主从)，同理创建26380、26381</span></span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor xxx 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor yyy 127.0.0.1 46379 2</span><br></pre></td></tr></table></figure><h3 id="击穿-穿透-雪崩"><a href="#击穿-穿透-雪崩" class="headerlink" title="击穿/穿透/雪崩"></a>击穿/穿透/雪崩</h3><ul><li><p>击穿、穿透、雪崩</p><ul><li>击穿<ul><li>某个(热点)key突然失效，造成大量请求同时访问数据库</li><li>解决方案：setnx加锁取数据到redis，并设置加锁超时时间(防止死锁)</li></ul></li><li>穿透<ul><li>访问了大量不存在的(redis中没有)数据</li><li>解决方案：使用布隆过滤器、布谷鸟过滤器</li></ul></li><li><p>雪崩</p><ul><li>大量key同时失效，造成同时大量访问数据库</li><li>解决方案：缓存预热、随机过期时间、二级缓存、加锁或队列</li></ul><p><img src="/data/images/db/redis-击穿-穿透-雪崩.png" alt="redis-击穿-穿透-雪崩"></p></li></ul></li><li><p>击穿解决方案：setnx加锁，伪代码如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 代表缓存值过期</span></span><br><span class="line">        <span class="comment">// 加锁，并设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123; <span class="comment">// 代表设置成功</span></span><br><span class="line">            value = db.get(key); <span class="comment">// 如果这一步很耗时，可以考虑多线程(一个线程取DB，一个线程监控数据是否取回来并更新锁)</span></span><br><span class="line">            redis.set(key, value, expire_secs);</span><br><span class="line">            redis.del(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这个时候代表有其他线程获取到锁，已经或正在load db并回设到缓存，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            value = get(key); <span class="comment">// 重试（递归调用，如果值为空还是会尝试获取锁）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>穿透解决方案：布隆过滤器、布谷鸟过滤器</li><li>雪崩解决方案：随机过期时间、二级缓存、加锁或队列（针对时点性高的场景）</li></ul><h4 id="布隆和布谷鸟过滤器"><a href="#布隆和布谷鸟过滤器" class="headerlink" title="布隆和布谷鸟过滤器"></a>布隆和布谷鸟过滤器</h4><ul><li><p><code>布隆过滤器</code>(Bloom Filter)：一种比较巧妙的概率型数据结构，<strong>它可以告诉你某种东西一定不存在或者可能存在</strong></p><ul><li>布隆过滤器相对于Set、Map 等数据结构来说，它可以更高效地插入和查询，并且占用空间更少。缺点是判断某种东西是否存在时，可能会被误判，但是只要参数设置的合理，它的精确度也可以控制的相对精确，只会有小小的误判概率</li><li><p>牺牲存储空间来换查询速度</p><p><img src="/data/images/db/redis-bloom.png" alt="redis-bloom"></p></li></ul></li><li><code>布谷鸟过滤器</code><ul><li>相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数</li></ul></li><li><strong>解决缓存穿透的问题</strong><ul><li>一般情况下，先查询缓存是否有该条数据，缓存中没有时，再查询数据库。当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。缓存穿透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库</li><li>可以使用布隆过滤器解决缓存穿透的问题，把已存在数据的key存在布隆过滤器中。当有新的请求时，先到布隆过滤器中查询是否存在，如果缓存中不存在该条数据直接返回；如果缓存中存在该条数据再查询数据库</li></ul></li><li>redis中可以手动添加<a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">布隆过滤器模块(包含布谷鸟)</a>，实际也可在客户端实现布隆算法从而到达过滤效果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装</span></span><br><span class="line">wget https://github.com/RedisBloom/RedisBloom/archive/v2.2.3.zip</span><br><span class="line">yum install unzip</span><br><span class="line">unzip v2.2.3.zip</span><br><span class="line"><span class="built_in">cd</span> RedisBloom-2.2.3/</span><br><span class="line">make <span class="comment"># 编译，会生成bloom.so库</span></span><br><span class="line">cp redisbloom.so /opt/soft/redis5/</span><br><span class="line"></span><br><span class="line"><span class="comment">## 操作(该模块提供了bf.*、cf.*等命令)</span></span><br><span class="line"><span class="comment"># 启动时载入布隆模块，也可在配置文件的MODULES部分进行配置</span></span><br><span class="line">redis-server --loadmodule /opt/soft/redis5/redisbloom.so <span class="comment"># 启动时加载布隆过滤器模块</span></span><br><span class="line">redis-cli</span><br><span class="line">bf.add k1 123 <span class="comment"># 通过布隆过滤器添加元素123到k1中</span></span><br><span class="line"><span class="built_in">type</span> k1 <span class="comment"># MBbloom--</span></span><br><span class="line">bf.exists k1 abc <span class="comment"># (integer) 0，判断k1中是否存在abc</span></span><br><span class="line">bf.exists k1 123 <span class="comment"># (integer) 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布谷鸟过滤器，使用同上</span></span><br><span class="line">cf.add</span><br><span class="line">cf.exists</span><br></pre></td></tr></table></figure><h3 id="双写一致性问题"><a href="#双写一致性问题" class="headerlink" title="双写一致性问题"></a>双写一致性问题</h3><ul><li>当更新数据时，数据库和缓存的更新如何保证数据一致</li><li>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案</li><li>如果不考虑设置过期时间，存在一下几种方式 <a href="https://www.cnblogs.com/wangwust/p/9467586.html" target="_blank" rel="noopener">^6</a><ul><li>先更新缓存，再更新数据库：不推荐，明显很容易出现数据不一致的问题</li><li>先更新数据库，再更新缓存：不推荐，A/B线程先后更新了数据库，B/A先后更新了缓存，导致最终数据不一致</li><li>先删除缓存，再更新数据库：不推荐，如删除缓存后，在数据库更新完成前，另外一个线程重新读取数据把旧数据写入到缓存<ul><li>可采用延时双删策略，即先删缓存 - 更新数据库 - 延迟一定时间(确保数据读取完成/分库分别同步完成)再删除缓存</li><li>由于需要延迟会导致吞吐量下降，可使用异步显示进行删除（但是会存在第二次删除失败的情况）</li></ul></li><li><strong>先更新数据库，再删除缓存</strong><ul><li>可能出现数据不一致的概率较小(缓存失效线程A查询到一个旧值，线程B更新了数据库并完成了缓存删除，线程A把读取的旧值写入到缓存。出现概率小的原因是读一般是比写快，上述情况是在完成一个写的情况下，读还没完成导致)</li><li>也可进行解决：进行异步延迟删除，如果更新失败则通过消息队列重试更新。（为了减少对业务代码的入侵，可更新数据库后，订阅binlog日志，进行缓存更新，再结合消息队列处理失败的更新）</li></ul></li></ul></li></ul><h2 id="Java使用"><a href="#Java使用" class="headerlink" title="Java使用"></a>Java使用</h2><h3 id="SpringBoot使用Redis"><a href="#SpringBoot使用Redis" class="headerlink" title="SpringBoot使用Redis"></a>SpringBoot使用Redis</h3><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis缓存配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">   host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">   port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">   database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">   password:</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储String</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"myRedisKey"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">redisTemplate.opsForValue().get(<span class="string">"myRedisKey"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储Map</span></span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">"myRedisKey"</span>, <span class="string">"myMapKey"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">redisTemplate.opsForHash().get(<span class="string">"myRedisKey"</span>, <span class="string">"myMapKey"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Jedis使用"><a href="#Jedis使用" class="headerlink" title="Jedis使用"></a>Jedis使用</h3><ul><li>Jedis为java中操作redis的客户端</li><li>引入jar包(参考上文pom)<ul><li>使用Java操作Redis需要jedis-3.0.1.jar</li><li>如果需要使用Redis连接池的话，还需commons-pool2-2.6.2.jar</li></ul></li><li>简单使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接，如果使用空参构造，默认值 localhost:6379 端口</span></span><br><span class="line">redis.clients.jedis.Jedis jedis = <span class="keyword">new</span> redis.clients.jedis.Jedis();</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">String name = jedis.get(<span class="string">"name"</span>); <span class="comment">// zhangsan</span></span><br><span class="line"><span class="comment">// hash类型：map格式</span></span><br><span class="line">jedis.hset(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>, <span class="string">"id"</span>, <span class="string">"13"</span>);</span><br><span class="line">jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>); <span class="comment">// zhangsan</span></span><br><span class="line">Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>); <span class="comment">// 获取全部数据</span></span><br><span class="line"><span class="comment">// 列表类型：list格式</span></span><br><span class="line">jedis.lpush(<span class="string">"list"</span>, <span class="string">"a"</span>); <span class="comment">// 左边添加数据</span></span><br><span class="line">jedis.rpush(<span class="string">"list"</span>, <span class="string">"b"</span>); <span class="comment">// 右边添加数据</span></span><br><span class="line">String list = jedis.rpop(<span class="string">"list"</span>); <span class="comment">// 移除最右边的数据并返回值</span></span><br><span class="line"><span class="comment">// 集合类型：set格式</span></span><br><span class="line">jedis.sadd(<span class="string">"set"</span>, <span class="string">"a"</span>);</span><br><span class="line">jedis.sadd(<span class="string">"set"</span>, <span class="string">"b"</span>);</span><br><span class="line">Set&lt;String&gt; set = jedis.smembers(<span class="string">"set"</span>);</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><ul><li>使用连接池连接redis集群(jedis v3)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考: https://blog.51cto.com/u_14402/9184932</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisCluster jedis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可用连接实例的最大数目，默认为8；特别多的并发的情况也可以设置的高，如500或更高 (服务器集群默认最大允许10000个连接)</span></span><br><span class="line">    <span class="comment">//如果赋值为-1，则表示不限制，如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer MAX_TOTAL = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//控制一个pool最多有多少个状态为idle(空闲)的jedis实例，默认值是8；其他如20</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer MAX_IDLE = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//等待可用连接的最大时间，单位是毫秒，默认值为-1，表示永不超时。</span></span><br><span class="line">    <span class="comment">//如果超过等待时间，则直接抛出JedisConnectionException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer MAX_WAIT_MILLIS = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">//在borrow(用)一个jedis实例时，是否提前进行validate(验证)操作；</span></span><br><span class="line">    <span class="comment">//如果为true，则得到的jedis实例均是可用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean TEST_ON_BORROW = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//在空闲时检查有效性, 默认false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean TEST_WHILE_IDLE = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//是否进行有效性检查</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean TEST_ON_RETURN = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String AUTH = <span class="string">"1234@abcd"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态块，初始化Redis连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">            <span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">                在高版本的jedis jar包，比如本版本2.9.0，JedisPoolConfig没有setMaxActive和setMaxWait属性了</span></span><br><span class="line"><span class="comment">                这是因为高版本中官方废弃了此方法，用以下两个属性替换。</span></span><br><span class="line"><span class="comment">                maxActive  ==&gt;  maxTotal</span></span><br><span class="line"><span class="comment">                maxWait ==&gt;  maxWaitMillis</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            config.setMaxTotal(MAX_TOTAL);</span><br><span class="line">            config.setMaxIdle(MAX_IDLE);</span><br><span class="line">            config.setMaxWaitMillis(MAX_WAIT_MILLIS);</span><br><span class="line">            config.setTestOnBorrow(TEST_ON_BORROW);</span><br><span class="line">            config.setTestWhileIdle(TEST_WHILE_IDLE);</span><br><span class="line">            config.setTestOnReturn(TEST_ON_RETURN);</span><br><span class="line"></span><br><span class="line">            Set&lt;HostAndPort&gt; jedisClusterNode = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.31"</span>, <span class="number">6380</span>));</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.32"</span>, <span class="number">6380</span>));</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.33"</span>, <span class="number">6380</span>));</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.34"</span>, <span class="number">6380</span>));</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.35"</span>, <span class="number">6380</span>));</span><br><span class="line">            jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.0.36"</span>, <span class="number">6380</span>));</span><br><span class="line"></span><br><span class="line">            jedis = <span class="keyword">new</span> JedisCluster(jedisClusterNode,<span class="number">2000</span>,<span class="number">2000</span>,<span class="number">5</span>,AUTH,config);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisCluster <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用连接池连接redis单机(jedis v3)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        InputStream resourceAsStream = JedisUtil.class.getClassLoader().getResourceAsStream(<span class="string">"jedis.properties"</span>);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(resourceAsStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建配置文件对象</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">// 控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；低版本使用(如v2.9.0之前) setMaxActive</span></span><br><span class="line">        <span class="comment">// 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。  </span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(Integer.parseInt(properties.getProperty(<span class="string">"maxTotal"</span>))); <span class="comment">// 500</span></span><br><span class="line">        <span class="comment">// 控制一个pool最多有多少个状态为idle(空闲的)的jedis实例</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(Integer.parseInt(<span class="string">"maxIdle"</span>)); <span class="comment">// 默认 8</span></span><br><span class="line">        <span class="comment">// 表示当borrow(引入)一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException</span></span><br><span class="line">        <span class="comment">// config.setMaxWait(1000 * 100);  </span></span><br><span class="line">        <span class="comment">// 在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的</span></span><br><span class="line">        <span class="comment">// config.setTestOnBorrow(true);</span></span><br><span class="line">        <span class="comment">// 初始化jedispool, localhost:6379</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, properties.getProperty(<span class="string">"host"</span>), Integer.parseInt(properties.getProperty(<span class="string">"port"</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返还到连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pool  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redis</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">returnResource</span><span class="params">(Jedis redis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (redis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedisPool.returnResource(redis);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串数据示例</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisPool = JedisUtil.getJedisPool();</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">            String value = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 释放redis对象</span></span><br><span class="line">            jedisPool.returnBrokenResource(jedis);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 返还到连接池</span></span><br><span class="line">            JedisUtil.returnResource(pool, jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决session一致性-session共享"><a href="#解决session一致性-session共享" class="headerlink" title="解决session一致性(session共享)"></a>解决session一致性(session共享)</h3><ul><li>参考<a href="/_posts/arch/nginx.md#反向代理和负载均衡">nginx.md#反向代理和负载均衡</a></li></ul><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><ul><li>分布式场景方案：<a href="https://blog.csdn.net/asd051377305/article/details/108384490" target="_blank" rel="noopener">https://blog.csdn.net/asd051377305/article/details/108384490</a></li><li>示例 <a href="https://www.cnblogs.com/moxiaotao/p/10829799.html" target="_blank" rel="noopener">^4</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lua脚本，从而确保解锁操作是原子性的</span></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        <span class="comment">// 将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行</span></span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code> 对应如 <strong><code>set my_lock id_12345678 nx ex 60</code></strong><ul><li>使用key来当锁，因为key是唯一的</li><li>value传的是requestId，就可知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。<strong>解铃还须系铃人</strong>。requestId可以使用UUID.randomUUID().toString()方法生成</li><li>NX，意思是SET IF NOT EXIST，即当key不存在时，进行set操作；若key已经存在，则不做任何操作。<strong>互斥性</strong></li><li>PX，意思是要给这个key加一个过期的设置，具体时间由第五个参数决定。<strong>防止死锁</strong></li><li>time，与第四个参数相呼应，代表key的过期时间</li><li><strong>此时只考虑Redis单机部署的场景，所以没有考虑容错性</strong>，可使用<a href="https://github.com/redisson/redisson/wiki/8.-Distributed-locks-and-synchronizers" target="_blank" rel="noopener">Redisson</a></li></ul></li><li>分布式锁错误使用<ul><li>错误方式：jedis.setnx()和jedis.expire()组合使用<ul><li>由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间，那么将会发生死锁</li><li>网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法</li></ul></li><li>错误方式：jedis.del()方法删除锁<ul><li>这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的</li></ul></li></ul></li></ul><h3 id="redis对模糊查询的缺陷及解决方案"><a href="#redis对模糊查询的缺陷及解决方案" class="headerlink" title="redis对模糊查询的缺陷及解决方案"></a>redis对模糊查询的缺陷及解决方案</h3><blockquote><p>redis本身适合作为缓存工具，不建议使用模糊查询等操作</p></blockquote><ul><li>使用<a href="redis-search4j">https://code.google.com/archive/p/redis-search4j/</a> ，使用了分词，解决了中文的模糊查询。（效果不好，测试发现会在服务器中存储大量无用的key）</li></ul><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="Redis通信协议规范"><a href="#Redis通信协议规范" class="headerlink" title="Redis通信协议规范"></a>Redis通信协议规范</h3><ul><li>Redis通信协议<ul><li>Redis客户端使用RESP协议（Redis的序列化协议）与Redis的服务器端进行通信</li><li>客户端连接到Redis的服务器，创建到端口6379的TCP连接</li><li>请求-响应模型</li></ul></li><li>RESP协议描述（RESP protocol description）<ul><li>支持以下数据类型的序列化协议：简单字符串（Simple Strings，响应的第一个字节为<code>+</code>），整数（Integers，<code>:</code>），数组（Arrays，<code>*</code>），块字符串/批量字符串（Bulk Strings，<code>$</code>）和错误（Errors，<code>-</code>）</li><li>请求-响应流程<ul><li>客户端将命令作为批量字符串的RESP数组发送到Redis服务器</li><li>服务器（Server）根据命令执行的情况返回一个具体的RESP类型作为回复，有些的数据类型取决于响应的第一个字节（参考上文）</li></ul></li></ul></li></ul><hr><p>参考文章</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> smalle</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.aezo.cn/2016/07/02/db/redis/" title="redis">http://blog.aezo.cn/2016/07/02/db/redis/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/redis/" rel="tag"># redis</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/06/25/service/lightstreamer/" rel="next" title="lightstreamer"><i class="fa fa-chevron-left"></i> lightstreamer</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2016/07/06/extend/java-code-style/" rel="prev" title="Java开发规范">Java开发规范<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div> <a target="_blank" href="https://github.com/oldinaction/ChatGPT-MP"><img class="nofancybox" style="width:300px;margin:0 auto" src="https://cdn7.aezo.cn/one/chat/chat-gpt-open-banner.jpg" alt="ChatGPT开源小程序" title="ChatGPT开源小程序"></a></div></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400" alt="smalle"><p class="site-author-name" itemprop="name">smalle</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">167</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">153</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div><div> 欢迎关注公众号：阿壹族 <img class="nofancybox" style="width:120px;margin:0 auto" src="https://cdn7.aezo.cn/common/qrcode/ayz_qrcode.jpg" alt="欢迎关注公众号：阿壹族" title="欢迎关注公众号：阿壹族"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis简介"><span class="nav-number">1.</span> <span class="nav-text">Redis简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装Redis服务"><span class="nav-number">2.</span> <span class="nav-text">安装Redis服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件"><span class="nav-number">2.1.</span> <span class="nav-text">配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令使用"><span class="nav-number">3.</span> <span class="nav-text">命令使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-number">3.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串-string"><span class="nav-number">3.2.</span> <span class="nav-text">字符串(string)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">3.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-map"><span class="nav-number">3.4.</span> <span class="nav-text">hash(map)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.5.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorted-set"><span class="nav-number">3.6.</span> <span class="nav-text">sorted_set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶"><span class="nav-number">4.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">4.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布订阅"><span class="nav-number">4.2.</span> <span class="nav-text">发布订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipeline管道"><span class="nav-number">4.3.</span> <span class="nav-text">pipeline管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transactions事物"><span class="nav-number">4.4.</span> <span class="nav-text">transactions事物</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据有效期-作为缓存"><span class="nav-number">4.5.</span> <span class="nav-text">数据有效期(作为缓存)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#key的有效期"><span class="nav-number">4.5.1.</span> <span class="nav-text">key的有效期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收策略配置-数据淘汰机制"><span class="nav-number">4.5.2.</span> <span class="nav-text">回收策略配置/数据淘汰机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化-数据库"><span class="nav-number">4.6.</span> <span class="nav-text">持久化(数据库)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB方式持久化"><span class="nav-number">4.6.1.</span> <span class="nav-text">RDB方式持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF方式持久化"><span class="nav-number">4.6.2.</span> <span class="nav-text">AOF方式持久化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群方式"><span class="nav-number">4.7.</span> <span class="nav-text">集群方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-Cluster"><span class="nav-number">4.7.1.</span> <span class="nav-text">Redis Cluster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于docker搭建集群"><span class="nav-number">4.7.2.</span> <span class="nav-text">基于docker搭建集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主备设置实践-replicaof"><span class="nav-number">4.7.3.</span> <span class="nav-text">主备设置实践(replicaof)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高可用-基于Sentinel哨兵"><span class="nav-number">4.7.4.</span> <span class="nav-text">高可用(基于Sentinel哨兵)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区-片"><span class="nav-number">4.7.5.</span> <span class="nav-text">分区/片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理"><span class="nav-number">4.7.6.</span> <span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#twemproxy测试"><span class="nav-number">4.7.6.1.</span> <span class="nav-text">twemproxy测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#predixy测试"><span class="nav-number">4.7.6.2.</span> <span class="nav-text">predixy测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#击穿-穿透-雪崩"><span class="nav-number">4.8.</span> <span class="nav-text">击穿/穿透/雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆和布谷鸟过滤器"><span class="nav-number">4.8.1.</span> <span class="nav-text">布隆和布谷鸟过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双写一致性问题"><span class="nav-number">4.9.</span> <span class="nav-text">双写一致性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java使用"><span class="nav-number">5.</span> <span class="nav-text">Java使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot使用Redis"><span class="nav-number">5.1.</span> <span class="nav-text">SpringBoot使用Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jedis使用"><span class="nav-number">5.2.</span> <span class="nav-text">Jedis使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决session一致性-session共享"><span class="nav-number">5.3.</span> <span class="nav-text">解决session一致性(session共享)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现分布式锁"><span class="nav-number">5.4.</span> <span class="nav-text">实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis对模糊查询的缺陷及解决方案"><span class="nav-number">5.5.</span> <span class="nav-text">redis对模糊查询的缺陷及解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级"><span class="nav-number">6.</span> <span class="nav-text">高级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis通信协议规范"><span class="nav-number">6.1.</span> <span class="nav-text">Redis通信协议规范</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">smalle</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class="powered-by"> 由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="powered-by"> 主题 - <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="theme-info"> <a class="theme-link" target="_blank" href="https://tongji.baidu.com/main/overview/10000542408/overview/index?siteId=18991897">站长统计</a></div></div><div class="ad"> <span style="font-weight:700">AD&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=oby5nolb">阿里云大礼包</a></div></div><div class="aezocn"> <span style="font-weight:700">&copy;AEZO.CN&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="powered-by"> <a target="_blank" href="https://shengqitech.aezo.cn/">圣骑科技</a></div><div class="powered-by"> <a target="_blank" href="https://cdn7.aezo.cn/common/qrcode/one_qrcode.jpg">【One能抽屉】小程序</a></div><div class="theme-info"> <a target="_blank" href="http://shop.aezo.cn/">杂货铺(省钱小助手)</a></div></div><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?085f9cd91ef2ad985f791c677472f0d1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script></body></html>