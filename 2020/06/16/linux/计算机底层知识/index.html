<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="java,cpu,"><link rel="alternate" href="/atom.xml" title="Smalle's Blog | AEZOCN" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1"><meta name="description" content="书籍推荐 计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》 语言：C JAVA 《C 程序设计语言》《C Primer Plus》 数据结构与算法：《Java 数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》 操作系统：Linux 内核源码解析、Linux 内核设计与实现、30 天自制操作系统、深入理解 linux 内核、深入理解计算机系统 网络：机工《TCP/IP"><meta name="keywords" content="java,cpu"><meta property="og:type" content="article"><meta property="og:title" content="计算机底层知识"><meta property="og:url" content="http://blog.aezo.cn/2020/06/16/linux/计算机底层知识/index.html"><meta property="og:site_name" content="Smalle&#39;s Blog | AEZOCN"><meta property="og:description" content="书籍推荐 计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》 语言：C JAVA 《C 程序设计语言》《C Primer Plus》 数据结构与算法：《Java 数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》 操作系统：Linux 内核源码解析、Linux 内核设计与实现、30 天自制操作系统、深入理解 linux 内核、深入理解计算机系统 网络：机工《TCP/IP"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/计算机的组成.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/电脑启动.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/超线程.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/三级缓存.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/UMA-NUMA.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/计算机虚拟内存分段.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/ByteBuffer-position.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/ButeBuffer-FileChannel.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/TCP握手时服务器资源开辟流程.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/tcp-backlog.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/io-nat-route.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/io-多路复用器.png"><meta property="og:image" content="http://blog.aezo.cn/data/images/linux/io-epoll_vs_select_poll.png"><meta property="og:updated_time" content="2021-08-31T06:07:20.365Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="计算机底层知识"><meta name="twitter:description" content="书籍推荐 计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》 语言：C JAVA 《C 程序设计语言》《C Primer Plus》 数据结构与算法：《Java 数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》 操作系统：Linux 内核源码解析、Linux 内核设计与实现、30 天自制操作系统、深入理解 linux 内核、深入理解计算机系统 网络：机工《TCP/IP"><meta name="twitter:image" content="http://blog.aezo.cn/data/images/linux/计算机的组成.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"BWD6R9FA4K",apiKey:"3330f3cbaa099dfc30395de5f5b20151",indexName:"blog",hits:{per_page:10},labels:{input_placeholder:"请输入关键字",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}}}</script><link rel="canonical" href="http://blog.aezo.cn/2020/06/16/linux/计算机底层知识/"><title>计算机底层知识 | Smalle's Blog | AEZOCN</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=cnzz_stat_icon_1276691827&web_id=cnzz_stat_icon_1276691827" language="JavaScript"></script></div></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Smalle's Blog | AEZOCN</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Better Code, Better Life</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br> 站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.aezo.cn/2020/06/16/linux/计算机底层知识/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="smalle"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Smalle's Blog | AEZOCN"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">计算机底层知识</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T20:50:00+08:00">2020-06-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><div></div><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ul><li>计算机：《编码：隐匿在计算机软硬件背后的语言》《深入理解计算机系统》</li><li>语言：C JAVA 《C 程序设计语言》《C Primer Plus》</li><li>数据结构与算法：《Java 数据结构与算法》《算法》《算法导论》《计算机程序设计艺术》</li><li>操作系统：Linux 内核源码解析、<strong>Linux 内核设计与实现</strong>、30 天自制操作系统、深入理解 linux 内核、深入理解计算机系统</li><li>网络：机工《TCP/IP 详解》卷一</li><li>编译原理：《编译原理》《编程语言实现模式》</li><li>数据库：SQLite 源码、Derby(JDK 自带数据库)</li></ul><h2 id="硬件基础知识"><a href="#硬件基础知识" class="headerlink" title="硬件基础知识"></a>硬件基础知识</h2><ul><li><p>计算机的组成</p><p> <img src="/data/images/linux/计算机的组成.png" alt="计算机的组成"></p></li><li><p>CPU 制作</p><ul><li>Intel cpu 的制作过程：<a href="https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="noopener">https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video</a></li><li>CPU 是如何制作的(文字描述)：<a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">https://www.sohu.com/a/255397866_468626</a></li></ul></li><li>CPU 的原理<ul><li>计算机需要解决的最根本问题：如何代表数字</li><li>晶体管是如何工作的：<a href="https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="noopener">https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video</a></li><li>晶体管的工作原理：<a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av47388949?p=2</a></li><li>发展过程<ul><li>硅 - 加入特殊元素 - P 半导体 N 半导体 - PN 结 - 二极管 - 场效应晶体管 - 逻辑开关</li><li>基于逻辑开关实现：与门、或门、非门(异或)，即基础逻辑电路</li><li>再实现加法器、累加器、锁存器</li><li>实现手动计算(通电一次，运行一次位运算)</li><li>加入内存，实现自动运算(每次读取内存指令)。CPU 的每个针脚可以读取一个 0/1</li></ul></li><li>CPU、内存、显卡等都是和主板进行连通</li></ul></li><li>总线<ul><li>总线是计算机各部件之间传递信息的基本通道，将每根小线捆到一起的一根线即为总线</li><li>依据传递的内容不同，总线又分为数据总线、地址总线、控制总线 3 种。CPU 根据不同总线过来的从内存读取数据，从而区分哪些为立即数，哪些为指令(最终还是 0101，因此需要根据总线类型区分)</li></ul></li><li>汇编语言（机器语言）的执行过程<ul><li>最早手工输入：纸带计算机，纸带上有孔，有孔没孔可代表 1/0。一次一只虫子堵住了此孔，因此产生了 BUG</li><li>汇编语言的本质：机器语言(0101)的助记符(mod)，其实它就是机器语言</li><li>计算机通电 -&gt; CPU 读取内存中程序（电信号输入）-&gt; 时钟发生器不断震荡通断电(相关的如 CPU 频率) -&gt; 推动 CPU 内部一步一步执行（执行多少步取决于指令需要的时钟周期）-&gt; 计算完成 -&gt; 写回（电信号）-&gt; 写给显卡输出（sout，或者图形）</li><li>c 编译完后直接是机器码，CPU 可直接执行，即编译执行；java 编译后是二进制码(ByteCode)，执行时通过虚拟机解释成机器语言进行执行，即解释执行</li></ul></li><li>量子计算机<ul><li>量子比特，可同时表示 1 和 0</li><li>潘建伟 18bit 量子纠缠：使用 6 个光子(有 3 个特点：路径、偏振、角动力)得到 6*3=18 个 bit，每个 bit 有 2 中状态，相当于 2^18 中可能。经典计算机只能表示 2^18 中的一个数，而量子计算则能同时表示 2^18 个数</li></ul></li><li><p>启动</p><ul><li><p>通电 -&gt; bios/uefi 工作 -&gt; 自检 -&gt; 到硬盘固定位置加载 bootloader -&gt; 读取可配置信息 -&gt; CMOS(如保存开机密码，有一块额外的小电池通电，没电了数据就会丢失)</p><p><img src="/data/images/linux/电脑启动.png" alt="电脑启动"></p></li></ul></li></ul><h3 id="常见指标"><a href="#常见指标" class="headerlink" title="常见指标"></a>常见指标</h3><ul><li>磁盘寻址是ms级，带宽是G、M<ul><li>固态硬盘IO速度约500M/S，机械硬盘约是100M/S，网卡IO约是100M/S(ping返回的单位基本是ms)</li><li>磁盘扇区大小一般是512Byte，此时获取数据成本较高，因此无论读取数据多少，操作系统每次都是从磁盘中拿4K的数据</li></ul></li><li>内存寻址是ns级，带宽很大；磁盘比内存寻址慢了10w倍</li><li>计算机的2个基础设施<ul><li>冯诺依曼体系的硬件</li><li>以太网，tcp/ip的网络</li></ul></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="CPU-的基本组成"><a href="#CPU-的基本组成" class="headerlink" title="CPU 的基本组成"></a>CPU 的基本组成</h3><ul><li>PC(Program Counter) 程序计数器(记录当前指令地址)</li><li>Registers 寄存器，暂时存储 CPU 计算需要用到的数据，速度比内存快很多<ul><li>Intel 的寄存器如：AX/BX…(16 位)，EAX/EBX…(32 位)，RAX/RBX…(64 位)</li><li>64 位机器(CPU)一般指寄存器一次性可以存储 64 位，ALU 一次性也可读取 64 位</li></ul></li><li>ALU(Arithmetic &amp; Logic Unit) 运算单元。如从寄存器的 AX 中读取 2，BX 中读取 3，然后通过 ALU 进行运算得到 5，并将 5 存储在如 DX 中，最后写回内存</li><li>CU(Control Unit) 控制单元<ul><li>由指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)三个部件组成</li></ul></li><li>MMU(Memory Management Unit) 内存管理单元</li><li>cache</li></ul><h3 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h3><ul><li><p>一个 ALU 对应多个 PC 和 Registers，即所谓的 4 核 8 线程，一个核如下</p><p> <img src="/data/images/linux/超线程.png" alt="超线程"></p></li></ul><h3 id="三级缓存和伪共享"><a href="#三级缓存和伪共享" class="headerlink" title="三级缓存和伪共享"></a>三级缓存和伪共享</h3><ul><li><a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">三级缓存和伪共享</a></li><li>按块读取<ul><li>从硬盘往内存读，从内存往缓存读都是按块读取的，从而提高效率。充分发挥总线、CPU 针脚一次性读取更多数据的能力</li></ul></li><li><p>三级缓存</p><p> <img src="/data/images/linux/三级缓存.png" alt="三级缓存"></p><ul><li>CPU 缓存可以分为一级缓存(L1)，二级缓存(L2)，部分高端 CPU 还具有三级缓存(L3)<ul><li>每一级缓存中所储存的全部数据都是下一级缓存的一部分，越靠近 CPU 的缓存越快也越小，所以 L1 缓存很小但很快</li><li>L1,L2 只能被单独的 CPU 核使用</li><li>L3 被单个插槽上的所有 CPU 核共享</li></ul></li><li>主存(常说的内存)则由全部插槽上的所有 CPU 核共享</li><li>每个核都有自己私有的 L1,、L2 缓存。那么多线程编程时，另外一个核的线程想要访问当前核内 L1、L2 缓存行的数据，该怎么办呢？<ul><li>有人说可以通过第 2 个核直接访问第 1 个核的缓存行，这是当然是可行的，但这种方法不够快。跨核访问需要通过 Memory Controller（内存控制器，是计算机系统内部控制内存并且通过内存控制器使内存与 CPU 之间交换数据的重要组成部分），典型的情况是第 2 个核经常访问第 1 个核的这条数据，那么每次都有跨核的消耗。更糟的情况是，有可能第 2 个核与第 1 个核不在一个插槽内，况且 Memory Controller 的总线带宽是有限的，扛不住这么多数据传输</li><li>所以，CPU 设计者们更偏向于另一种办法： 如果第 2 个核需要这份数据，由第 1 个核直接把数据内容发过去，数据只需要传一次</li><li>由此，第 2 个核修改了这份数据，那么第 1 个核原来的数据就成了脏数据，解决方式就是通过 <strong>EMSI</strong> 协议进行缓存行操作(见下文)</li></ul></li></ul></li><li>伪共享<ul><li>缓存系统中是以缓存行(cache line, 通常是 64 字节)为单位存储的，当多线程修改互相独立的变量时(发起的 RFO 请求会耗性能)，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享</li></ul></li><li>解决伪共享<ul><li>JDK7 中很多采用缓存行填充(空间换时间)。Disruptor 就是通过缓存行填充实现，参考<a href="/_posts/java/concurrence.md#Disruptor">concurrence.md#Disruptor</a></li><li>JDK8 开始可以使用@Contended 注解(需加 JVM 参数：-XX:-RestrictContended)来避免伪共享</li></ul></li><li>缓存行对齐(缓存行填充)<ul><li>对于有些特别敏感的数字，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存航对齐的编程方式</li></ul></li></ul><h3 id="MESI协议及RFO请求"><a href="#MESI协议及RFO请求" class="headerlink" title="MESI协议及RFO请求"></a>MESI协议及RFO请求</h3><ul><li>现代CPU的数据一致性实现通过缓存锁(MESI …) + 总线锁(老的CPU直接通过锁总线，L2连接L3时的总线)</li><li>MESI(M 修改, E 专有, S 共享, I 无效)、MSI、MOSI 及 Dragon Protocol 等都是为了解决缓存一致性的协议<ul><li>MESI主要是Inter处理一致性的解决方法</li></ul></li><li>RFO(Request For Owner)请求，为 MESI 协议中需要将当前核心的某缓存行设置为 E，将其他核心的该缓存行设置为 I</li></ul><h3 id="WC-合并写技术"><a href="#WC-合并写技术" class="headerlink" title="WC 合并写技术"></a>WC 合并写技术</h3><ul><li>WC(Write Combining) 合并写</li><li>某些计算机在寄存器和三级缓存之间还有其他缓存，如与 L1 之间有 Load Buffer、Store Buffer，与 L2 之间有 WC Buffer，他们的空间很小，但是速度比三级缓存快</li><li>由于 ALU 速度太快，所以在写入 L1 的同时写入一个 WC Buffer，满了之后，再直接更新到 L2(因为 L1 最终需要写入到 L2)，大小一般是 4 个字节</li></ul><details><br><summary>WC合并写技术程序证明</summary><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runCaseTwo比runCaseOne更快(但是runCaseTwo循环次数更多，且写入的数据多)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="comment">// 7个写操作</span></span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="comment">// 4个写操作</span></span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="comment">// 4个写操作</span></span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h3 id="乱序执行与防止指令重排"><a href="#乱序执行与防止指令重排" class="headerlink" title="乱序执行与防止指令重排"></a>乱序执行与防止指令重排</h3><ul><li>乱序执行<ul><li>CPU 执行命令时并不一定完全按照程序代码一行行的执行，而会进行指令重排，当 CPU 在进行读等待的同时执行指令，最终结果不会有影响。CPU 乱序的是为了提高效率</li><li>as-if-serial：不管如何重排序，单线程执行的结果不变，看上去像是 serial</li><li>程序证明：<a href="https://preshing.com/20120515/memory-reordering-caught-in-the-act/" target="_blank" rel="noopener">jvm/jmm/Disorder.java</a></li></ul></li><li>禁止乱序<ul><li>CPU 层面<ul><li>使用内存屏障或锁总线<ul><li>如 Intel 底层使用内存屏障，对应原语(lfence 读屏障 sfence 写屏障 mfence 混合屏障)。sfence 表示：在某个 sfence 指令之前的写指令为 A 指令集，在其后的写指令为 B 指令集，此时 A 指令必须在 B 指令之前完成</li><li>如 Intel lock 汇编指令，执行后会锁住内存子系统来确保执行顺序，甚至跨多个 CPU</li></ul></li><li>lock 指令一般 CPU 都有，但是内存屏障可能部分品牌没有内存屏障原语支持，HotSpot 直接使用了 lock 指令来防止指令重排</li></ul></li><li>JVM 层级<ul><li>JSR(JVM 规范)内存屏障(LL LS SL SS)<ul><li>LoadLoad(LL)：对于 Load1;LoadLoad;Load2;这样的指令，Load2 即之后读操作要在 Load1 读操作之后完成。其他如 LoadStore 类似</li></ul></li><li>volatile禁止指令重排即使用了内存屏障，参考<a href="/_posts/java/concurrence.md#volatile">concurrence.md#volatile</a></li></ul></li></ul></li><li>JVM 规定重排序必须遵守 8 个 hanppens-before 原则</li><li>案例：DCL 单例(双重检查单例，Double Check Lock)必须配合 volatile，此时 volatile 即达到了指令重排的作用</li></ul><h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><ul><li>UMA(Uniform Memory Access)：多个 CPU 通过一个总线访问同一个内存。但缺点是 CPU 增加导致资源抢占，工业测试证明 4 颗效果最好</li><li>NUMA(Non Uniform Memory Access)：非同一内存访问</li><li>ZGC - NUMA aware：分配内存会优先分配该线程所在 CPU 的最近内存</li></ul><p><img src="/data/images/linux/UMA-NUMA.png" alt="UMA-NUMA"></p><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ul><li>kernel 内核作用：负责调度 CPU，管理内存、文件系统、进度调度、设备驱动等</li><li>内核分类<ul><li>宏内核：PC、phone</li><li>微内核：弹性部署、5G、IoT。用户请求某个内核，这个内核可能无法处理，他会请求其他内核进行处理(也可能联网请求，如控制冰箱内核、电视内核等)</li><li>外核：为应用定制操作系统，科研中(多租户 request-based GC JVM)</li></ul></li><li>内核态与用户态<ul><li>cpu 分不同的指令级别：0 1 2 3</li><li>linux 内核跑在 ring 0 级，用户程序跑在 ring 3，对于系统的关键访问(如访问硬件)，需要经过 kernel 的同意，保证系统健壮性</li><li>内核执行的操作：200 多个系统调用，sendfile read write pthread fork 等</li><li>站在 OS 老大的角度，JVM 就是个普通程序</li></ul></li></ul><h3 id="进程-线程-纤程"><a href="#进程-线程-纤程" class="headerlink" title="进程/线程/纤程"></a>进程/线程/纤程</h3><ul><li>进程和线程<ul><li><strong>进程是 OS 分配资源的基本单位，线程是执行调度的基本单位</strong><ul><li>某个进程获的CPU执行时间，此时可能执行此进程下的不同线程，直到此进程失去CPU执行时间</li></ul></li><li>一个进程可以包括多个线程</li><li>每个进程都有独立的代码和数据空间(程序上下文)，进程之间切换开销大(需要保存和恢复上下文)；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器(PC)，线程之间切换的开销小<ul><li>进程是 OS 分配资源的基本单位，一个进程的内存空间是共享的，每个线程都可以使用这些共享内存</li></ul></li></ul></li><li>纤程<ul><li>用户态的线程，线程中的线程，切换和调度不需要经过 OS。java 的 new Thread 与 OS 系统的线程一一对应</li><li>优势<ul><li>切换和调度不需要和内核打交道。如线程要和内核打交道，因此中途会调用 80 软中断(见下文)，效率会低</li><li>占有资源很少，OS 启动一个线程大约要 1M 空间，启动一个 Fiber 纤程大约需要 4K</li><li>纤程切换比较简单，线程切换较耗时。可以启动很多个 10W+，OS 启动 1W 个线程时进行切换就会较耗时</li></ul></li><li>目前支持内置纤程的语言：Kotlin、Scala、Go、Python(lib)… Java(需要 open jdk 的 loom 库支持)</li></ul></li><li>进程在 linux 中也称 task，是系统分配资源的基本单位<ul><li>资源：独立的地址空间、内核数据结构(进程描述符等)、全局变量、数据段等</li><li>进程描述符：PCB(Process Control Block)</li></ul></li><li>进程创建和启动<ul><li>系统函数 fork() exec()</li><li>从 A 中 fork B 的话，A 称之为 B 的父进程</li></ul></li><li>僵尸进程<ul><li>父进程产生子进程后，会维护子进程的一个 PCB 结构，子进程退出，由父进程释放；如果父进程没有释放，那么子进程成为一个僵尸进程</li><li><code>ps -ef | grep defunct</code> 查询所有的僵尸进程，此时只能杀掉父进程才会从 ps 中消失</li></ul></li><li>孤儿进程<ul><li>子进程结束之前，父进程已经退出，孤儿进程会成为 init 进程的孩子，由 1 号进程进行维护</li></ul></li></ul><details><br><summary>僵尸进程和孤儿进程案例</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 僵尸进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复制一个子进程出来</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="comment">// 会在子进程中运行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child id is %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 会在主进程中运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孤儿进程</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;<span class="built_in">string</span>.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child ppid is %d\n"</span>, getppid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent ppid is %d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><ul><li>进程类型<ul><li>IO 密集型：大部分时间用于等待 IO</li><li>CPU 密集型：大部分时间用于计算</li></ul></li><li>进程(任务)调度<ul><li>发展过程为从单任务独占到多任务分时，最大限度的压榨 CPU 资源</li><li>多任务的抢占式和非抢占式<ul><li>非抢占式(cooperative multitasking)：除非进程主动让出 cpu(yielding)，否则一直运行</li><li>抢占式(preemptive multitasking，采用较多)：由进程调度器强制开始或暂停(抢占)某一进程的执行</li></ul></li></ul></li><li>linux 普通进程调度<ul><li>linux2.5 采用经典 Unix O(1)调度策略(执行时间均匀分配)，偏向服务器，但对 UI 交互不友好</li><li>linux2.6.23 采用 <code>CFS</code> (Completely Fair Scheduler) 完全公平调度算法<ul><li>按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间少于他应该分配的比例，则优先执行</li></ul></li></ul></li><li>进程优先级<ul><li>实时进程 &gt; 普通进程(0 -&gt; 99)</li><li>普通进程则按照 nice 值(-20 -&gt; 19)</li><li>linux 默认调度策略<ul><li>实时进程：使用SCHED_FIFO(按照优先级来)和SCHED_RR(优先级一样则轮询)两种</li><li>普通进程：使用CFS</li><li>默认执行等级为 FIFO 的实时进程，且 linux 会一致执行它，除非自己让出 CPU、更高等级的 FIFO、同 FIFO 等级的 RR 抢占它。只有实时进程主动让出或者执行完毕，普通进程才有机会执行</li></ul></li></ul></li><li>进程间通信方式。参考：<a href="https://blog.csdn.net/qq_39507723/article/details/97811048" target="_blank" rel="noopener">https://blog.csdn.net/qq_39507723/article/details/97811048</a><ul><li>共享内存通信(配合信号量实现同步)</li><li>管道通信：半双工的通信方式，数据只能单向流动</li><li>消息队列通信：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>套接字(socket)通信：可用于不同机器间的进程通信</li></ul></li></ul><h3 id="Copy-On-Write写时复制"><a href="#Copy-On-Write写时复制" class="headerlink" title="Copy-On-Write写时复制"></a>Copy-On-Write写时复制</h3><ul><li><code>Copy-on-write</code>，简称COW，写时复制。是一种计算机程序设计领域的优化策略</li><li>Linux的COW<ul><li>fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间) <a href="https://juejin.im/post/6844903702373859335" target="_blank" rel="noopener">^1</a></li><li>实现原理<ul><li>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份给调用者(修改者)，其余的页还是共享父进程的</li><li>修改时才会复制，只会复制异常页，而不是整个共享内存</li><li>如linux的管道符就是基于fork()完成，具体参考<a href="/_posts/linux/shell.md#特殊符号">特殊符号-管道符<code>|</code></a></li></ul></li><li>特点<ul><li>COW技术可减少分配和复制大量资源时带来的瞬间延时</li><li>COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制</li><li>缺点：如果在fork()之后，父子进程都还需要继续进行大量写操作，那么会产生大量的分页错误(页异常中断page-fault)</li></ul></li></ul></li><li>Redis的COW（基于linux的COW）<ul><li>Redis在持久化时，如果是采用bgsave命令或者bgrewriteaof的方式，那Redis会fork出一个子进程来读取数据，从而写到磁盘中</li><li>总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断page-fault)，这样就得耗费不少性能在复制上</li><li>而在rehash阶段上，写操作是无法避免的。所以Redis在fork出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存</li></ul></li><li><p>Java的COW（和linux的COW无关）<a href="https://zhuanlan.zhihu.com/p/136428913" target="_blank" rel="noopener">^2</a></p><ul><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只截取了部分 CopyOnWriteArrayList 代码片段 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明<ul><li>COWList 读操作是无锁的</li><li>COWList 写与写之间是互斥的</li><li>底层持有的数组变量 array 是通过 volatile 修饰的</li></ul></li></ul></li></ul></li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li><strong>中断为硬件或软件要和内核打交道的处理信号</strong>。硬件像磁盘，网卡，键盘，时钟等；软中断如80中断</li><li>在微机系统中，对于外部中断，中断请求信号是由外部设备产生，并施加到CPU的NMI或INTR引脚上，CPU通过不断地检测NMI和INTR引脚信号来识 别是否有中断请求发生。对于内部中断，中断请求方式不需要外部施加信号激发，而是通过内部中断控制逻辑去调用</li><li>中断处理过程<ul><li>请求中断</li><li>响应中断</li><li>关闭中断(CPU不再响应其他中断)</li><li>保留断点</li><li>中断源识别</li><li>保护现场(将断点处各寄存器的内容压入堆栈保护起来)</li><li>中断服务子程序</li><li>恢复现场(指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值)</li><li>中断返回</li></ul></li><li>中断向量表：0-255号，每一个对应一个处理程序，中断时需要据此判断执行的中断处理程序。记录如键盘对应的处理程序，鼠标对应的处理程序等，其中128(0x80)即为软中断</li><li>软中断<ul><li>又称 <strong>80 中断/系统调用</strong>，指软件产生的中断，<strong>即用户空间的处理程序需要调用内核空间的函数</strong>，应该尽量避免出现软中断(中断处理过程较长)</li><li>软中断方式：int 0x80(80 中断，interrupt 128) 或者 sysenter 原语(更先进)</li><li>调用过程：通过 ax 寄存器填入系统调用号(内核函数的编号)，参数通过 bx cx dx si di 传入内核，返回值写到 ax 进行返回</li><li>如 java 读网络的中断过程：jvm read() - c 库 read() - 内核空间 - system_call()系统调用处理程序 - sys_read()</li></ul></li><li>可使用<code>strace</code>查看程序的系统调用情况</li><li>基于汇编理解软中断<ul><li><code>yum install nasm</code> 搭建汇编环境</li><li>编译 <code>nasm -f elf hello.asm -o hello.o</code></li><li>链接 <code>ld -m elf_i386 -o hello hello.o</code> 生成一个 hello 可执行文件</li><li>执行 <code>./hello</code></li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;hello.asm</span></span><br><span class="line"><span class="comment">;分号开头为注释</span></span><br><span class="line"><span class="comment">;write(int fd, const void *buffer, size_t nbytes)</span></span><br><span class="line"><span class="comment">;fd 文件描述符 file descriptor(不同的介质对应不同的文件描述符，如网络、文件、标准输出) - linux下一切皆文件</span></span><br><span class="line"></span><br><span class="line">section data ;数据段声明</span><br><span class="line">    msg db "Hello", 0xA ;要输出的字符串加换行</span><br><span class="line">    len equ $ - msg ;字符串长度</span><br><span class="line"></span><br><span class="line">section .text ;代码段声明</span><br><span class="line">global _start ;指定入口函数</span><br><span class="line">_start: ;在屏幕上显示一个字符串的函数</span><br><span class="line"></span><br><span class="line">    mov edx, len ;参数三，将len数据保存在寄存器dx中</span><br><span class="line">    mov ecx, msg ;参数二</span><br><span class="line">    mov ebx, 1 ;参数一，文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80 ;调用80中断，即调用内核功能(write)</span><br><span class="line"></span><br><span class="line">    mov ebx, 0 ;参数一，退出代码</span><br><span class="line">    mov eax, 1 ;sys_exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><ul><li>一个程序的执行过程，要么处于用户态，要么处于内核态(调用了软中断)</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>内存管理的发展历程<ul><li>DOS 时代：同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）。内存大概 64K 数量级</li><li>windows9x(windows95 等)：多个进程装入内存，内存大概 16M 数量级。产生了问题：内存不够用、互相打扰</li><li>为了解决上述两个问题，诞生了现在的内存管理系统：分页装入、虚拟地址、软硬件结合寻址</li></ul></li></ul><h3 id="分页装入、虚拟地址、软硬件结合寻址"><a href="#分页装入、虚拟地址、软硬件结合寻址" class="headerlink" title="分页装入、虚拟地址、软硬件结合寻址"></a>分页装入、虚拟地址、软硬件结合寻址</h3><ul><li>分页装入(解决内存不够用)<ul><li>内存中分成固定大小的页框(大小固定为 4K)，且程序(硬盘上)也分成 4K 大小的块，用到哪一块，加载那一块到内存的页框中(即Page Cache)。加载的过程中，如果内存已经满了，会把最不常用的一块放到 swap 分区，把最新的一块加载进来，这个就是著名的<strong>LRU(Least Recently Used)算法</strong>(见[msb#一#161#00:58:13])</li><li><strong>Page Cache</strong><ul><li>Page Cache以Page为单位(大小一般为4K，64位系统为8K)，缓存文件内容，存在于内核空间(只要内存空间有空余就可以存放Page Cache)。缓存在Page Cache中的文件数据，能够更快的被用户读写</li><li>从硬盘读取文件时，先拷贝到内核的Page Cache，并将FD文件描述符相关信息保存在用户程序内存，用户程序通过FD访问该文件<ul><li>如果两个进程读取一个文件，则此文件在磁盘的 Page Cache 是一个，只是每个进程的文件描述符(如记录了各自的该文件读写位置)不同</li><li>在第一次加载文件Page到内存时涉及到磁盘操作，相对较慢，之后再次访问此Page Cache相当于访问内存，速度回很快。如果访问的数据所在Page没有加载到内存，则会产生缺页中断，会将缺失的加载到磁盘；如果内存空间不足，会将不经常访问的放到Swap空间<ul><li><strong>缺页中断</strong>：需要用到页面内存中没有，产生缺页异常(中断)，由内核处理并从磁盘加载到内存</li></ul></li></ul></li><li>写入到内核Page Cache的pages成为脏页，稍后会由内核线程pdflush真正写入到硬盘上<ul><li><strong>脏页(Dirty Pages)</strong><ul><li>程序创建和修改文件则默认会有一个脏标识，直到内存使用超过设置阈值(如 10%)则会一次性将脏标识的数据刷到磁盘，并去掉脏标识。此时可能并不会从内存中移除，知道内存不足才会将未使用的Page Cache移出</li><li>脏页写回磁盘方法<ul><li>手动调用sync()或者fsync()系统调用把脏页写回<ul><li><code>sync</code> 函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数</li><li><code>fsync</code> 函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上</li><li><code>fdatasync</code> 函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性</li></ul></li><li>pdflush进程会定时把脏页写回到磁盘</li></ul></li><li>脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放</li></ul></li></ul></li><li>读写Page Cache是要经过内核的，从而会产生系统调用(80中断)。如Java的带Buffer写会先将数据存放在jvm(用户空间内存)中，然后一次性提交给内核，此时产生的系统调用少，因此效率高</li><li>缺点：容易丢数据<ul><li>数据会先写在 Page Cache 中，linux 根据配置，当占用一定内存大小才会将内存中脏页数据刷新到磁盘，如果此时突然断电则会丢失没来得及写入到磁盘的数据(如果正常关机则没事)</li></ul></li></ul></li><li><strong>Buffer Cache</strong><ul><li>Page cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，Page cache中的数据交给Buffer Cache</li><li>Page cache用来缓存文件数据，Buffer Cache用来缓存磁盘(块)数据。在有文件系统的情况下，对文件操作，那么数据会缓存到Page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到Buffer Cache</li><li>2.6内核中的Buffer Cache和Page cache在处理上是保持一致的，但是存在概念上的差别，page cache针对文件的cache，buffer是针对磁盘块数据的cache</li><li>cache是解决cpu与内存间的速度不对等问题，buffer是解决内存与磁盘间的速度不对等问题</li></ul></li></ul></li><li><p>虚拟内存(解决相互打扰问题)</p><ul><li>DOS Win31 等，各进程间内存可互相访问，容易相互影响</li><li>虚拟内存让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A 进程永远不可能访问到 B 进程的空间</li><li>虚拟空间大小为寻址空间大小，64 位系统为 2^64 byte，比物理空间大很多</li><li><p>计算机虚拟内存</p><p> <img src="/data/images/linux/计算机虚拟内存分段.png" alt="计算机虚拟内存分段"></p><ul><li>进程内部分段(格式固定)，段内部分页。需要该页的时候加载到物理内存的 page cache 中</li><li>站在进程的角度，好像是进程独占了内存和 CPU，上图中虚拟内存中含是一个映射的内核</li><li>共享库如汇编中调用 C 语言的一些函数，如 read、print 等函数库</li></ul></li><li>内存映射<ul><li>逻辑地址(偏移量) + 段的基地址 = 线性地址(虚拟空间地址)</li><li>线性地址再通过 OS + <strong>MMU</strong>(Memory Management Unit，放在 CPU 中)硬件映射为物理地址。此时只有 OS 知道物理的地址，因此相对安全</li></ul></li></ul></li><li>软硬件结合寻址<ul><li>原本内存和外部设备(如磁盘等 IO 设备)的交互必须经过 CPU(的寄存器)，如由 CPU 通过总线将磁盘的数据加载到内存</li><li>后来增加了<strong>DMA</strong>(Direct Memory Access，协处理器)设备，可直接让外部设备直接和内存进行交互。此时可提供读写效率，且不浪费 CPU</li></ul></li></ul><h2 id="内核同步机制"><a href="#内核同步机制" class="headerlink" title="内核同步机制"></a>内核同步机制</h2><ul><li>基本概念<ul><li>临界区（critical area）:访问或操作共享数据的代码段。简单理解：synchronized 大括号中部分（原子性）</li><li>竞争条件（race conditions）两个线程同时拥有临界区的执行权</li><li>数据不一致：data unconsistency 由竞争条件引起的数据破坏</li><li>同步（synchronization）避免 race conditions</li><li>锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在）。上锁解锁必须具备原子性</li><li>原子性（象原子一样不可分割的操作）</li><li>有序性（禁止指令重排）</li><li>可见性（一个线程内的修改，另一个线程可见）</li></ul></li><li>内核同步常用方法<ul><li><strong>原子操作</strong> – 内核中类似于 java 的 AtomicXXX(基于 cas，但是内核的原子操作是基于原语完成的)，位于<code>linux/types.h</code></li><li><strong>自旋锁</strong> – 内核中通过汇编支持的 cas，位于<code>asm/spinlock.h</code></li><li>读-写自旋 – 类似于 ReadWriteLock，可同时读，只能一个写。读的时候是共享锁，写的时候是排他锁</li><li><strong>信号量</strong> – 类似于 Semaphore(PV 操作 down up 操作 占有和释放)。重量级锁，线程会进入 wait(Java 的 Semaphore 是通过 cas 完成)，适合长时间持有的锁情况</li><li>读-写信号量 – downread upread downwrite upwrite（多个写，可以分段写，比较少用）分段锁</li><li>互斥体(mutex) – 特殊的信号量（二值信号量），类似 synchronized</li><li>完成变量 – 特殊的信号量（A 发出信号给 B，B 等待在完成变量上）。vfork() 在子进程结束时通过完成变量叫醒父进程，类似于(Latch)</li><li>BKL：大内核锁（早期，现在已经不用）</li><li><strong>顺序锁</strong>(内核 v2.6 开始) – 线程可以挂起的读写自旋锁，基于序列计数器：从 0 开始，写时+1，写完释放+1；读前发现单数，说明有写线程，可进行等待或读取临时值；读前未偶数，说明已经写完，可进行读取；读前读后序列一样，说明没有写线程打断</li><li>禁止抢占 – preempt_disable()</li><li>内存屏障 – 见<a href="#乱序执行与防止指令重排">乱序执行与防止指令重排</a></li></ul></li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>一#166</li><li>VFS(虚拟文件系统)<ul><li>Kernel 内部模块，为一颗目录树，每个节点可以找一个物理位置或网络接口，每个物理位置可以是不同的文件系统，如 FAT、EXT4。而 windows 看到的 C 盘/D 盘为物理文件系统</li><li><strong>inode 号</strong><ul><li>文件打开后的唯一 id 号。读文件时：一般先访问内核 - 打开目标文件 - inode 号被加载 - 加载元数据 - 内核读取数据到内存(在内存中开启一个 4k 大小的 page cache)</li><li><code>stat test.txt</code> 可查看到文件的 inode 号</li></ul></li></ul></li><li>FD(File Descriptor)文件描述符<ul><li>如果两个进程读取同一个文件，则 inode 号相同，只是各自的文件描述符(FD)不同。如一个读取到 A 位置，指针偏移量为 seek 5；另一个读取到 B 位置，指针偏移量为 seek 11</li><li>当 o = new OutputStream(…)时在操作系统就会产生一个 fd，可理解为把 fd 的引用赋值给 o</li></ul></li><li>darty 脏页<ul><li>page cache 被修改后会有一个 darty 标识，而 flush 到磁盘有不同的策略，如：程序手动控制，或者交由内核自动刷到磁盘</li></ul></li><li>文件类型，常见如<ul><li><code>-</code> 普通文件（可执行，图片，文本），type=REG</li><li><code>d</code> 目录，type=DIR</li><li><code>l</code> 链接，包括硬链接、软连接(修改其中一个文件，另外一个文件会自动变化)</li><li><code>b</code> 块设备。可以自制一个镜像，里面放入可执行程序，然后拷贝到其他地方进行使用</li><li><code>c</code> 字符设备，如标准输入输出，type=CHR</li><li><code>s</code> socket</li><li><code>p</code> pipeline</li><li><code>[eventpoll]</code></li></ul></li><li>示例</li></ul><details><br><summary>文件操作示例</summary><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 链接</span></span><br><span class="line">ln test.txt hard.link <span class="comment"># 创建硬链接，查看两个文件发现inode号相同，且文件引用计数增加</span></span><br><span class="line">ln -s test.txt soft.link <span class="comment"># 创建软连接，查看两个文件发现inode号不同，且文件引用计数不增加，如果文件丢失，则ll查看时会报红</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 块设备(自制简单镜像，并添加bash可执行程序)</span></span><br><span class="line"><span class="comment"># 从输入文件/dev/zero(无限个0, input file)，复制数据到输出文件mydisk.img文件中(output file)，blokc size块大小为1048576kb(1M)，总共有100块，即100M</span></span><br><span class="line">    <span class="comment"># dd if=/home of=/dev/sdb # 备份目录到另一磁盘</span></span><br><span class="line">    <span class="comment"># dd if=/dev/sdb of=/home # 恢复磁盘数据到某一目录</span></span><br><span class="line">    <span class="comment"># dd if=/dev/sda of=/dev/sdb # 拷贝磁盘到另外一个磁盘</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=mydisk.img bs=1048576 count=100</span><br><span class="line">losetup /dev/loop0 mydisk.img <span class="comment"># 用于设置循环设备。循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备</span></span><br><span class="line">mkfs.ext4 /dev/loop0 <span class="comment"># 格式化文件系统</span></span><br><span class="line">mkdir /mnt/io-test &amp;&amp; mount /dev/loop0 /mnt/io-test <span class="comment"># 挂载</span></span><br><span class="line"><span class="built_in">cd</span> /mnt/io-test</span><br><span class="line">mkdir bin &amp;&amp; cp /bin/bash bin <span class="comment"># 复制系统的bash可执行文件到镜像目录下</span></span><br><span class="line">ldd bin/bash <span class="comment"># 查看bash需要执行的动态链接库</span></span><br><span class="line">mkdir lib64 &amp;&amp; cp /lib64/&#123;libtinfo.so.5,libdl.so.2,libc.so.6,ld-linux-x86-64.so.2&#125; ./lib64/</span><br><span class="line">chroot ./ <span class="comment"># 切换根目录(必须将bash的依赖库也复制过来，才能执行成功)，会显示 bash-4.2# 的命令行(此时不能执行ls等命令，因为没有复制相应文件到此目录)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 文件描述符</span></span><br><span class="line"><span class="comment"># 在xshell的第一个session中执行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"abc\ndef\n123\n456"</span> &gt; fd-file</span><br><span class="line"><span class="built_in">exec</span> 7&lt; fd-file <span class="comment"># 创建7文件描述符(可以使用0-255)，输入(&lt;，中间不能有空格)来自fd-file文件(读取文件)</span></span><br><span class="line">ll /proc/$$/fd <span class="comment"># 查看当前进程的文件描述，发现有一个7u的文件</span></span><br><span class="line"><span class="comment"># 查看进程打开了哪些文件，$$表示当前进程pid，-o显示偏移</span></span><br><span class="line">    <span class="comment"># 显示FD信息(FD可以理解为指向文件的指针)：cwd当前工作目录，rtd根目录，txt文本域(进程加载时的可执行程序代码块，type=REG表示普通文件)、mem分配的内存空间(如动态链接库的挂载)、0u标准输入stdin、1u标准输出stdout、2u报错输出stderr(所有进程都有0u、1u、2u；u为可读可写，r为可读；type=CHR表示字符文件)、255u(用于在重定向时保留这些副本，如：`echo foo 1&gt;/dev/null 2&gt;/dev/null &gt;/proc/$$/fd/255` 打印foo)</span></span><br><span class="line">    <span class="comment"># OFFSET 读写文件的偏移(读到的位置，指针指到的位置)</span></span><br><span class="line">    <span class="comment"># NODE为 文件inode号</span></span><br><span class="line">lsof -op $$ <span class="comment"># 部分结果如下</span></span><br><span class="line">:&lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE OFFSET     NODE NAME</span><br><span class="line">bash    7281 root    0u   CHR  136,0    0t0        3 /dev/pts/0</span><br><span class="line">bash    7281 root    1u   CHR  136,0    0t0        3 /dev/pts/0</span><br><span class="line">bash    7281 root    2u   CHR  136,0    0t0        3 /dev/pts/0</span><br><span class="line">bash    7281 root    7r   REG  253,0    0t0 33611576 /root/io-test/fd-file</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">read</span> a 0&lt;&amp; 7 <span class="comment"># read读取一行。从7(7为文件描述符，所以需要加&amp;)指向的文件读取一行到变量a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span> <span class="comment"># 打印abc</span></span><br><span class="line">lsof -op $$ <span class="comment"># 再次查看打印(此时偏移量为0t4，读取了3个字符，指针指到第4个位置)：bash    7281 root    7r   REG  253,0    0t4 33611576 /root/io-test/fd-file</span></span><br><span class="line"><span class="comment"># 在xshell的第二个session中执行</span></span><br><span class="line"><span class="built_in">exec</span> 6&lt; fd-file</span><br><span class="line">lsof -op $$ <span class="comment"># 此时打印(偏移量为0，说明不同进程可以打开同一文件，只是FD不同)：bash    7311 root    6r   REG  253,0    0t0 33611576 /root/io-test/fd-file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 脏页</span></span><br><span class="line">cat /proc/vmstat | grep dirty <span class="comment"># 查看脏页数据量</span></span><br><span class="line">sysctl -a | grep dirty <span class="comment"># 查看系统对脏页的配置</span></span><br><span class="line">:&lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10 <span class="comment"># 后台阈值，当内存中脏页到达10%时，自动将脏页数据刷到磁盘</span></span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 30 <span class="comment"># 前台阈值，当内存中脏页到达30%时，禁止继续写入，等到脏页刷到磁盘后才允许继续写入</span></span><br><span class="line">vm.dirty_writeback_centisecs = 500</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">## socket</span></span><br><span class="line"><span class="built_in">exec</span> 8&lt;&gt; /dev/tcp/www.baidu.com/80 <span class="comment"># 创建8，输入输出(8&lt;&gt;中间不能有空格)指向百度的tcp连接(/dev/tcp目录看不到，但是确实存在)</span></span><br><span class="line">ll /proc/$$/fd <span class="comment"># lrwx------. 1 root root 64 Jun 23 08:11 8 -&gt; socket:[41512]</span></span><br><span class="line">lsof -op $$ <span class="comment"># bash    7311 root    8u  IPv4  41512    0t0      TCP localhost.localdomain:41854-&gt;180.101.49.12:http (ESTABLISHED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重定向(不是命令，是一种机制，重定向符前后命令会被隔开)</span></span><br><span class="line">cat fd-file xxx 1&gt; fd.out 2&gt; xxx.err <span class="comment"># 标准输出指向fd.out，错误输出指向xxx.err(此时xxx文件不存在会在xxx.err中写入"cat: xxx: No such file or directory")</span></span><br><span class="line">cat fd-file xxx 1&gt; cat.out 2&gt;&amp;1 <span class="comment"># 将标准输出和错误输出指向同一文件。重定向符前面是类型，后面一般是文件，如果不是文件则需要加重定向符后面加&amp;；且2&gt;&amp;1(或2&gt;&amp; 1)必须在后面，因为需要先把1指向cat.out，1才进行了定义</span></span><br><span class="line"><span class="built_in">read</span> a <span class="comment"># 默认标准输入为键盘</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>  <span class="comment"># 此时需要在命令行输入后回车</span></span><br><span class="line"><span class="built_in">read</span> a 0&lt; fd-file <span class="comment"># 此时指定标准输入为fd-file文件内容，会默认读取一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## [管道文件描述符](/_posts/linux/shell.md#特殊符号)</span></span><br><span class="line">&#123; <span class="built_in">echo</span> $$; <span class="built_in">echo</span> <span class="variable">$BASHPID</span>; <span class="built_in">read</span> x; &#125; | &#123; cat ; <span class="built_in">echo</span> <span class="variable">$BASHPID</span>; <span class="built_in">read</span> y; &#125; <span class="comment"># 回车打印9287、10371</span></span><br><span class="line">ps -ef | grep 9287 <span class="comment"># 重新打开一个session执行，发现9287产生了两个子进程10371、10372</span></span><br><span class="line">ll /proc/10371/fd <span class="comment"># 会显示一个管道文件描述符：l-wx------. 1 root root 64 Jun 23 08:59 1 -&gt; pipe:[42516]</span></span><br><span class="line">lsof -op 10371 <span class="comment"># 打开的文件为pipe管道：bash    10371 root    1w  FIFO    0,9    0t0    42516 pipe</span></span><br></pre></td></tr></table></figure><br><br></details><h3 id="io-nio"><a href="#io-nio" class="headerlink" title="io/nio"></a>io/nio</h3><ul><li>一#174</li><li>ByteBuffer指针移动图</li></ul><p><img src="/data/images/linux/ByteBuffer-position.png" alt="ByteBuffer-position"></p><ul><li>nio包中的ByteBuffer和FileChannel.map的读写过程</li></ul><p><img src="/data/images/linux/ButeBuffer-FileChannel.png" alt="ButeBuffer-FileChannel"></p><ul><li>代码示例</li></ul><details><br><summary>io/nio示例</summary><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_OSFileIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] data = <span class="string">"123456789\n"</span>.getBytes();</span><br><span class="line">    <span class="keyword">static</span> String path = <span class="string">"/root/io-test/out.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"0"</span>:</span><br><span class="line">                <span class="comment">// 循环写，会发现效率低于testBufferedFileIO</span></span><br><span class="line">                testBasicFileIO();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"1"</span>:</span><br><span class="line">                testBufferedFileIO();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"2"</span>:</span><br><span class="line">                testRandomAccessFileWrite();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"3"</span>:</span><br><span class="line">                testWhatByteBuffer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.编写如下启动脚本测试testBasicFileIO和testBufferedFileIO</span></span><br><span class="line"><span class="comment">     * rm -rf *out* # 为strace记录的日志文件(有多个线程所有有多个文件)，其中存储使用空间多的为主线程</span></span><br><span class="line"><span class="comment">     * javac T1_OSFileIO.java # 需提前去掉此类中的包名</span></span><br><span class="line"><span class="comment">     * strace -ff -o out java T1_OSFileIO $1 # 其中strace可监控用户空间进程和内核的交互，比如系统调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2.testBasicFileIO对应out文件日志如(每次都会调用系统方法写入到文件)</span></span><br><span class="line"><span class="comment">     * open("/root/io-test/out.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 5 # 获取到/root/io-test/out.txt的此进程文件描述符为5</span></span><br><span class="line"><span class="comment">     * fstat(5, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0</span></span><br><span class="line"><span class="comment">     * write(5, "123456789\n", 10)             = 10 # 对5号文件描述符(实际对应文件)进行写入</span></span><br><span class="line"><span class="comment">     * write(5, "123456789\n", 10)             = 10</span></span><br><span class="line"><span class="comment">     * write(5, "123456789\n", 10)             = 10</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.testBufferedFileIO对应日志文件如(写满8字节才会调用系统的write方法写入到文件)</span></span><br><span class="line"><span class="comment">     * open("/root/io-test/out.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 5</span></span><br><span class="line"><span class="comment">     * fstat(5, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * write(5, "123456789\n123456789\n123456789\n12"..., 8190) = 8190</span></span><br><span class="line"><span class="comment">     * write(5, "123456789\n123456789\n123456789\n12"..., 8190) = 8190</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4.由上述可见testBufferedFileIO的系统调用少，因此效率更高</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 最基本的file写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBasicFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Thread.sleep(10);</span></span><br><span class="line">            out.write(data);</span><br><span class="line">            <span class="comment">// out.flush();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试buffer文件IO。jvm会分配8kB的内存，当内存写满时会进行system_call write(8KB byte[])写到page cache</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBufferedFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Thread.sleep(10);</span></span><br><span class="line">            out.write(data);</span><br><span class="line">            <span class="comment">// out.flush();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试文件NIO</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAccessFileWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(path, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通(顺序)写</span></span><br><span class="line">        raf.write(<span class="string">"hello world\n"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"write------------"</span>);</span><br><span class="line">        <span class="comment">// 阻塞住程序，回车继续运行</span></span><br><span class="line">        <span class="comment">// 查看文件中的内容为 hello world(但是此时可能并不在磁盘上，只是在page cache上，还没有做刷写)</span></span><br><span class="line">        <span class="comment">// 此时通过`lsof -op &lt;pid&gt;`可发现此进程多了一个对该文件的读写文件描述符，如4u</span></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机写，将指针指到第5个字符后。可理解为文件描述符的偏移量</span></span><br><span class="line">        raf.seek(<span class="number">5</span>);</span><br><span class="line">        raf.write(<span class="string">",hi"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"seek---------"</span>);</span><br><span class="line">        System.in.read(); <span class="comment">// 此时文件内容为 hello,hirld</span></span><br><span class="line"></span><br><span class="line">        FileChannel rafChannel = raf.getChannel();</span><br><span class="line">        <span class="comment">// 调用系统mmap，进行linux进程堆外(设置大小为4096字节)和文件(page cache)的映射，此时是基于byte的读写，不是基于java的object</span></span><br><span class="line">        <span class="comment">// 只有文件才能进行mmap映射</span></span><br><span class="line">        MappedByteBuffer map = rafChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不是系统调用，但是数据会到达内核的page cache</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.曾经我们是需要out.write()这样的系统调用，才能让程序的data进入内核的page cache，必须有用户态内核态切换</span></span><br><span class="line"><span class="comment">         * 2.mmap的内存映射，依然是内核的page cache体系所约束的。换言之，可能丢数据</span></span><br><span class="line"><span class="comment">         * 3.可以去github上找一些其他C程序员写的jni扩展库，使用linux内核的Direct IO(直接IO)</span></span><br><span class="line"><span class="comment">         *   Direct IO是把page cache交给了程序自己开辟一个字节数组当作page cache(私有)，不经过系统读写page cache</span></span><br><span class="line"><span class="comment">         *   因此需要动用代码逻辑来维护一致性/dirty等一系列复杂问题，程序可以控制何时将page cache写入磁盘，但是从page cache写入磁盘的过程还是系统控制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map.put(<span class="string">"@@@"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"map-put--------"</span>);</span><br><span class="line">        <span class="comment">// 此时文件内容为 @@@lo,hirld</span></span><br><span class="line">        <span class="comment">// 此时通过`lsof -op &lt;pid&gt;`可发现此进程多了一个对该文件的内存映射：</span></span><br><span class="line">        <span class="comment">// java    7737 root  mem    REG              253,0            33621134 /root/io-test/out.txt</span></span><br><span class="line">        <span class="comment">// 并且文件的大小变成了4096(文件对应的page cache和堆外进行了映射，因此大小为上面设置的)</span></span><br><span class="line">        <span class="comment">// 到此，有上文4u和此处的mem都可以对此文件进行读写</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// map.force(); // flush</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机写，将指针指到第0个字符后</span></span><br><span class="line">        raf.seek(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试ByteBuffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">        <span class="comment">// ByteBuffer buffer = ByteBuffer.allocateDirect(8192); // 分配jvm堆外内存(但在linux进程堆内)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> read = rafChannel.read(buffer); <span class="comment">// 将rafChannel对应的文件内容读到buffer中，类似调用buffer.put()</span></span><br><span class="line">        System.out.println(<span class="string">"read: "</span> + read); <span class="comment">// 打印 read: 4096</span></span><br><span class="line">        System.out.println(buffer); <span class="comment">// java.nio.HeapByteBuffer[pos=4096 lim=8192 cap=8192] 或 java.nio.DirectByteBuffer[pos=4096 lim=8192 cap=8192]</span></span><br><span class="line"></span><br><span class="line">        buffer.flip(); <span class="comment">// ByteBuffer读写交替</span></span><br><span class="line">        System.out.println(buffer); <span class="comment">// java.nio.HeapByteBuffer[pos=0 lim=4096 cap=8192] 或 java.nio.DirectByteBuffer[pos=0 lim=4096 cap=8192]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.print(((<span class="keyword">char</span>) buffer.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWhatByteBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ByteBuffer buffer = ByteBuffer.allocate(1024);</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>); <span class="comment">// 分配jvm堆外内存(但在linux进程堆内)</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"position: "</span> + buffer.position()); <span class="comment">// 0，读写下标位置</span></span><br><span class="line">        System.out.println(<span class="string">"limit: "</span> + buffer.limit()); <span class="comment">// 1024，能读写的下标最大位置(每次执行flip会在position和capacity间切换)</span></span><br><span class="line">        System.out.println(<span class="string">"capacity: "</span> + buffer.capacity()); <span class="comment">// 1024，容量</span></span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=0 lim=1024 cap=1024] // 允许从0位置开始写入到1024位置</span></span><br><span class="line"></span><br><span class="line">        buffer.put(<span class="string">"123"</span>.getBytes()); <span class="comment">// 往buffer中写入数据</span></span><br><span class="line">        System.out.println(<span class="string">"-------------put:123......"</span>);</span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=3 lim=1024 cap=1024]</span></span><br><span class="line"></span><br><span class="line">        buffer.flip(); <span class="comment">// 读写交替(修改limit指向的位置)。则位置从0开始可最大读取到3位置(总共为3个字节)</span></span><br><span class="line">        <span class="comment">// 如果此时执行一次写入</span></span><br><span class="line">            <span class="comment">// 则flip下面打印java.nio.DirectByteBuffer[pos=1 lim=3 cap=1024]</span></span><br><span class="line">            <span class="comment">// get(返回2)下面打印java.nio.DirectByteBuffer[pos=2 lim=3 cap=1024]</span></span><br><span class="line">            <span class="comment">// compact下面打印java.nio.DirectByteBuffer[pos=1 lim=1024 cap=1024] // 前两个位置指针已经移动经过了</span></span><br><span class="line">        <span class="comment">// buffer.put("4".getBytes());</span></span><br><span class="line">        System.out.println(<span class="string">"-------------flip......"</span>);</span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=0 lim=3 cap=1024]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> c = buffer.get(); <span class="comment">// 读取一个字节</span></span><br><span class="line">        System.out.println(<span class="string">"-------------get......"</span> + (<span class="keyword">char</span>) c);</span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=1 lim=3 cap=1024]</span></span><br><span class="line"></span><br><span class="line">        buffer.compact(); <span class="comment">// 压缩。因为已经读走1个字节，还剩下2个字节，此时再写入时则可以从第2个位置开始写到1024个位置</span></span><br><span class="line">        System.out.println(<span class="string">"-------------compact......"</span>);</span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=2 lim=1024 cap=1024]</span></span><br><span class="line"></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空buffer</span></span><br><span class="line">        System.out.println(<span class="string">"-------------clear......"</span>);</span><br><span class="line">        System.out.println(<span class="string">"mark: "</span> + buffer); <span class="comment">// java.nio.DirectByteBuffer[pos=0 lim=1024 cap=1024]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><ul><li>一#177</li><li><p>TCP握手时服务器资源开辟流程</p><p> <img src="/data/images/linux/TCP握手时服务器资源开辟流程.png" alt="TCP握手时服务器资源开辟流程"></p></li><li><p>TCP相关参数，详细参考<a href="https://github.com/oldinaction/smjava/blob/master/netty/src/main/java/cn/aezo/netty/c3_io_tcp/T1_Server_Properties.java" target="_blank" rel="noopener">cn.aezo.netty.c3_io_tcp.T1_Server_Properties&amp;T1_Client</a></p><ul><li><p>backlog参数示意图</p><ul><li>tcp_max_syn_backlog是指定所能接受SYN同步包的最大客户端数量</li><li>somaxconn是指服务端所能accept，即处理数据的最大客户端数量</li></ul><p><img src="/data/images/linux/tcp-backlog.png" alt="tcp-backlog参数示意图"></p></li></ul></li><li><p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">C10K问题，即单机1万个并发连接问题</a> (一#184)</p><ul><li>BIO缺点<ul><li>阻塞的，从而每个客户端需要创建一个线程进行read</li><li>并且每次循环read，会产生无意义的系统调用(NIO也存在此缺点)</li></ul></li><li>NIO解决的问题和缺点<ul><li>NIO相比BIO优势：非阻塞时，可通过1个或几个线程，来解决N个IO连接的处理</li><li>仍存在的缺点：每循环一次，read为O(n)复杂度，很多read调用是无意义的(客户端并没有发数据过来)，但是每次会产生系统调用</li></ul></li><li>多路复用器(如netty中的)<ul><li>多路指多个IO，复用指进行一次系统调用，便可知道那些IO(文件描述符)是有数据的；然后用户程序对有数据的IO进行read调用</li><li>多路服务器包含select/poll/epoll等，详见下文</li></ul></li><li><p><a href="https://github.com/oldinaction/smjava/blob/master/netty/src/main/java/cn/aezo/netty/c4_io_c10k/C10KClient.java" target="_blank" rel="noopener">C10K测试客户端</a>，测试过程中关于路由问题如下图</p><p> <img src="/data/images/linux/io-nat-route.png" alt="io-nat-route"></p></li></ul></li><li>BIO/NIO下建立TCP连接时系统调用情况(通过strace监测)，详细参考<a href="https://github.com/oldinaction/smjava/blob/master/netty/src/main/java/cn/aezo/netty/c5_io_bio_nio/T1_Server_BIO.java" target="_blank" rel="noopener">cn.aezo.netty.c5_io_bio_nio.T1_Server_BIO&amp;T2_Server_NIO</a></li><li><p>多路复用器(一#185)</p><ul><li><a href="https://github.com/oldinaction/smjava/blob/master/netty/src/main/java/cn/aezo/netty/c6_io_multiplexing/SocketMultiplexingSingleThreadV1.java" target="_blank" rel="noopener">测试案例SocketMultiplexingSingleThreadV1.java</a></li><li>select/poll/epoll/kqueue =&gt; netty<ul><li><code>select</code>：synchronous I/O multiplexing，遵循POSIX规范的多路复用器，限制是一次调用只能检查FD_SETSIZ(1024)个文件描述符。man-pages(man select)中方法描述为<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code> timeout可已设置超时时间</li><li><code>poll</code>：wait for some event on a file descriptor，类似select，无FD_SETSIZ限制。方法为<code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></li><li><code>epoll</code>：I/O event notification facility，基于事件通知，包含epoll_create、epoll_ctr、epoll_wait。效率高于select/poll</li><li><code>kqueue</code>：类似epoll，只不过是unix系统上的</li></ul></li><li><p>多路复用器示意图</p><p> <img src="/data/images/linux/io-多路复用器.png" alt="io-多路复用器"></p></li><li><p>select/poll/epoll对比图</p><p> <img src="/data/images/linux/io-epoll_vs_select_poll.png" alt="io-epoll_vs_select_poll"></p></li><li>复杂度<ul><li>单路IO(BIO/NIO)，每次循环需要对有IO进行系统调用，复杂度为O(n)</li><li>多路复用器select/poll，每次select(fds)获取有状态的FD时，只需进行一次系统调用，复杂度为O(1)；但是对有状态的IO遍历read时，时间复杂度为O(m)<ul><li>无论NIO/SELECT/POLL都是要遍历所有的IO，询问状态</li><li>只不过NIO，这个遍历的过程成本在用户态内核态切换；多路复用器select/poll，这个遍历的过程触发了一次系统调用，用户态内核态的切换，每次会把fds传递给内核，内核重新根据用户这次调用传过来的fds，遍历修改状态</li><li>select/poll的弊端<ul><li>每次都要重新传递fds(内核开辟空间)</li><li>每次，内核被调了之后，针对这次调用，触发一个遍历fds全量的复杂度</li></ul></li></ul></li><li>多路复用器epoll，每次epoll_wait获取有状态IO时(类似select，只不过select是需要遍历)，是从链表中获取数据，复杂度为O(1)</li></ul></li></ul></li></ul><h2 id="汇编实现引导程序"><a href="#汇编实现引导程序" class="headerlink" title="汇编实现引导程序"></a>汇编实现引导程序</h2><ul><li>编写汇编码</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 文件名 boot.asm</span></span><br><span class="line"></span><br><span class="line">org 7c00h                     ; BIOS读入MBR后，从0x7c00h处开始执行。因此必须是7c00h</span><br><span class="line"></span><br><span class="line"><span class="comment">; 下面部分和10h有关中断，10h中断用来显示字符</span></span><br><span class="line">mov ax, cs</span><br><span class="line">mov es, ax</span><br><span class="line">mov ax, msg</span><br><span class="line">mov bp, ax                    ; ES:BP表示显示字符串的地址</span><br><span class="line">mov cx, msgLen                ; CX存字符长度</span><br><span class="line">mov ax, 1301h                 ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）</span><br><span class="line">mov bx, 000fh                 ; BH=00h表示页号，BL=0fh表示颜色</span><br><span class="line">mov dl, 0                     ; 列</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">msg: db "hello world, welcome to OS!"</span><br><span class="line">msgLen: equ $ - msg           ; 字符串长度</span><br><span class="line">times 510 - ($ - $$) db 0     ; 填充剩余部分</span><br><span class="line">dw 0aa55h                     ; 魔数，必须有这两个字节BIOS才确认是MBR</span><br></pre></td></tr></table></figure><ul><li>编译和制作启动软盘</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在centos上运行即可</span></span><br><span class="line">yum install nasm <span class="comment"># 安装汇编环境</span></span><br><span class="line">nasm boot.asm -o boot.bin <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制作启动软盘</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=floppy.img bs=1474560 count=1 <span class="comment"># 生成空白软盘镜像，大小必须为1.44M</span></span><br><span class="line">dd <span class="keyword">if</span>=boot.bin of=myos.img bs=512 count=1 <span class="comment"># 制作包含主引导记录boot.bin的启动镜像文件</span></span><br><span class="line">dd <span class="keyword">if</span>=floppy.img of=myos.img skip=1 seek=1 bs=512 count=2879 <span class="comment"># 在 bin 生成的镜像文件后补上空白，成为合适大小的软盘镜像，一共2880个扇区，略过第一个</span></span><br></pre></td></tr></table></figure><ul><li>用软盘启动系统<ul><li>将上述制作的软盘 myos.img 下载到 windows</li><li>VMWare 创建空的虚拟机<ul><li>文件 - 创建新的虚拟机 - 典型 - 稍后安装操作系统 - 其他(版本其他) - 一路 next 完成</li><li>虚拟机设置：去掉 CD/DVD 选项中”启动时连接” - 网络，选择”仅主机模式”，勾选”启动时连接” - 添加软盘驱动器，使用软盘映像，找到 myos.img</li><li>启动虚拟机</li><li>显示 hello world, welcome to OS!</li></ul></li></ul></li><li><a href="http://www.ruanyifeng.com/blog/2015/09/0x7c00.html" target="_blank" rel="noopener">为什么主引导记录的内存地址是 0x7C00?</a></li></ul><hr><p>参考文章</p></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> smalle</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://blog.aezo.cn/2020/06/16/linux/计算机底层知识/" title="计算机底层知识">http://blog.aezo.cn/2020/06/16/linux/计算机底层知识/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/java/" rel="tag"># java</a> <a href="/tags/cpu/" rel="tag"># cpu</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/05/17/db/mysql的锁机制/" rel="next" title="Mysql锁机制"><i class="fa fa-chevron-left"></i> Mysql锁机制</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2020/06/24/lang/powershell/" rel="prev" title="PowerShell">PowerShell<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/15698218?v=3&u=ce740bf0b67ff0d74990ba6fc644d6e92f572dcb&s=400" alt="smalle"><p class="site-author-name" itemprop="name">smalle</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">155</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">140</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#书籍推荐"><span class="nav-number">1.</span> <span class="nav-text">书籍推荐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件基础知识"><span class="nav-number">2.</span> <span class="nav-text">硬件基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见指标"><span class="nav-number">2.1.</span> <span class="nav-text">常见指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU"><span class="nav-number">3.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-的基本组成"><span class="nav-number">3.1.</span> <span class="nav-text">CPU 的基本组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超线程"><span class="nav-number">3.2.</span> <span class="nav-text">超线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三级缓存和伪共享"><span class="nav-number">3.3.</span> <span class="nav-text">三级缓存和伪共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MESI协议及RFO请求"><span class="nav-number">3.4.</span> <span class="nav-text">MESI协议及RFO请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WC-合并写技术"><span class="nav-number">3.5.</span> <span class="nav-text">WC 合并写技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乱序执行与防止指令重排"><span class="nav-number">3.6.</span> <span class="nav-text">乱序执行与防止指令重排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NUMA"><span class="nav-number">3.7.</span> <span class="nav-text">NUMA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS"><span class="nav-number">4.</span> <span class="nav-text">OS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内核"><span class="nav-number">4.1.</span> <span class="nav-text">内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-线程-纤程"><span class="nav-number">4.2.</span> <span class="nav-text">进程/线程/纤程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Copy-On-Write写时复制"><span class="nav-number">4.3.</span> <span class="nav-text">Copy-On-Write写时复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断"><span class="nav-number">4.4.</span> <span class="nav-text">中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分页装入、虚拟地址、软硬件结合寻址"><span class="nav-number">5.1.</span> <span class="nav-text">分页装入、虚拟地址、软硬件结合寻址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核同步机制"><span class="nav-number">6.</span> <span class="nav-text">内核同步机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">7.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">7.1.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-nio"><span class="nav-number">7.2.</span> <span class="nav-text">io/nio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络IO"><span class="nav-number">7.3.</span> <span class="nav-text">网络IO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编实现引导程序"><span class="nav-number">8.</span> <span class="nav-text">汇编实现引导程序</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 - <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">smalle</span>&nbsp;&nbsp;&nbsp;&nbsp;<div class="powered-by"> 由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="powered-by"> 主题 - <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div><div class="theme-info cnzz" style="margin:0 0 -5px 10px"><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?"https://":"http://";document.write(unescape("%3Cspan id='cnzz_stat_icon_1276691827'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s23.cnzz.com/z_stat.php%3Fid%3D1276691827%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"))</script></div></div><div class="ad"> <span style="font-weight:700">AD&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=oby5nolb">阿里云大礼包</a></div></div><div class="aezocn"> <span style="font-weight:700">@AEZO.CN&nbsp;&nbsp;&nbsp;&nbsp;</span><div class="theme-info"> <a target="_blank" href="http://shop.aezo.cn/">杂货铺</a></div></div><script>"use strict";!function(){var n=window.driftt=window.drift=window.driftt||[];if(!n.init){if(n.invoked)return window.console&&console.error&&console.error("Drift snippet included twice.");n.invoked=!0,n.methods=["identify","config","track","reset","debug","show","ping","page","hide","off","on"],n.factory=function(e){return function(){var t=Array.prototype.slice.call(arguments);return t.unshift(e),n.push(t),n}},n.methods.forEach(function(t){n[t]=n.factory(t)}),n.load=function(t){var e=3e5*Math.ceil(new Date/3e5),n=document.createElement("script");n.type="text/javascript",n.async=!0,n.crossorigin="anonymous",n.src="https://js.driftt.com/include/"+e+"/"+t+".js";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(n,r)}}}(),drift.SNIPPET_VERSION="0.3.1",drift.load("e4wbzuxev4zt")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?d82223039d601f2f819f8fe140a63468";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script></body></html>